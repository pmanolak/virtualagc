<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Verilog Simulation of AGC</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Hardware Simulation Page").replace("@SUBTITLE@","Digital Simulation of the AGC Electronics"))</script>
    <h1><a name="Contents"></a>Contents</h1>
    <ul>
      <li><a href="#Introduction">Introduction</a><br>
      </li>
      <li><a href="#References">References</a></li>
      <li><a moz-do-not-send="true" href="#WorkstationSetup">Workstation
          Setup</a><br>
      </li>
      <li><a href="#An_Example:_testVerilog">First Example: Simulating a
          Small Digital Circuit</a></li>
      <li><a moz-do-not-send="true" href="#EntireAGC">Big Example:&nbsp;
          Simulating an Entire AGC</a></li>
      <ul>
        <li><a moz-do-not-send="true" href="#AGCchoices">Choices To Make</a></li>
        <li><a moz-do-not-send="true" href="#AGCworkflow">The Workflow</a></li>
        <li><a moz-do-not-send="true" href="#Transactions">Enhanced
            Viewing of an AGC's Simulation Results</a><br>
        </li>
      </ul>
      <ul>
      </ul>
      <li><a href="#Appendix:_Translation_from_KiCad_into">Technical
          Appendix</a></li>
      <ul>
        <li><a moz-do-not-send="true" href="#AGCSoftwareForSimulation">AGC




            Software for Simulation Purposes</a><br>
        </li>
      </ul>
      <ul>
        <li><a moz-do-not-send="true" href="#CreatingSchematic">Transcribing/Editing











            a Schematic Diagram with eeschema</a><br>
        </li>
        <li><a moz-do-not-send="true" href="#CreatingNetlists">Creating
            a Netlist with eeschema</a><br>
        </li>
        <li><a href="#Converting_Netlist_to_Verilog">Converting Netlists
            to Verilog Source code with dumbVerilog.py<br>
          </a></li>
        <li><a moz-do-not-send="true" href="#PinsTxt">The pins.txt File</a><br>
        </li>
        <li><a href="#Generating_Flip-flop_Initialization">The
            module.init file, dumbInitialization.py, and
            dumbInitialization0.py</a><br>
        </li>
        <li><a href="#Converting_Verilog_Module_to_Verilog">Converting
            Verilog Module(s) to Verilog Test Bench</a></li>
        <li><a moz-do-not-send="true" href="#compilation">Compilation of
            the Verilog Source Code</a><br>
        </li>
        <li><a moz-do-not-send="true" href="#RunningTheSimulation">Running







            the Simulation</a></li>
        <li><a moz-do-not-send="true" href="#visualization">Visualization</a><br>
        </li>
        <li><a moz-do-not-send="true" href="#tying">Tying It All
            Together</a><br>
        </li>
      </ul>
    </ul>
    <h1><a name="Introduction"></a>Introduction</h1>
    <p>Digital simulation of the AGC electrical design can provide
      detailed insight into how the computer functions.&nbsp; Aside from
      satisfying simple personal interest, this is very valuable if you
      wish to create a simulation of the AGC, in the manner of Virtual
      AGC Project's <a href="http://www.ibiblio.org/apollo/yaAGC.html">Block










        II AGC software simulator</a> or <a
        href="Block1.html#Virtual_AGCs_CPU_Simulator_yaAGCb1">Block I
        AGC software simulator</a>, or John Pultorak's <a
href="http://www.ibiblio.org/apollo/Pultorak.html#John_Pultoraks_Block_I_AGC">Block
I











        AGC hardware simulator</a>, and want to have some way of
      verifying that your creation works properly.<br>
    </p>
    <p>Realize, though, that the purpose of such simulations can only be
      accurate examination or verification of AGC behavior, and they are
      not practical substitutes for software (such as our <a
        moz-do-not-send="true" href="yaAGC.html"><b>yaAGC</b></a>
      program) designed and dedicated solely to running AGC
      software.&nbsp; While you <i>can</i> use digital electrical
      simulations to run AGC software, these simulations are very much
      slower than real time.&nbsp; One day, as computer speeds continue
      to advance, I expect that digital electrical simulations will be
      much faster than now!&nbsp; But "faster than now" is not <i>now</i>.&nbsp;










      Recognize too that while simulation of the AGC or DSKY's <i>analog</i>
      circuitry is also possible, that's not what I'm talking about
      here.&nbsp; It is simulation of the digital circuitry — i.e., the
      collection of logic gates in the AGC — that will be of interest.<br>
    </p>
    <p>Here's an executive summary of the workflow of the
      digital-simulation process as I envisage it, and which will be
      used throughout the remainder of this page:&nbsp; <br>
    </p>
    <table cellspacing="2" cellpadding="2" height="739" border="1"
      align="center">
      <tbody>
        <tr>
          <th valign="bottom">#<br>
          </th>
          <th valign="bottom">Workflow Step<br>
          </th>
          <th valign="bottom">Comment<br>
          </th>
        </tr>
        <tr>
          <td valign="middle">1<br>
          </td>
          <td valign="middle">The electrical schematics — in our case,
            the original schematics of the AGC — are transcribed for use
            with modern schematic-capture software.</td>
          <td valign="middle">The schematic-capture software in question
            is called <a moz-do-not-send="true"
              href="https://www.kicad.org/"><b>KiCad</b> EDA</a>.&nbsp;
            The transcribed schematic files are <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">here</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">2<br>
          </td>
          <td valign="middle">Netlists — i.e., files that list every
            electrical connection in a given electrical schematic — are
            created.<br>
          </td>
          <td valign="middle"><b>KiCad</b> itself creates the netlist
            files.&nbsp; There are many different formats of netlist
            files, all containing roughly the same information.&nbsp;
            For our workflow, the specific format known in <b>KiCad</b>
            as ORCAD PCB 2 is required.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">3<br>
          </td>
          <td valign="middle">The netlists+schematics+initial conditions
            are translated into Verilog source code.</td>
          <td valign="middle"> <a moz-do-not-send="true"
              href="https://en.wikipedia.org/wiki/Verilog">Verilog</a>
            is a high-level hardware description language.&nbsp; The
            translation into Verilog source code is performed by <a
              moz-do-not-send="true"
              href="https://github.com/virtualagc/virtualagc/tree/schematics/Scripts">a
              Python 3 script called <b>dumbVerilog.py</b></a> that we
            provide, assisted by another such script that's called <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/dumbInitialization.py"><b>dumbInitialization.py</b></a>.&nbsp;










            <br>
            <br>
            <b>Note:</b>&nbsp; These scripts are specialized for AGC
            digital circuits ~1970, and will not produce anything useful
            when applied to non-AGC circuitry or to analog circuitry.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">4<br>
          </td>
          <td valign="middle">A "test bench" — i.e., a description in
            Verilog source code of the external inputs into the emulated
            circuitry vs time — is written.</td>
          <td valign="middle">There's a helpful Python 3 script, <b><a
                moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/dumbTestbench.py">dumbTestbench.py</a></b>,
            which can automate a little of this for you, but the script
            can't read your mind (yet!), so you still have to make some
            choices for yourself.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">5<br>
          </td>
          <td valign="middle">A model of the Erasable/Fixed Memory —
            i.e., the executable form of the AGC software that the
            emulated AGC circuitry is going to run — is converted into
            Verilog source code.</td>
          <td valign="middle"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/roms">This











              has already been done</a>, at least for an incomplete
            selection of the AGC software versions available to us.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">6<br>
          </td>
          <td valign="middle">The Verilog source code for the AGC
            circuitry, the test bench, and the erasable/fixed memory are
            compiled together into an executable form.</td>
          <td valign="middle">Our workflow specifically uses the <a
              moz-do-not-send="true"
              href="https://en.wikipedia.org/wiki/Icarus_Verilog">Icarus
              Verilog</a> (<b>iVerilog</b>) compiler for this.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">7<br>
          </td>
          <td valign="middle">The executable Verilog program is then run
            in an emulator. <br>
          </td>
          <td valign="middle">Our workflow uses the <b>iVerilog</b>
            emulator for this.&nbsp; Typically, this creates a "dump
            file" of whichever of the AGC's signals were considered to
            be interesting when the test bench was written.</td>
        </tr>
        <tr>
          <td valign="middle">8<br>
          </td>
          <td valign="middle">The output data dumped by the emulation is
            viewed as waveforms, similar to an oscilloscope, or else is
            post-processed in some other manner.</td>
          <td valign="middle">Our workflow uses a program called <a
              moz-do-not-send="true"
              href="https://gtkwave.sourceforge.net/"><b>GTKWave</b></a>
            for this visualization of the results.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Regarding the choice
        of software used in the workflow&nbsp;</font><font size="-1"><font
          size="-1">— i.e., the holy trinity <b>KiCad</b>, <b>iVerilog</b>,
          and <b>GTKWave</b> </font>—, disagreement as to whether
        these are the optimal choices is always possible, and indeed
        likely if you happen to be a person with expertise in this
        particular area.&nbsp; The programs were chosen because they are
        free of charge (and indeed are open source, like the Virtual AGC
        Project itself) and available for Linux, Windows, and Mac
        OS.&nbsp; If you can make it work with the fancier tools a
        professional may have at their disposal, then by all means do so
        and let me know.&nbsp; I won't change an open-source workflow
        into a non-open-source workflow no matter how terrific an
        alternate tool may be, but at least I'll be interested to hear
        the news and can parrot it back to the general public!<br>
      </font></blockquote>
    <p>Although multiple types of simulation are possible, we'll
      concentrate just on these particular configurations:<br>
    </p>
    <ul>
      <li>A full AGC, consisting of multiple "logic modules"
        interconnected via a backplane into which they plug.<br>
      </li>
      <li>A single logic module, or portion thereof.<br>
      </li>
    </ul>
    One slight point of confusion is that in the AGC design, the various
    plug-in circuits are called "modules", while Verilog also uses the
    term "modules" for its constructs that are similar to "functions" or
    "subroutines" in other programming languages.&nbsp; Now as it
    happens, we've implemented the simulation in such a way that each
    AGC module <i>actually is</i> modeled as a single Verilog
    module.&nbsp; That's more-or-less a coincidence, though, and if you
    attempt to work with any simulations that differ from those we've
    pre-prepared for you, you may have to watch out for the dual meaning
    of this term.<br>
    <br>
    In the unlikely event that you have KiCad 5 and refuse to upgrade
    it, consult <a moz-do-not-send="true" href="Verilog-KiCad-5.html">the


      older version of this page</a>.<br>
    <ul>
    </ul>
    <h1><a name="References"></a>References</h1>
    <p><a href="ElectroMechanical.html">The Virtual AGC Project's
        Electro-Mechanical page</a>.<br>
    </p>
    <p>Apollo-era AGC/DSKY electrical-schematic diagrams:<br>
    </p>
    <ul>
      <li>Block I AGC/DSKY schematic diagrams redrawn in AC Electronics
        Manual ND-1021041, with theory of operation: <a
          href="https://archive.org/details/apollocommandmodacel">Volume
          1</a> and <a
          href="https://archive.org/details/apollocommandmodacel_0">Volume











          2</a>.<br>
      </li>
      <li><a href="klabs/history/agc_schematics_block2/">Scans of the
          original electrical-schematic drawings for Block II AGC p/n
          2003993.</a> <br>
      </li>
      <li><a href="https://archive.org/details/agc_handbook_jp2">Scans
          of the original electrical-schematic drawings for Block II AGC
          p/n 2003100 &amp; 2003200, and associated DSKYs.</a>&nbsp; <br>
      </li>
      <li>Block II AGC/DSKY schematic diagrams redrawn in AC Electronics
        Manual ND-1021042, with theory of operation: <a
          href="Documents/acelectroniclmma00acel_0.pdf">Volume 2</a>.<br>
      </li>
      <li><a
          href="ElectroMechanical.html#Appendix:_Index_and_Links_to_all_AGC_">Drawing-by-drawing
index











          into the items above.</a></li>
    </ul>
    AGC/DSKY electrical schematics transcribed into KiCad
    electrical-design software, plus Verilog translations:<br>
    <ul>
      <li><a
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">GitHub











          repository</a></li>
    </ul>
    <p>Open-source software:<br>
    </p>
    <ul>
      <li><a href="http://kicad-pcb.org/">KiCad (Electrical
          schematic-capture CAD)</a></li>
      <li><a
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/dumbVerilog.py">KiCad-to-Verilog
translator











          script</a></li>
      <li><a href="http://iverilog.icarus.com/">Icarus Verilog (Verilog
          compiler and simulator)</a></li>
      <li><a href="http://gtkwave.sourceforge.net/">GTKWave (viewer for
          waveforms output by Icarus Verilog)</a></li>
    </ul>
    <p>Mike Stewart's similar transcription + simulation effort:<br>
    </p>
    <ul>
      <li><a href="https://github.com/virtualagc/agc_hardware/">KiCad
          schematics</a></li>
      <li><a href="https://github.com/virtualagc/agc_simulation/">Verilog











          translations</a></li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; It should be noted that the
          AGC simulations described on this page were <i>not</i> based
          on Mike Stewart's pre-existing project, other than in
          spirit.&nbsp; Mike's simulation was a very important resource
          in the sense that cross comparisons of the results output by
          Mike's implementation with those output by mine provided a way
          to detect errors in both implementations that would not have
          been easily discoverable otherwise.&nbsp; And I can honestly
          tell you that it would never even have occurred to me to try
          this if Mike hadn't already done what he did!&nbsp; It's very
          much a case of "me too!" on my part. &nbsp; With that said,
          there are some pros and cons (described later) that work in
          both directions.&nbsp; My schematics closely match the
          original AGC schematics, so closely that you can overlay them,
          while Mike's schematics are intended to be — and I believe,
          are! — <i>functionally</i> identical to the original
          schematics, but impossible to verify vs the original
          schematics without considerable intellectual effort.&nbsp;
          Mike's version is more efficient in the sense that his
          simulation runs significantly faster than mine ... but you
          can't compare his side-by-side with the original schematics to
          verify correctness as you can with mine.&nbsp; Which approach
          you prefer is a matter of taste.&nbsp; What I'll be discussing
          <i>here</i> is my own approach rather than Mike's.</font><br>
      </p>
    </blockquote>
    <ul>
    </ul>
    <h1><a name="WorkstationSetup"></a>Workstation Setup</h1>
    <p>If you are using Virtual AGC via the Virtual AGC 64-bit Virtual
      Machine, then everything is already set up for you.<br>
    </p>
    <p>If not, you'll want to install the following software on your
      computer:<br>
    </p>
    <ul>
    </ul>
    <ul>
      <li><a moz-do-not-send="true" href="https://www.kicad.org/">KiCad
          EDA</a></li>
      <li><a moz-do-not-send="true"
          href="https://steveicarus.github.io/iverilog/">Icarus Verilog</a><br>
      </li>
      <li><a moz-do-not-send="true"
          href="https://gtkwave.github.io/gtkwave/">GTKWave</a></li>
    </ul>
    <p>Note that KiCad 7 or later should probably be used, since I
      myself have KiCad 7.<br>
    </p>
    <p>On Ubuntu Linux or Debian Linux, or derivatives of either of them
      like Linux Mint, installation of the three programs mentioned
      above is as simple as using the command "<font color="#663300"><code>sudo







          apt install kicad iverilog gtkwave</code></font>"; with Red
      Hat or Fedora, I believe but don't guarantee that you could use "<font
        color="#663300"><code>sudo yum install kicad iverilog gtkwave</code></font>";







      on other Linux platforms, Solaris, or FreeBSD there's likely to be
      some easy way, but you'll have to research it yourself.<br>
    </p>
    <p>On Windows, install KiCad from the installer found at the
      hyperlink given above; watch for an option to add the KiCad
      command-line program (kicad-cli.exe) to your PATH, and if there is
      such an option then be sure to take advantage of it.&nbsp; There's
      also an <a moz-do-not-send="true"
        href="https://bleyer.org/icarus/">installer providing both
        Icarus Verilog and GTKWave</a>, and I'd suggest using it rather
      than the individual hyperlinks given above.&nbsp; But note that
      you'll find some additional setup instructions at the end of this
      section.<br>
    </p>
    <p>On Mac OS, the least-painful approach would seem to be installing
      <a moz-do-not-send="true" href="https://brew.sh/">homebrew</a>, if
      you don't already have it, and then using <b>brew</b> to install
      the three programs rather than doing anything recommended at the
      links above.<br>
    </p>
    <ul>
      <li><font color="#663300"><code>brew install --cask kicad</code></font><br>
      </li>
      <li><font color="#663300"><code>brew install icarus-verilog</code></font></li>
      <li><font color="#663300"><code>brew install --HEAD
            randomplum/gtkwave/gtkwave</code><font color="#000000"> </font><br>
        </font></li>
      <li>Close any open command-line terminals.<br>
      </li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; While the foregoing advice
          about Mac OS results in an easy installation, there are things
          about the process that are unpleasant and perhaps warrant a
          few words of warning so that you won't be blind-sided when you
          encounter them.&nbsp; <br>
        </font></p>
      <ul>
        <li><font size="-1">KiCad:&nbsp; Expect that the first usage
            after installation of any of the programs in the KiCad suite
            (including <b>kicad-cli</b>) will take a <i>very</i> long
            time to load.&nbsp; Load times of the KiCad applications
            after that first load take a much more reasonable amount of
            time. <br>
          </font></li>
        <li><font size="-1">Icarus Verilog:&nbsp; A pleasure!<br>
          </font></li>
        <li><font size="-1"><font size="-1">GTKWave:&nbsp; At some point
              in the installation, it will abort and insist that you
              change ownership and permissions of a couple of folders
              before retrying the installation.&nbsp; Whether this is
              good to do as a security matter, I'm not qualified to say;
              moreover, the installation will take a long time, measured
              in hours rather than minutes because of the many, many
              prerequisites it has to build.&nbsp; Supposedly there is a
              second possibility, "<a moz-do-not-send="true"
                href="https://formulae.brew.sh/cask/gtkwave#default">brew




                install --cask gtkwave</a>", but this command has been
              deprecated and (I believe) does not actually result in a
              functional gtkwave.<br>
            </font></font></li>
      </ul>
    </blockquote>
    <p>On all operating systems, download <a moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/schematics">the











        "schematics" branch of the Virtual AGC repository</a> from
      GitHub.&nbsp; There are many different ways you might do this,
      depending on your computer platform and personal tastes, and I
      wouldn't presume to dictate to you.&nbsp; For the sake of
      discussion, however, I'll assume that you've done this by creating
      a folder called "virtualagc-schematics" in your home
      directory.&nbsp; For example, if you have the <b>git</b> program
      installed on your computer, you could do it with a command like:<br>
    </p>
    <blockquote>
      <pre>git clone --depth=1 -b schematics https://github.com/virtualagc/virtualagc.git virtualagc-schematics<br></pre>
    </blockquote>
    <p>Install Python 3 if not already installed, and then install the
      Python module TatSu:<br>
    </p>
    <blockquote>
      <pre>pip install tatsu<br></pre>
    </blockquote>
    <p>or perhaps<br>
    </p>
    <blockquote>
      <pre>pip3 install tatsu</pre>
    </blockquote>
    <p>or perhaps<br>
    </p>
    <blockquote>
      <pre>pip[3] install --break-system-packages tatsu<br></pre>
    </blockquote>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; This
          "<font color="#663300"><code>--break-system-packages</code></font>"
          option doesn't imply that there's anything wrong with the
          TatSu package.&nbsp; Rather, it relates to a wonderful new
          trend of using Python environments which are "externally
          managed", in which <i>no new Python modules whatever</i> can
          be installed in the default environment without this </font><font
          size="-1"><font size="-1">"<font color="#663300"><code>--break-system-packages</code></font>"
          </font>command-line option.&nbsp;&nbsp; Isn't that a lovely
          development in user-friendliness?&nbsp; Easily-extensible
          systems that can't be extended? &nbsp; Ubuntu has it; Mac OS
          has it; soon, everybody may have it.&nbsp; Oh brave new world
          that has such stuff in it!</font><br>
      </p>
    </blockquote>
    <p>Within the virtualagc-schematics folder (or whatever you chose to
      call it) you've just created, you'll find a folder called
      "Scripts".&nbsp; Add the path to this Scripts folder into your
      PATH environment variable.&nbsp; Depending on your particular
      computer platform, the way of doing that varies.&nbsp; But the
      following should usually work:<br>
    </p>
    <ul>
      <li>Linux: Add the line "<code>export PATH=$PATH:</code><code><i>PathToScripts</i></code>"
        to the file ~/.bashrc using a text editor.</li>
      <li>Mac OS: Add the line "<code>export PATH=$PATH:</code><code><i>PathToScripts</i></code>"
        to <i>both</i> of the files ~/.bashrc and ~/.zprofile using a
        text editor.</li>
      <li>Windows:&nbsp; I'd suggest opening up the desktop menu and
        searching for "edit environment variables".&nbsp; Edit the
        "Path" variable for your account and add <code><i>PathToScripts</i></code>
        to it.</li>
    </ul>
    <i>Extra Environment Variables for Windows and Mac OS:&nbsp; </i><br>
    <ul>
      <li>The folder you just added to the PATH needs also to be added
        to a probably-new environment variable called PYTHONPATH if
        you'd like all of the instructions you'll find in the text below
        to work for you.&nbsp; Use the same technique as described above
        for editing the PATH.</li>
    </ul>
    <p><i>Even More Environment Variables for Windows:</i><br>
    </p>
    <ul>
      <li>After installing KiCad, perform the test of opening a command
        line and using the command "kicad-cli".&nbsp; if you are told
        that kicad-cli cannot be found, then you have encountered <a
          moz-do-not-send="true"
          href="https://gitlab.com/kicad/code/kicad/-/issues/19639">a
          bug in the KiCad installer</a>, which you ought to work around
        by adding the folder containing the kicad-cli.exe file to your
        PATH.&nbsp; For me, that folder was C:\Users\<i>USERNAME</i>\AppData\Local\Programs\KiCad\8.0\bin.&nbsp;







        For you, it may turn out to be different.</li>
    </ul>
    <p>It's likely that the changes to the PATH or PYTHONPATH won't
      affect any existing command line terminals which are already open,
      so you'll probably have to open a new command-line terminal to get
      the benefit of the change(s).</p>
    <h1><a name="An_Example:_testVerilog"></a>First Example: Simulating
      a Small Digital Circuit<br>
    </h1>
    <p>The Virtual AGC software repository already contains some
      fully-worked out examples of digital simulations. The simplest
      example is something called "<a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/testVerilog">testVerilog</a>",











      which is actually a small circuit block extracted from the AGC's
      circuit module A1, the "scaler" module.&nbsp; Per the installation
      instructions in the preceding section, all of the workflow steps
      will be carried out in the folder
      virtualagc-schematics/Schematics/testVerilog/.&nbsp; The results
      given below were generated using KiCad v6, but any later version
      should work as well, I hope. <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; My intent is to walk you
          through the steps of the simulation workflow.&nbsp; If you
          haven't the fortitude for that — I understand and forgive you!
          —, there's a script (<b>simulateModuleII</b> or <b>simulateModuleII.bat</b>)
          which can do all of the work for you and just present you with
          the visualization of the simulation data created by the
          workflow.&nbsp; If you feel strong enough, then take the high
          road and skip past <b>simulateBlockII</b> to the main
          narrative instead of running the script.<br>
        </font></p>
      <p><font size="-1">But if you must, here's how to take the low
          road and use the script.&nbsp; For KiCad 7 or later, you can
          do the following (with \ in place of / in Windows):<br>
        </font></p>
      <blockquote>
        <pre><font size="-1">cd virtualagc-schematics/Schematics/testVerilog<br>simulateModuleII A1</font> <br></pre>
      </blockquote>
      <p><font size="-1">It's slightly more involved for KiCad 6:<br>
        </font></p>
      <blockquote>
        <pre><font size="-1">cd virtualagc-schematics/Schematics/testVerilog<br># Edit module.kicad_sch in eeschema and generate netlist file module.net,<br># via eeschema's <u>File</u>/<u>Export</u>/<u>Netlist</u>/<u>OrcadPCB2</u>/<u>Export Netlist</u>.<br># Then exit eeschema.<br>eeschema module.kicad_sch<br>simulateModuleII A1 module.net</font> <br></pre>
      </blockquote>
      <font size="-1">After the simulation completes, <a
          moz-do-not-send="true" href="#simple8">you can just jump down
          to workflow step #8</a> to see the simulation data displayed
        in a visualization program.</font><br>
    </blockquote>
    <p>Workflow Step #1:&nbsp; We've actually transcribed this circuit
      for you already as a file called module.kicad_sch, so you needn't
      do anything.&nbsp; Still, just to give you an idea how it works,
      here's very high-level summary.<br>
    </p>
    <p>Start with the original Apollo Program schematic-diagram drawing
      for module A1, which is drawing 2005259A, two sheets (click to
      enlarge):<br>
    </p>
    <div align="center"><a
        href="klabs/history/agc_schematics_block2/logic/a01-1.jpg"><img
          src="a01-1-small.jpg" alt="" width="300" height="241"
          border="2"></a>&nbsp; <a
        href="klabs/history/agc_schematics_block2/logic/a01-2.jpg"><img
          src="a01-2-small.jpg" alt="" width="300" height="239"
          border="2"></a><br>
    </div>
    <p>Don't be confused by the fact that the inputs of NOR gates in the
      circuit are decorated with little triangles that make the gates
      look like rocket ships.&nbsp; (Was it intentional, I
      wonder?)&nbsp; They're just regular NOR gates in spite of
      that.&nbsp; The numbered oval pads are the inputs from or outputs
      to the AGC backplane into which the various AGC circuitry modules
      plug.&nbsp; Perhaps I should also point out that the NOR gates
      used in the AGC were open-drain gates, in which you can directly
      tie together outputs from different gates (effectively AND'ing
      them without any literal AND gate).&nbsp;&nbsp; <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; I won't cover here how to
          actually transcribe paper drawings of electrical schematics
          into KiCad schematic files.&nbsp; It's a complicated
          affair.&nbsp; Just any old transcription won't do.&nbsp; And
          honestly, you may not have to understand how to make
          transcriptions anyway, since I've already transcribed all of
          the pre-existing AGC schematics for you.&nbsp; Nevertheless,
          in the Appendix there's <a moz-do-not-send="true"
            href="#Converting_Netlist_to_Verilog">a list of some of the
            rules</a> you'd have to follow to get schematic files that
          are usable for our simulation workflow.&nbsp; There are also
          common-sense rules that aren't covered in the Appendix, such
          as "you have to use wires for electrical interconnections
          rather than just lines".&nbsp; One rule not in the Appendix
          that I've personally followed in order to make verification of
          correctness of the transcriptions much simpler is that the
          transcribed schematics should appear to be so visually
          identical to the originals that you can overlay them with
          nothing perceptibly out of place.&nbsp; There's no technical
          necessity for that particular rule.&nbsp; Mike Stewart's
          transcriptions, for example, are designed entirely for
          functional correctness and have no visual resemblance whatever
          to the originals.&nbsp; On the other hand, Mike's
          transcriptions don't follow the rules laid out in the Appendix
          either, so certain steps in our simulation workflow (which
          post-date Mike's transcriptions) will fail.&nbsp; In case
          you're wondering how to transcribe a circuit so as to make it
          visually identical to the original, KiCad's schematic capture
          program, <b>eeschema</b>, allows you to use a JPG image as
          the backdrop of your schematic.&nbsp; Thus if you use the
          scanned images (as seen above) for your backdrops in <b>eeschema</b>,
          you can almost-trivially insure that all of your components
          and wires are in exactly the right places, which also helps to
          insure that the nets in the transcription are as they should
          be. </font><br>
      </p>
    </blockquote>
    <p>Transcriptions which follow the rules in the Appendix (and my
      additional criteria) look like this: <br>
    </p>
    <div align="center"><a href="KiCad/2005259A-p1of2.png"><img
          src="2005259A-p1of2-small.png" alt="" width="300" height="232"
          border="2">&nbsp; </a><a href="KiCad/2005259A-p2of2.png"><img
          src="2005259A-p2of2-small.png" alt="" width="300" height="232"
          border="2"></a><br>
    </div>
    <p>Now as I mentioned, AGC module A1 is the "scaler" circuit.&nbsp;
      If you want to read about it in some detail, you can look at <a
href="https://archive.org/stream/acelectroniclmma00acel#page/n290/mode/1up">section
4-5.3.4











        of document ND-1021042</a>, which covers the theory of operation
      of this module.&nbsp; The module's purpose is to take a clock
      signal called FS01/ (a 51.2 KHz square wave), which you can see
      coming into the module from the AGC's backplane near the upper
      left on the first sheet of the schematic, and to run it through a
      sequence of identical circuit blocks that successively cut the
      frequency of that signal in half, as follows, outputting those
      slower clocks back to the AGC's backplane:<br>
    </p>
    <ul>
      <li>Output signal FS02 is 25.6 KHz</li>
      <li> Output signal FS03 is 12.8 KHz</li>
      <li>...</li>
      <li>Output signal FS33 is 0.000011921 Hz</li>
    </ul>
    <p>ND-1021042 has <a moz-do-not-send="true"
        href="Documents/apollolunarexcuracel_0.pdf#page=367">a handy
        table</a> listing all of the values for FS01 through FS17, but
      for whatever reason doesn't deign to list FS18 through FS33 for
      us.<br>
    </p>
    <p>To simplify things, the testVerilog example cuts this all down so
      that just the <i>first</i> of the many divide-by-two circuit
      blocks.&nbsp; The abridged circuit produces the output signal FS02
      from input signal FS01/ and implements what's known to electrical
      engineers as a "flip-flop". &nbsp; Here is an image of that
      circuit:<br>
    </p>
    <div align="center"><img src="testVerilogCircuit.png" alt=""
        width="446" height="382"><br>
    </div>
    <p>Workflow Step 2:&nbsp; One way to create the netlist is to load
      the schematic file into <b>eeschema</b>, then from the main menu
      select File/Export/Netlist/OrcadPCB2/ExportNetlist and create a
      file called module.net.&nbsp; For this discussion, I did this
      using KiCad v6, and got the resulting file<br>
    </p>
    <blockquote>
      <p>
        <meta http-equiv="content-type" content="text/html;
          charset=UTF-8">
      </p>
      <pre style="color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; white-space: pre-wrap;"><font color="#663300" face="Courier">( { EESchema Netlist Version 1.1 created  Tue 14 Jan 2025 05:51:55 AM CST }<br> ( /00000000-0000-0000-0000-00005d281baf $noname  J2 ConnectorA1-200<br>  (  202 Net-(J2-Pad202) )<br>  (  204 Net-(J2-Pad204) )<br>  (  205 Net-(J2-Pad205) )<br>  (  206 Net-(J2-Pad206) )<br>  (  208 Net-(J2-Pad208) )<br>  (  209 Net-(J2-Pad209) )<br>  (  212 0VDCA )<br>  (  222 +4VDC )<br>  (  236 0VDCA )<br>  (  250 +4VDC )<br>  (  260 0VDCA )<br> )<br> ( /00000000-0000-0000-0000-00005d281ba1 $noname  U129 D3NOR-+4VDC-0VDCA-ABC-E_F<br>  (    1 Net-(U127-Pad8) )<br>  (    2 Net-(J2-Pad202) )<br>  (    3 Net-(J2-Pad205) )<br>  (    4 Net-(U127-Pad2) )<br>  (    5 0VDCA )<br>  (    6 0VDCA )<br>  (    7 Net-(U127-Pad8) )<br>  (    8 Net-(J2-Pad204) )<br>  (    9 Net-(J2-Pad202) )<br>  (   10 +4VDC )<br> )<br> ( /00000000-0000-0000-0000-00005d281b3e $noname  U126 D3NOR-+4VDC-0VDCA-A_B-E_F<br>  (    6 0VDCA )<br>  (    7 Net-(U126-Pad7) )<br>  (    8 Net-(J2-Pad206) )<br>  (    9 Net-(J2-Pad208) )<br> )<br> ( /00000000-0000-0000-0000-00005d281b94 $noname  U127 D3NOR-+4VDC-0VDCA-B_C-E_F<br>  (    1 Net-(U126-Pad7) )<br>  (    2 Net-(U127-Pad2) )<br>  (    3 Net-(J2-Pad204) )<br>  (    4 0VDCA )<br>  (    5 0VDCA )<br>  (    6 0VDCA )<br>  (    7 Net-(U126-Pad7) )<br>  (    8 Net-(U127-Pad8) )<br>  (    9 Net-(J2-Pad204) )<br>  (   10 +4VDC )<br> )<br> ( /00000000-0000-0000-0000-00005d281b45 $noname  U128 D3NOR-+4VDC-0VDCA-ABC-E_F<br>  (    1 Net-(U127-Pad2) )<br>  (    2 Net-(U127-Pad8) )<br>  (    3 Net-(J2-Pad205) )<br>  (    4 Net-(J2-Pad209) )<br>  (    5 0VDCA )<br>  (    6 0VDCA )<br>  (    7 Net-(U126-Pad7) )<br>  (    8 Net-(U127-Pad2) )<br>  (    9 Net-(J2-Pad209) )<br>  (   10 +4VDC )<br> )<br>)<br>*</font><br></pre>
    </blockquote>
    Workflow Step #3: Conversion to Verilog source code.&nbsp; <br>
    <br>
    The Verilog source code is created by the following steps in Linux:<br>
    <blockquote><font color="#663300" face="Courier 10 Pitch">dumbVerilog.py










        A1 <font face="Courier 10 Pitch">module</font>.net pins.txt 20
        ../empty<font face="Courier 10 Pitch">.init</font>
        module.kicad_sch &gt;<font face="Courier 10 Pitch">module</font>.v<br>
        dumbInitialization0.py &lt;module.v<br>
      </font><font color="#663300" face="Courier 10 Pitch"><font
          face="Courier 10 Pitch">dumbVerilog.py A1 <font face="Courier
            10 Pitch">module</font>.net pins.txt 20 A1<font
            face="Courier 10 Pitch">.init</font> module.kicad_sch &gt;<font
            face="Courier 10 Pitch">module</font>.v</font></font> </blockquote>
    In Windows, it would instead be<br>
    <blockquote><font color="#663300" face="Courier 10 Pitch">python -m
        dumbVerilog A1 <font face="Courier 10 Pitch">module</font>.net
        pins.txt 20 ..\empty<font face="Courier 10 Pitch">.init</font>
        module.kicad_sch &gt;<font face="Courier 10 Pitch">module</font>.v<br>
        python -m dumbInitialization0 &lt;module.v<br>
      </font><font color="#663300" face="Courier 10 Pitch"><font
          face="Courier 10 Pitch">python -m dumbVerilog A1 <font
            face="Courier 10 Pitch">module</font>.net pins.txt 20 A1<font
            face="Courier 10 Pitch">.init</font> module.kicad_sch &gt;<font
            face="Courier 10 Pitch">module</font>.v</font></font> </blockquote>
    While in Mac OS, it would be<br>
    <blockquote><font color="#663300" face="Courier 10 Pitch">python3 -m
        dumbVerilog A1 <font face="Courier 10 Pitch">module</font>.net
        pins.txt 20 ..\empty<font face="Courier 10 Pitch">.init</font>
        module.kicad_sch &gt;<font face="Courier 10 Pitch">module</font>.v<br>
        python3 -m dumbInitialization0 &lt;module.v<br>
      </font><font color="#663300" face="Courier 10 Pitch"><font
          face="Courier 10 Pitch">python3 -m dumbVerilog A1 <font
            face="Courier 10 Pitch">module</font>.net pins.txt 20 A1<font
            face="Courier 10 Pitch">.init</font> module.kicad_sch &gt;<font
            face="Courier 10 Pitch">module</font>.v</font></font> </blockquote>
    The details of this procedure are covered in <a
      moz-do-not-send="true"
      href="#Appendix:_Translation_from_KiCad_into">the technical
      Appendix</a>.&nbsp; In brief, pins.txt is a file describing
    backplane connections that are appropriate for AGC models 2003200 or
    2003993, though it doesn't really serve any purpose here since the
    backplane is used only to interconnect multiple logic modules,
    whereas this circuit uses only a portion of a single logic module
    and thus doesn't connect to any other logic modules.&nbsp; 20 is the
    propagation delay of the NOR gates in nanoseconds.&nbsp; As I
    mentioned before, in this example circuit the various NOR gates form
    a flip-flop.&nbsp; The file A1.init is used to specify whether the
    flip-flop is initially "on" or "off" at the start of the digital
    simulation.&nbsp; It is a file that you can create manually — though
    generally with considerable inconvenience —, and the purpose of the
    first two steps of the process above is to heuristically create a
    version of A1.init that will probably be "good enough".&nbsp; In
    point of fact, the repository supplies a module.init for you that
    could have been used in place of A1.init in the third step above, so
    that the first two steps above could have been skipped.&nbsp; The
    A1.init generated above might look like<br>
    <blockquote>
      <pre><font color="#663300"># Auto-generated for module A1 by dumbInitialization0.py.<br>U127 1 0<br>U129 1 0</font><br></pre>
    </blockquote>
    and is telling us that initially, we can choose output signal U127-J
    to be HIGH (1), U127-K to be LOW (0), U129-J to be HIGH, and U129-K
    to be LOW.&nbsp; I say it "might" look like that, because there are
    other consistent initial conditions that could be generated instead,
    such as:<br>
    <blockquote>
      <pre><font color="#663300">U126 0 1<br>U127 0 1<br>U128 1 0</font></pre>
    </blockquote>
    The Verilog source code (module.v) that you get after the final step
    is below, depending on which initial conditions were
    generated.&nbsp; Even if you don't know Verilog, I think you can get
    some sense of what's what.&nbsp; The bulk of the file, namely the <font
      color="#663300"><code>assign</code></font> statements, define how
    the internal signals and output signals change at each timestep of
    the simulation.&nbsp; The <font color="#663300"><code>rst</code></font>
    signal is not present in the schematic, and is simply always added
    by <b>dumbVerilog.py</b>.&nbsp; It's what allows the initial
    conditions of memory — in this case, the flip-flop — to be set up,
    but is normally active only at the very beginning of the
    simulation.&nbsp; Verilog doesn't allow signal names like "FS01/",
    because the character "/" isn't legal for signal names, so the
    translator has automatically changed "FS01/" to "FS01_".<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <pre style="font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; overflow-wrap: break-word; white-space: pre-wrap;"><font color="#663300" face="Courier">// Verilog module auto-generated for AGC module A1 by dumbVerilog.py<br><br>module A1 ( <br>  rst, FS01_, F02A, F02B, FS02, FS02A<br>);<br><br>input wire rst, FS01_;<br><br>output wire F02A, F02B, FS02, FS02A;<br><br>parameter GATE_DELAY = 20; // This default may be overridden at compile time.<br>initial $display("Gate delay (A1) will be %f ns.", GATE_DELAY);<br><br>// Gate A1-U129A<br>pullup(g38205);<br>assign #GATE_DELAY g38205 = rst ? 1'bz : ((0|g38203|FS01_|F02B) ? 1'b0 : 1'bz);<br>// Gate A1-U129B<br>pullup(F02B);<br>assign #GATE_DELAY F02B = rst ? 0 : ((0|g38205|FS02) ? 1'b0 : 1'bz);<br>// Gate A1-U126B<br>pullup(FS02A);<br>assign #GATE_DELAY FS02A = rst ? 0 : ((0|g38204) ? 1'b0 : 1'bz);<br>// Gate A1-U127A<br>pullup(g38204);<br>assign #GATE_DELAY g38204 = rst ? 1'bz : ((0|FS02|g38203) ? 1'b0 : 1'bz);<br>// Gate A1-U127B<br>pullup(FS02);<br>assign #GATE_DELAY FS02 = rst ? 0 : ((0|g38204|g38205) ? 1'b0 : 1'bz);<br>// Gate A1-U128A<br>pullup(g38203);<br>assign #GATE_DELAY g38203 = rst ? 0 : ((0|F02A|FS01_|g38205) ? 1'b0 : 1'bz);<br>// Gate A1-U128B<br>pullup(F02A);<br>assign #GATE_DELAY F02A = rst ? 0 : ((0|g38204|g38203) ? 1'b0 : 1'bz);<br>// End of NOR gates<br><br><br>endmodule<br></font></pre>
    </blockquote>
    <a name="TestbenchExplanations"></a>Workflow Step #4: Creation of a
    test bench.&nbsp; This is the point in a simulation workflow where
    you would have to decide how you want the input signals supplied to
    the circuit to vary over time, as well as which output signals from
    the circuit you want to log for later viewing or analysis.&nbsp;
    Those decisions together comprise what's called the "test
    bench".&nbsp; The test bench could be yet another Verilog
    source-code file, though it turns out to be more-convenient for it
    to be a pair of files, one to hold your personal choices, and
    another to include anything that can be figured out via automation.<br>
    <br>
    The automated portion is performed like so:<br>
    <blockquote>
      <pre><font color="#663300"># In Linux:<br>dumbTestbench.py &lt;module.v &gt;module_tb.v<br># Or in Windows:<br>python -m dumbTestbench &lt;module.v &gt;module_tb.v<br># Or in Mac OS:<br>python3 -m dumbTestbench &lt;module.v &gt;module_tb.v<br></font></pre>
    </blockquote>
    which gives you the following:<br>
    <blockquote>
      <pre><font color="#663300">// Verilog testbench created by dumbTestbench.py<br>`timescale 1ns / 1ps<br><br>module agc;<br><br>parameter GATE_DELAY = 20;<br>`include "tb.v"<br><br>wire F02A, F02B, FS02, FS02A;<br><br>A1 iA1 (<br>  rst, FS01_, F02A, F02B, FS02, FS02A<br>);<br>defparam iA1.GATE_DELAY = GATE_DELAY;<br><br>endmodule</font><br></pre>
    </blockquote>
    You needn't worry (I hope!) about what any of that means.&nbsp; I'll
    just point out that it tells the emulator that the basic time scale
    of the simulation is 1 nanosecond (with a precision of 1
    picosecond), the propagation delay through the NOR gates is by
    default 20 nanoseconds, and that the file tb.v, which is where the
    "personal choices" mentioned above are stored, is automatically
    imported.<br>
    <br>
    <a name="tbdotv"></a>In our case, the "personal choices" are mine
    rather than yours, unless you invent new ones, and the tb.v file I
    give you is this:<br>
    <blockquote>
      <pre><font color="#663300">// Include-file used by module_tb.py for automating testbench generation.<br><br>reg rst = 1;<br>initial begin<br>  // Assumes compilation with the -fst option.<br>  $dumpfile("module.fst");<br>  $dumpvars(0, agc);<br>  <br>  # 2000 rst = 0;<br>  # 500000 $finish;<br>end<br><br>reg FS01_ = 0;<br>always #9765.625 FS01_ = !FS01_;<br>  <br>initial<br>  $timeformat(-6, 0, " us", 10);<br>initial<br>  $monitor("At time %t, rst=%d, FS01_=%d, F02B=%d, FS02=%d, FS02A=%d, FS02A=%d", $time, rst, FS01_, F02B, FS02, F02A, FS02A);</font><br></pre>
    </blockquote>
    The "<font color="#663300"><code>reg rst = 1</code></font>" means
    that the <font color="#663300"><code>rst</code></font> signal is
    going to be an input signal into the circuit we're testing, but here
    within the test bench it's going to be a "register" that remembers
    it's own settings, as opposed to a "wire" (which cannot remember
    anything).&nbsp; Thus, we set <font color="#663300"><code>rst</code></font>
    to 1 and it will stay that way until we say otherwise.&nbsp; A few
    lines later we will see "<font color="#663300"><code># 2000 rst = 0</code></font>",










    which means that 2000 nanoseconds (2 μs) after startup, the test
    bench is going to reset the <font color="#663300"><code>rst</code></font>
    signal to 0, and leave it there.&nbsp; The "<font color="#663300"><code>#
        500000 $finish</code></font>" that you will also see there says
    that the simulation itself will actually end after 500 μs.&nbsp; The
    intervening "<font color="#663300"><code>$dumpfile</code></font>"
    and "<font color="#663300"><code>$dumpvars</code></font>" statements
    say that an output log-file called testVerilog.fst is going to be
    opened, and that the values of all of the input and output variables
    are going to be dumped into it on a cycle-by-cycle basis, for later
    analysis.&nbsp; <br>
    <br>
    The "<font color="#663300"><code>reg FS01_ = 0</code></font>" means
    that <font color="#663300"><code>FS01_</code></font> (FS01/) is
    also an input to the circuit being tested, and that it starts out at
    0.&nbsp; But "<font color="#663300"><code>always #9765.625 FS01_ =
        !FS01_</code></font>" means that <font color="#663300"><code>FS01_</code></font>
    is going to be toggled every 9.765625 μs during the
    simulation.&nbsp; Recall that FS01/ is a 51.2 KHz square wave in the
    AGC, and therefore it toggles from low-to-high or high-to-low at a
    rate of 102.4 KHz, or (surprise!) every 9.765625 μs.<br>
    <br>
    Finally, the "<font color="#663300"><code>initial</code></font>"
    statements at the very end describe the status messages which the
    simulation is going to print out whilst running.&nbsp; These
    messages are just informative, and have nothing to do with the data
    being dumped out on the module.fst.&nbsp; You don't even need to
    print out any status messages if you don't want to.<br>
    <br>
    Workflow Step #5:&nbsp; Modeling memory.&nbsp; Since we're just
    simulating a single logic module of the AGC, rather than the AGC as
    a whole, we don't need any memory other than the flip-flop that the
    circuit implements, so&nbsp; we don't need this step.<br>
    <br>
    Workflow Step #6:&nbsp; In this example, we have created two Verilog
    source code files, the one describing the logic module (module.v)
    and the one describing the test-bench (module_tb.v, which
    automatically imports tb.v as well).&nbsp; We need to compile these
    together to get the "executable" form (which we'll call module.vvp)
    of the digital simulation we want to perform:<br>
    <blockquote>
      <pre>iverilog -o module.vvp module_tb.v module.v<br></pre>
    </blockquote>
    I can't show you the contents of module.vvp — I bet you're relieved!
    —, since it's a binary file rather than a human-readable one.<br>
    <br>
    Workflow Step #7:&nbsp; Here's how to run the simulation:<br>
    <blockquote>
      <pre>vvp module.vvp -fst<br></pre>
    </blockquote>
    I get messages something like this when I do that:<br>
    <blockquote><font size="-1" face="Courier"><font color="#663300">Gate
          delay (A1) will be 20.000000 ns.<br>
          FST info: dumpfile module.fst opened for output.<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 us, rst=1,
          FS01_=0, F02B=x, FS02=x, FS02A=x, FS02A=x<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 us, rst=1,
          FS01_=0, F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 us, rst=0,
          FS01_=0, F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9 us, rst=0,
          FS01_=1, F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9 us, rst=0,
          FS01_=1, F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 us, rst=0, FS01_=0,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 us, rst=0, FS01_=0,
          F02B=1, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 us, rst=0, FS01_=1,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          ...<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 468 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 478 us, rst=0, FS01_=1,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 478 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 488 us, rst=0, FS01_=0,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 488 us, rst=0, FS01_=0,
          F02B=1, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 488 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 498 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 498 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
        </font><br>
      </font></blockquote>
    Thus as promised, <font color="#663300"><code>FS01_</code></font>
    (FS01/) toggles about every 10 microseconds, while <font
      color="#663300"><code>FS02</code></font> toggles about every 20
    microseconds, though it's a bit of a pain to extract that conclusion
    from the messages.<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    </blockquote>
    Workflow Step #8: Visualization.&nbsp; Pull the dump-file created by
    running the simulation, namely module.fst, into the <b>GTKWave</b>
    visualization program, <br>
    <blockquote>
      <pre># In Linux or Windows:<br>gtkwave module.fst<br></pre>
    </blockquote>
    In Mac OS, I think it would just be easier to open <b>GTKWave</b>
    from the desktop (rather than figuring out how to do it from a
    command line), and use its File menu to navigate to
    virtualagc-schematics/Schematics/testVerilog/module.fst.<br>
    <br>
    <a name="simple8"></a>You'll see something like the following
    screenshot.&nbsp; <br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Actually, I won't
        pretend that what you see will magically resemble the
        screenshot.&nbsp; There will a few interactive steps within the
        <b>GTKWave</b> program's user interface to set the viewing
        timescale, select the specific signals to view, and the order in
        which the signals should appear, but I don't want to get
        sidetracked into a discussion of GTKWave's operation.&nbsp; If
        you've been motivated enough to get this far, I think you can
        figure those bits out for yourself!&nbsp; But you can look at <a
          moz-do-not-send="true"
          href="https://gtkwave.github.io/gtkwave/index.html">GTKwave's
          online documentation</a> to see how to use the visualizer, if
        you cannot monkey through it yourself.&nbsp;&nbsp; Or you can
        try these steps to quickly get something reasonably viewable,
        even it won't look precisely like the screenshot:<br>
      </font>
      <ul>
        <li><font size="-1">Select some signals to view:</font></li>
        <ul>
          <li><font size="-1">Left-Click on where it says "agc" in the
              SST pane.&nbsp; That will open up a subheading called "iA1
              (A1)".<br>
            </font></li>
          <li><font size="-1">Right-Click on the subheading "iA1 (A1)"
              in the SST pane.</font></li>
          <li><font size="-1">In the pop-up menu that appears, choose
              Recurse-Import / Append / Yes.<br>
            </font></li>
        </ul>
        <li><font size="-1">Zoom out a bit by clicking the Zoom-Fit
            hot-button in the toolbar at the top.&nbsp; (In the
            screenshot below, that's the button between the clipboard
            button and the + button.)<br>
          </font></li>
      </ul>
    </blockquote>
    <br>
    <div align="center"><img src="testVerilog.Wave.png" alt=""
        moz-do-not-send="true" width="1456" height="365"><br>
    </div>
    <br>
    In comparison, here's a clipping out of the corresponding waveform <a
      moz-do-not-send="true"
href="https://archive.org/stream/acelectroniclmma00acel#page/n296/mode/1up">Figure








      4-121</a> from the contemporary theory of operation document
    ND-1021042:<br>
    <br>
    <div align="center"><img moz-do-not-send="true"
        src="file:///home/rburkey/git/virtualagc-web/ND1011042-Fig4-121.jpg"
        alt="" width="1316" height="282"><br>
      <div align="left"><br>
        <blockquote><font size="-1"><b>Note:</b>&nbsp; While the
            waveforms shown in the two graphs are the same, there
            is&nbsp; nevertheless a significant difference:&nbsp;&nbsp;
            Figure 4-121 purports to display the signal FS01, whereas
            our data visualization displays signal FS01/, which is
            inverted from FS01.&nbsp; Then too, the position of the
            final pulse of F02B doesn't match.&nbsp; </font><font
            size="-1"><font size="-1">One of us must be wrong!&nbsp;
              Which one could it be?&nbsp; Could it be ... me?&nbsp;
              Could it be ... them?&nbsp; The suspense is terrible!</font>&nbsp;




            I hope it'll last.&nbsp; Check it out yourself. <br>
            <br>
            <b>Cheat sheet:</b>&nbsp; I've made most of this line
            white-on-white, to make it harder to read
            accidentally.&nbsp; If you highlight this entire line, I
            expect it will be enlightening. &nbsp; <font
              color="#ffffff">To figure out who's wrong, it's relatively
              easy to work backward from the condition F02A HIGH to see
              what conditions it requires for the inputs of the various
              NOR gates, then to work backward to the NOR gates feeding
              those inputs, and so on.&nbsp; You'll quickly find that
              F02A HIGH implies that FS01/ is HIGH as well, which means
              that Figure 4-121 is wrong in asserting that F02A is HIGH
              at the same time as FS01 is HIGH.&nbsp; Identical
              reasoning applies to determining the conditions for F02B
              being HIGH, demonstrating that Figure 4-121 is incorrect
              about the positioning of the final pulse.</font><br>
          </font> </blockquote>
      </div>
    </div>
    <h1><a name="EntireAGC"></a>Big Example: Simulating an Entire AGC</h1>
    <h2><a name="AGCchoices"></a>Choices To Make</h2>
    There are several important choices to be made at the very beginning
    of any attempt at simulating a whole AGC.&nbsp; I suppose that
    making those choices could form a Step #0 in the simulation
    workflow:<br>
    <ol>
      <li>Which model of AGC is to be simulated?</li>
      <li>Which of the available AGC programs is going to be run on the
        simulated AGC?</li>
      <li>What is the test bench going to be like?<br>
      </li>
    </ol>
    Regarding choice of AGC model:&nbsp; Aside from dash numbers
    suffixed to part numbers, the list of AGC models really boils down
    to those in the following table:<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="top">Generic AGC Model<br>
          </th>
          <th valign="top">Block<br>
          </th>
          <th valign="top">Mission<br>
          </th>
          <th valign="top">Spacecraft<br>
          </th>
          <th valign="top">Specific Dash Number<br>
          </th>
        </tr>
        <tr>
          <td valign="middle">1003565<br>
          </td>
          <td valign="middle">I<br>
          </td>
          <td valign="top">AS-202<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003565-011<br>
          </td>
        </tr>
        <tr>
          <td rowspan="2" colspan="1" valign="middle">1003700<br>
          </td>
          <td rowspan="2" colspan="1" valign="middle">I<br>
          </td>
          <td valign="top">Apollo 4<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003700-051<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Apollo 6<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003700-071<br>
          </td>
        </tr>
        <tr>
          <td rowspan="2" colspan="1" valign="middle">2003100<br>
          </td>
          <td valign="middle">II<br>
          </td>
          <td valign="top">2TV-1<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">2003100-061<br>
          </td>
        </tr>
        <tr>
          <td valign="top">II<br>
          </td>
          <td valign="top">LTA-8<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003100-071<br>
          </td>
        </tr>
        <tr>
          <td rowspan="2" colspan="1" valign="middle">2003200<br>
          </td>
          <td rowspan="2" colspan="1" valign="middle">II<br>
          </td>
          <td valign="top">(None)<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">2003200-031<br>
          </td>
        </tr>
        <tr>
          <td valign="top">(None)<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003200-041<br>
          </td>
        </tr>
        <tr>
          <td rowspan="3" colspan="1" valign="middle">2003993<br>
          </td>
          <td rowspan="3" colspan="1" valign="middle">II<br>
          </td>
          <td valign="top">Apollo 5<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003993-011<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Apollo 7</td>
          <td valign="top">CM</td>
          <td valign="top">2003993-031</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="3" valign="top"><i>etc.</i><br>
          </td>
        </tr>
      </tbody>
    </table>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; Model 2003993, in differing
          specific dash numbers, was used for almost all missions, so I
          hope you'll forgive me for running out of steam at the end of
          the table and just covering all of the remaining missions with
          a bland "<i>etc.</i>" rather than giving you 20+ more rows of
          model 2003993!&nbsp; The way to get the information for the
          missing entries is by drilling down into <a
            moz-do-not-send="true"
            href="ElectroMechanical.html#Navigate_the_Assembly_Hierarchy_">the











            GN&amp;C mission hierarchy table</a>.&nbsp; That is also the
          place to go in order to match a particular AGC model to a
          specific set of electrical schematics.</font><br>
      </p>
    </blockquote>
    <p>But there are really less choices than it appears at first
      glance.&nbsp; There's a table in <a moz-do-not-send="true"
        href="#ReverseLookup">the Technical Appendix</a> that lists all
      of the logic modules appearing in the different AGC models, in
      terms of the assocated schematic-diagram drawing numbers, and we
      can summarize what we learn from that table as follows:<br>
    </p>
    <ul>
      <li>AGC models 1003656 and 1003700 use the same logic modules, in
        so far as the electrical schematics are concerned.</li>
      <li> AGC model 2003100 uses logic modules for which the electrical
        schematics aren't available to us.</li>
      <li>AGC models 2003200 and 2003993 use the same logic modules, in
        so far as the electrical schematics are concerned, except that
        model 2003200 has an additional "restart monitor" alarm box
        bolted to it.&nbsp; The restart monitor is interesting, but it
        monitors rather than affects the functioning of the AGC, so in
        most cases its presence or absence is a distinction without a
        difference.<br>
      </li>
    </ul>
    <p>Or in other words, the only essentially-different cases that we
      could potentially simulate are AGC model 1003700 (Block I) or
      model 2003993 (Block II).&nbsp; <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; And of <i>those</i> two
          choices, only the simulation workflow for Block II has been
          debugged so far and can be considered mature enough to be
          "working" ... which coincidentally, is the one that is likely
          most desired by people, since it's the one relevant to Apollo
          11.</font><br>
      </p>
    </blockquote>
    Regarding the choice of AGC software:&nbsp; In principle, any of the
    available Block I AGC software versions can be used in a simulated
    AGC model 1003700, while any of the available Block II AGC software
    versions can be used in a simulated AGC model 2003993.&nbsp; Any
    Block II core-rope — in the form of a "bin" file produced by the AGC
    assembler, <b>yaYUL</b> — can be converted to a Verilog source code
    by a Python program provided by Mike Stewart that's called <b>bin_to_verilog_rom.py</b>.&nbsp;







    In practice, 15 or so AGC software versions have been converted by
    Mike and are already found with the transcribed schematics, in a
    folder called "roms".&nbsp; I would recommend the program called
    "Validation-hardware-simulation".
    <p>Regarding the test bench:&nbsp; This is really no different than
      what was discussed in the preceding section, except that we need a
      test bench for the entire AGC, rather than test benches for
      individual logic modules.&nbsp; I have created some test-bench
      files that can be used as starting points.&nbsp; They are named
      tb-2003993.v, tb-2003200.v, etc.&nbsp; Some of the characteristics
      of the test bench (such as the run length and the selection of
      logged signals) can be changed at runtime rather than requiring
      modifications to these test-bench source-code files themselves; <a
        moz-do-not-send="true" href="#simulateAGC">see the Technical
        Appendix</a>.<br>
    </p>
    <h2><a name="AGCworkflow"></a>The Workflow<br>
    </h2>
    As just explained, we'll be simulating the model 2003993 AGC.&nbsp;
    <br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; As in the case of
        simulating a single module, I've provided a script which can
        perform the entire sequence of steps needed to carry out the
        simulation, assuming that the choices described in the preceding
        section have been made.&nbsp; <i></i></font><font size="-1">The
        script is run from the Schematics directory, and its calling
        sequence from the command line is<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">simulateAGC <i>AGC_MODEL</i> <i>SOFTWARE</i> <i>VERILOG_OPTIONS</i></font><br></pre>
      </blockquote>
      <font size="-1">where <i><code>AGC_MODEL</code></i> defaults to
        "2003993", <i><code>SOFTWARE</code></i> defaults to
        "Validation-hardware-simulation", and <i><code>VERILOG_OPTIONS</code></i>
        (a quoted list of command-line parameters for the Verilog
        compiler that alter values in the test bench) is empty
        ("").&nbsp; The settings you can include in <i><code>VERILOG_OPTIONS</code></i>
        are described in the <a moz-do-not-send="true"
          href="#simulateAGC">Technical Appendix</a>.<br>
        <br>
      </font><font size="-1">To run the simulation while accepting all
        of the defaults, you could use the simple command.<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">simulateAGC</font><br></pre>
      </blockquote>
      <font size="-1">This will perform the entire workflow and </font><font
        size="-2"><font size="-1">jump you right to the visualization of
          the data output by the simulation, thus avoiding the
          possibility of having to learn anything in the meantime.&nbsp;
          Among the useful files left behind are the simulation file <i>AGC_MODEL</i>.vvp


          (in case you'd like to re-run the simulation), and<i> </i>agc.fst


          (the results of the simulation run, in case you'd like to
          re-view them).</font></font><br>
    </blockquote>
    What makes whole-AGC simulations trickier than single module
    simulations is that while the same basic workflow holds, some of the
    steps of the workflow are carried out for each logic module
    comprising the circuit, while other steps combine the
    logic-module-specific files&nbsp; into single large files pertaining
    to the whole AGC, and yet other steps operate on those whole-AGC
    files.<br>
    <br>
    Thus given a particular AGC model that's a candidate for simulation,
    we must first have a proper idea of what schematic diagrams are
    specific to the logic modules in that AGC model.&nbsp; <a
      moz-do-not-send="true" href="#ReverseLookup">The table in the
      Technical Appendix</a> informs us on this topic.&nbsp; In the case
    of our present example, it tells us a model 2003993 AGC has the
    following logic modules:<br>
    <ul>
      <li>A1 = 2005259A</li>
      <li>A2 = 2005260A</li>
      <li>A3 = 2005251A</li>
      <li>A4 = 2005262A</li>
      <li>A5 = 2005261A</li>
      <li>A6 = 2005263A</li>
      <li>A7 = 2005252A</li>
      <li>A8 =&nbsp; 2005255-</li>
      <li>A9 =&nbsp; 2005256A</li>
      <li>A10 =&nbsp; 2005257A</li>
      <li>A11 =&nbsp; 2005258A</li>
      <li>A12 = 2005253A</li>
      <li>A13 =&nbsp; 2005269-</li>
      <li>A14 =&nbsp; 2005264B</li>
      <li>A15 =&nbsp; 2005265A</li>
      <li>A16 =&nbsp; 2005266-</li>
      <li>A17 =&nbsp; 2005267A</li>
      <li>A18 =&nbsp; 2005268A</li>
      <li>A19 =&nbsp; 2005270-</li>
      <li>A20 =&nbsp; 2005254-</li>
      <li>A21 =&nbsp; 2005250-</li>
      <li>A22 =&nbsp; 2005271-</li>
      <li>A23 =&nbsp; 2005272A</li>
      <li>A24 =&nbsp; 2005273A"<br>
      </li>
    </ul>
    Of course, these schematic transcriptions already exist, so once
    again, workflow Step #1 (creation of schematic transcriptions)
    leaves us with nothing to do.<br>
    <br>
    Workflow Step #2 is creation of netlist files.&nbsp; This is done
    precisely as for the single logic modules we talked about in the
    preceding section, and must be done for <i>each</i> of the unique
    schematics listed above.&nbsp; I mention "unique" schematics,
    because it's certainly possible for the same schematic to apply to
    more than logic module.&nbsp; That's not the case for the 2003993,
    but is the case for AGC model 1003700.<br>
    <br>
    At Workflow Step #3 (creation of Verilog source-code files for the
    logic modules we begin to experience some differences from the
    single-module case.&nbsp; In the case of single-module simulation,
    this step was roughly:<br>
    <ol>
      <li>Run <b>dumbVerilog.py</b> for<i> </i>the logic module to
        generate a kind of "rough draft" of the Verilog source code.</li>
      <li>Run <b>dumbInitialization0.py</b> on the rough drafts to
        create an initialization file for the implicit flip-flops in the
        design.</li>
      <li>Run <b>dumbVerilog.py</b> again, using the new initialization
        file to get the final form of the module's Verilog source code.
        <br>
      </li>
    </ol>
    For whole-AGC simulation, this step instead becomes the following
    procedure:<br>
    <ol>
      <li>Run <b>dumbVerilog.py</b> for<i> each</i> of the logic
        modules comprising the AGC to generate a kind of "rough draft"
        of the Verilog source code for each of them.</li>
      <li><i>Combine</i> all of the rough-draft Verilog source-code
        files for the modules by appending them end-to-end into one big
        file.&nbsp; Realize that the result is <i>not</i> Verilog
        source code that we'll eventually compile, but merely is an
        input to some of our Python scripts to deduce the existing
        signals in the AGC.<br>
      </li>
      <li>Run <b>dumbInitialization.py</b> on the big Verilog file to
        generate an initialization file.</li>
      <li>Run <b>dumbVerilog.py</b> for<i> each</i> of the logic
        modules comprising the AGC, this time using the just-created
        initialization file, to generate a final form of the Verilog
        source code for each of them.</li>
    </ol>
    Workflow Step #4 (testbench generation). The appropriate file tb-<i>AGC_MODEL</i>.v


    must be copied to tb.v or else you must devise your own testbench
    file for tb.v instead.&nbsp; Use the combined Verilog source-file
    created in workflow step #3 as input for <b>dumbTestbench.py</b>.&nbsp;


    This produces a Verilog file <i>AGC_MODEL</i>_tb.v that's the
    testbench.<br>
    <br>
    Workflow Step #5 (Verilog source-code creation for erasable and
    fixed memory) is completely new, since we didn't have to do it at
    all for the single-module case.&nbsp; <br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;


        Note that the while the AGC's physical memory, both erasable and
        fixed, was binary in the sense that it stored 1's and 0's, it
        was not implemented by digital circuitry.&nbsp; Instead, it was
        analog circuitry that had the effect of flipping the magnetic
        fields of memory cores.&nbsp; As such, AGC memory schematics
        cannot be converted to Verilog source code, nor simulated by
        Verilog.&nbsp; At least, not if used as-ins.&nbsp; Instead, what
        has been done is that the memory has been modeled by digital
        circuits having the same inputs and outputs as the original AGC
        circuitry, but differing completely internally.&nbsp; Moreover,
        unlike all other AGC digital circuitry, the memory model is <i>not</i>
        implemented using triple-input NOR gates, but is instead
        implemented by more modern RAM, ROM, and other chips, which are
        themselves modeled by pure Verilog source code.&nbsp; See the
        schematic diagram and associated Verilog source code in
        Schematics/fixed_erasable_memory/.&nbsp; I did not develop this
        modeling of the AGC memory; rather, Mike Stewart had already
        developed it for his own AGC electrical simulation, as mentioned
        earlier, and it has simply been appropriated for use in the
        Virtual AGC electrical-simulation framework.&nbsp; Thanks again,
        Mike!</font><br>
    </blockquote>
    Four separate things go into simulation of erasable and fixed
    memory:<br>
    <ul>
      <li>A model for erasable memory hardware.&nbsp; This Verilog file
        has been pre-created, and is always the same.&nbsp; It's the
        file called RAM.v in the folder
        Schematics/fixed_erasable_memory/.</li>
      <li>A model for a buffer chip interfacing to the erasable-memory
        databus.&nbsp; This Verilog file has been pre-created, and is
        always the same.&nbsp; It's the file called BUFFER.v in the
        folder Schematics/fixed_erasable_memory/.</li>
      <li>A model for fixed-memory hardware.&nbsp; This is simply a file
        that always is the same, namely ROM.v in the folder
        Schematics/fixed_erasable_memory/.</li>
      <li>A model for the AGC software.&nbsp; ROM.v, mentioned just
        above, always includes a file called rom.v from the folder
        Schematics/roms/ that contains this model.&nbsp; As I mentioned
        earlier, Schematics/roms/ already contains a number of models
        for specific AGC software versions, such as Luminary099.v or
        Validation-hardware-simulation.v.</li>
    </ul>
    <p>Combining those ideas, what Step #5 of the workflow does is to
      copy the appropriate file Schematics/roms/<i>SOFTWARE_VERSION</i>.v
      to Schematics/roms/rom.v.&nbsp; Since RAM.v, ROM.v, and BUFFER.v
      already exist and are never changed, nothing needs to be done with
      them.<br>
    </p>
    <p>Workflow Step #6 (compilation of the Verilog). The compiler, <b>iverilog</b>,
      uses all of the Verilog source-code files as inputs —
      specifically, <i>AGC_MODEL</i>_tb.v, <i>module</i>.v for each of
      the AGC's logic modules, RAM.v, ROM.v, rom.v, and BUFFER.v&nbsp;
      —,&nbsp; to create the simulation itself, which will be a file
      called <i>AGC_MODEL</i>.vvp.<br>
    </p>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
        Don't worry about the notion that we have different Verilog
        source-code files called ROM.v and rom.v that might be confused
        with each other because of the loony notion in Mac OS and
        Windows that filenames could be case-insensitive.&nbsp; Those
        source-code files are in different folders, so even Mac OS and
        Windows can't get them mixed up.</font><br>
    </blockquote>
    <p> </p>
    Workflow Step #7 (performing the simulation):<br>
    <blockquote>
      <pre>vvp <i>AGC_MODEL</i>.vvp -fst<br></pre>
    </blockquote>
    This creates a simulation-result "dump file" called agc.fst, in
    which the signals selected by the test bench are logged for
    subsequent viewing or analysis.<br>
    <br>
    Workflow Step #8 (viewing the simulation results):<br>
    <blockquote>
      <pre>gtkwave agc.gtkw<br></pre>
    </blockquote>
    You'll notice that this command is somewhat different than what we
    saw in the simulation of an individual module, from which we would
    have instead suspected a command of "<font color="#663300"><code>gtkwave


        agc.fst</code></font>".&nbsp; Make no mistake: the latter
    command would have worked fine!&nbsp; But unlike the case of a
    single-module simulation, in the case of a full-AGC simulation we
    are actually in a position to make a guess as to which signal-traces
    might be usefully displayed.&nbsp; And as we'll see in the next
    section, there are certain enhancements that can be made to our
    signal-viewing experience when an entire AGC is being
    analyzed.&nbsp; The provided agc.gtkw file, or a similar one, is a
    kind of "project-settings" file that helps us to apply those
    improvements to the viewing experience without having to manually
    perform a lot of tedious interactive setup within the <b>GTKWave</b>
    user interface.<br>
    <br>
    <a name="AGCvisualization"></a>But the full AGC has a <i>lot</i> of
    signal nets in it — about 5000 of them —, so there's a lot more
    flexibility in choosing which of those you want to look at in the
    data visualization than there is in any single logic module.&nbsp;
    In case it hasn't been clear already, any or all of the signals
    logged when the simulation was performed can be displayed, in any
    order, with or without various kinds of decorations, either
    individually or grouped into multi-signal buses.&nbsp; Which ones of
    them to display, and how, is typically a matter on which you'd
    consult the schematic diagrams and/or the theory-of-operation
    documents a lot in order to figure out which signals were helpful
    and which were merely clutter.&nbsp; What I've done for pedagogical
    purposes in the screenshot below is to select the signals
    corresponding to the upper portion of Figure 4-121 of the
    theory-of-operations document&nbsp; ND-1021042, of which you may
    recall that in the preceding section I used only the lower portion
    of that figure.&nbsp; One comforting feature of this simulation is
    that when we saw this same data in the preceding section, the test
    bench had <i>supplied</i> the input signal FS01/ at the proper
    clock rate, whereas in our full-AGC simulation here, signal FS01/ is
    instead <i>generated</i> by the upstream portions of the
    circuitry.&nbsp; And yet the simulation still generates an FS01/
    signal at the same correct frequency as before.<br>
    <div align="center"><img moz-do-not-send="true"
        src="2003993.Wave.png" alt="" width="844" height="352"><br>
    </div>
    <br>
    And here's the aforementioned upper portion of Figure 4-121:<br>
    <div align="center"><img moz-do-not-send="true"
        src="Figure4-121top.jpg" alt="" width="703" height="264"><br>
    </div>
    Perfect match!<br>
    <br>
    Because you're sharp-eyed and clever — if not, how could you
    possibly be reading this right now? —, I can detect some
    skepticism.&nbsp; I can hear you saying, "But wait!&nbsp; Didn't you
    conclusively demonstrate in the preceding section that Figure 4-121
    was bonkers, and was mistakenly displaying the signal FS01/ where it
    wrongly says it's displaying signal FS01?&nbsp; And if that's true,
    how could this <i>now</i> be a perfect match?!!!"&nbsp; You know
    what?&nbsp; You're right.&nbsp; Well, right and wrong, I
    think.&nbsp; I can't give you a 100% certain explanation of what
    happened when Figure 4-121 was drawn, but I visualize it something
    like this:<br>
    <ul>
      <li>The top portion of Figure 4-121, from POI/ through FS01, shows
        signals that are all from logic module A2.&nbsp; I imagine that
        this drawn first, and was correctly drawn.</li>
      <li>The bottom portion of Figure 4-121, below but not including
        FS01, shows signals from logic module A1.&nbsp; <br>
      </li>
      <li>Signal FS01 is not present in module A1, but FS01/ is present
        instead.&nbsp; I imagine that when the bottom portion was drawn,
        whoever drew it simply became confused and thought that FS01 was
        present in module A1, when it was really signal FS01/.</li>
    </ul>
    <p>There!&nbsp; That neatly explains, I think, why I'm right, and
      everyone else is to blame for any apparent errors, and how my
      simulation is beautiful and perfect.&nbsp; And they said it could
      not be done!&nbsp; My next trick will to be to run for public
      office of some kind.&nbsp; On the other hand, alternative
      explanations concluding that I and my simulations are idiotic are
      welcome too.&nbsp; Well, perhaps not <i>welcome</i> exactly
      ....&nbsp; but I say, anything that advances the dialog!&nbsp; Let
      me know if you come up with one.<br>
    </p>
    <h2><a name="Transactions"></a>Enhanced Viewing of an AGC's
      Simulation Results</h2>
    <blockquote><font size="-1"><b>Note for Windows users:</b>&nbsp; For
        <i>me</i> (Windows 11, GTKWave 3.3.100), although the
        enhancements described in this section work fine in Linux and
        Mac OS, they don't work at all in Microsoft Windows.&nbsp; I
        interpret this as <a moz-do-not-send="true"
          href="https://github.com/gtkwave/gtkwave/issues/416">a bug</a>
        in the Windows versions of the GTKWave viewing program.&nbsp;
        Perhaps if <b>GTKWave</b> were built from source, the problem
        would disappear, but I haven't tried doing that.&nbsp; And your
        experience may vary anyway.&nbsp; Hopefully it's a temporary
        problem, but at the moment it's out of my hands.</font><br>
    </blockquote>
    <p>As lamented in the preceding section, the simulation of a full
      AGC provides a <i>lot</i> of signals, the interpretation of which
      is not obvious at a glance, or indeed probably after an extended
      effort.&nbsp; Some simplification is needed if poor mortals as
      finite as human beings are to use the simulation results in any
      meaningful way.&nbsp; Fortunately, <b>GTKWave</b> and Mike
      Stewart come to the rescue, at least partially!<br>
    </p>
    <p><b>GTKWave</b>'s contribution is a feature in which you can
      optionally apply a so-called "<a moz-do-not-send="true"
        href="https://gtkwave.sourceforge.net/gtkwave.pdf#page=60">transaction



        filter</a>" to a selection of signals.&nbsp; A transaction
      filter is a user-supplied program, in our case written in Python
      3, that is applied by
      <b> GTKWave</b> at each change to the levels of any of the
      selected signals.&nbsp; The transaction filter can then process
      the levels of the selected signals in any manner it chooses, and
      can do things like log the results of its calculations to a file
      or add a new trace containing those results to <b>GTKWave</b>'s
      display of the signals.<br>
    </p>
    <p>One of Mike's contributions, among many others, is to actually
      supply such a transaction filter that decodes the AGC signals as
      CPU instructions, displaying the resulting instructions and their
      operands as an additional trace.&nbsp; I briefly mentioned in <a
        moz-do-not-send="true" href="#References">the References section</a>
      earlier that Mike had performed his own functionally-equivalent
      transcription into <b>KiCad</b> of the AGC electronics, along
      with the associated simulations thereof.&nbsp; Although I provide
      no instructions for doing so here, just as you can run the Virtual
      AGC simulations based on the Virtual AGC transcriptions of the AGC
      electrical schematics, if you refer to Mike's website you could
      alternatively use Mike's transcriptions of the AGC electrical
      schematics and run simulations based on them.<br>
    </p>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;


        Since I seem to be implying that Mike's simulations are so
        terrific — which I am — you may wonder why in the world you
        would choose to use Virtual AGC schematics and simulations
        rather than Mike's.&nbsp; The question is a valid one.&nbsp; The
        answer is that it's a matter of personal preference.&nbsp;
        Here's a rough point-by-point comparison:<br>
      </font>
      <table cellspacing="2" cellpadding="2" border="1" align="center">
        <tbody>
          <tr>
            <th valign="top"><font size="-1">Mike Stewart<br>
              </font></th>
            <th valign="top"><font size="-1">Virtual AGC<br>
              </font></th>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Schematics are functionally
                equivalent to Apollo<br>
              </font></td>
            <td valign="top"><font size="-1">Schematics are visually
                identical to Apollo drawings<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Requires modified version
                of <b>KiCad</b><br>
              </font></td>
            <td valign="top"><font size="-1">Uses stock version of <b>KiCad</b><br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Simulations run faster<br>
              </font></td>
            <td valign="top"><font size="-1">Simulations run slower<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Hard to compare to Apollo
                drawings<br>
              </font></td>
            <td valign="top"><font size="-1">Easy to verify vs Apollo
                drawings<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1"><a moz-do-not-send="true"
href="https://github.com/virtualagc/agc_simulation/blob/master/README.md">Documentation


                  is in Mike's GitHub repository</a><br>
              </font></td>
            <td valign="top"><font size="-1">Documentation is the stuff
                you've been reading<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Did it all first<br>
              </font></td>
            <td valign="top"><font size="-1">Copycat, piggybacking in
                some ways on Mike's work<br>
              </font></td>
          </tr>
        </tbody>
      </table>
      <font size="-1"><br>
      </font></blockquote>
    <p><a name="decoder"></a>Below (click to enlarge!), you can see a
      screenshot from one of Mike's simulations, with the
      instruction-decoder transaction filter displaying the AGC
      instructions along the top:<br>
    </p>
    <p align="center"><img moz-do-not-send="true"
        src="gtkwave-250ms-mike.png" alt="" width="100%" height="100%"><br>
    </p>
    While in comparison, here's a similar screenshot from a Virtual AGC
    simulation, borrowing Mike's instruction-decoding transaction filter
    to generate the top trace:<br>
    <img moz-do-not-send="true" src="gtkwave-250ms-ron.png" alt=""
      width="100%" height="100%"><br>
    <br>
    If you closely compare the two screenshots, you can see that the
    results of the simulation are quite similar, at least in this
    very-limited initial 250 μs of the simulation — which actually
    continued for an additional 250 ms that don't appear in the
    screenshots —&nbsp; but that there are nevertheless some differences
    in timing.&nbsp; In these two particular simulation runs, the
    instructions executed match only up to a certain point:<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="top">Mike's Simulation<br>
          </th>
          <th valign="top">Virtual AGC Simulation<br>
          </th>
        </tr>
        <tr>
          <td valign="top">
            <pre><font color="#ff0000">GOJAM</font><br>GOJAM<br><font color="#009900"><font color="#000000">TC 4000</font><br>INHINT<br>CA 7613<br>TS 0026<br>TCF 4054<br>RELINT</font><br><br><font color="#009900">CA 0007<br>TS 0061<br>TS 0062<br>INCR 0061<br>CA 0005<br>TS 0001</font><br>.<br>.<br>.<br></pre>
          </td>
          <td valign="top">
            <pre><br>GOJAM<br><font color="#009900"><font color="#000000">TC 4000</font><br>INHINT<br>CA 7613<br>TS 0026<br>TCF 4054<br>RELINT</font><br><font color="#ff0000">PINC 0040</font><br><font color="#009900">CA 0007<br>TS 0061<br>TS 0062<br>INCR 0061<br>CA 0005<br>TS 0001</font><br>.<br>.<br>.</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    Strictly speaking, not all of the "instructions" detected by the
    transaction filter are truly AGC instructions.&nbsp; "GOJAM", for
    example, is the name of an AGC signal associated with a reset of the
    AGC.&nbsp; Thus GOJAM is more of a condition of interest, telling us
    that a reset will occur, than an instruction <i>per se</i>.&nbsp;
    Mike's simulation has two GOJAMs at the very beginning, though the
    first is printed merely as "+" due to lack of space, while the
    Virtual AGC simulation has just one of them.<br>
    <br>
    Then too, "PINC" is what's called an <a moz-do-not-send="true"
      href="assembly_language_manual.html#UnprogrammedSequences">"unprogrammed



      sequence"</a>, which is type of AGC instruction that's executed
    without any corresponding mnemonic for the operation appearing in
    the assembly-language source code.&nbsp; The AGC has various types
    of these unprogrammed instructions, with names like PINC, PCDU,
    MINC, MCDU, DINC, and so on.&nbsp; They are executed asynchronously
    (with respect to the software source code) in order to perform
    actions such as updating the CPU's timer and counter registers,
    performing logical shift operations, and so on.&nbsp; Thus unlike
    hardware registers in a "modern" CPU, unprogrammed actions consume
    actual CPU time. &nbsp; In particular, I presume that PINC 0040
    increments CPU register 40 (the PIPA Y register), and the fact that
    "my" simulation performed a PINC when Mike's simulation did not
    would typically mean that not all of the AGC's implicit flip-flops
    had been given identical initial values in the two
    simulations.&nbsp; Which means nothing more than that if you intend
    to closely compare two simulations over an extended time, you better
    be sure that all of the implicit flip-flops are initialized the same
    way!&nbsp; In this case, for example, I certainly have no desire to
    increment PIPAY at this stage in the simulation, or indeed in <i>any</i>
    stage of the simulation, so perhaps it would have behooved me to
    perform a better initialization than I actually did when I created
    the screenshot above.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Or in other words,
        if you were to perform exactly the same simulation as I did
        above, following precisely the same steps, you might get a
        slightly-different result because I could have improved (or at
        least <i>changed</i>) the algorithm performing the flip-flop
        initializations in the meantime.&nbsp; Remember that in the
        physical AGC, there's little effort to perform any such
        initialization except in a few crucial cases, and the
        expectation was that after power-up the flip-flops would just
        settle on their own into some benign mutually-consistent
        configuration.&nbsp; So it's hard to be too terribly worried
        that we're treating initialization of the flip-flops somewhat
        loosely ourselves.<br>
        <br>
        In point of fact, I was comparing apples-to-oranges anyway,
        since Mike's simulation was of AGC model 2003993 and mine was of
        model 2003200, and used a preliminary version of the simulation
        framework to boot!&nbsp; If you were to run a new simulation
        today, of a 2003993, you'd actually find it very difficult to
        discern any difference from Mike's simulation, except in the
        first few microseconds when the AGC is settling down.&nbsp; But
        I keep the older screenshot here because it's more pedagogically
        useful to be able to explain the discrepancies than to lack any
        discrepancies to explain!<br>
      </font></blockquote>
    As for whether the particular AGC instructions being executed make
    sense, recall that while you can in principle simulate the AGC CPU
    running <i>any</i> AGC software, by default the AGC program used is
    the one called "Validation-hardware-simulation".&nbsp; Like all AGC
    programs, execution begins at address octal 4000 after a GOJAM, so
    the initial TC 4000 reported by the transaction filter is in fact an
    instruction manufactured entirely by the CPU hardware, rather than
    being something explicit in the AGC program's source code.&nbsp; In
    other words, a GOJAM always immediately triggers a TC 4000.&nbsp;
    The assembly listing of the source code looks like this:<br>
    <blockquote>
      <pre><font color="#663300">000061,000061:    4000           00004                           <font color="#009900">INHINT</font>                                 	# GO<br>000062,000062:    4001           3<font color="#009900">7613                           CA</font>       O37774                        	# Schedule the first TIME3 interrupt<br>000063,000063:    4002           54<font color="#009900">026                           TS</font>       TIME3                         	#<br>000064,000064:    4003           1<font color="#009900">4054                           TCF</font>      INIT                          	# Proceed with initialization<br>000121,000121:    4054           00003        INIT               <font color="#009900">RELINT</font>                                 	#<br>000122,000122:    4055           3<font color="#009900">0007                           CA</font>       ZEROES                        	# zero out A<br>000123,000123:    4056           54<font color="#009900">061                           TS</font>       ERRNUM                        	# and the error-code<br>000124,000124:    4057           54<font color="#009900">062                           TS</font>       ERRSUB                        	#<br>					      <i>			 ... Some comments omitted ...</i><br>000152,000152:    4060           24<font color="#009900">061                           INCR</font>     ERRNUM                        	#<br>000153,000153:    4061           3<font color="#009900">0005                           CA</font>       Z                             	# fetch Z.<br>000154,000154:    4062           54<font color="#009900">001        DEST1              TS</font>       L                             	#<br>                                                                 .<br>                                                                 .<br>                                                                 .</font><br></pre>
    </blockquote>
    Using a little imagination, and some judicious color-coding, you can
    see that exactly the instructions we expect are being executed by
    both of the simulations.&nbsp; Bear in mind that the symbol ZEROES
    refers to CPU register 0007 (which is always filled with zeroes)
    rather than to a variable, and similarly CPU register 0005 is the Z
    register, CPU register 0001 is the L register, CPU register 0026 is
    the TIME3 register, and so on.<br>
    <br>
    What I've given here is just a brief sketch of how the
    AGC-instruction-decoding transaction filter works.&nbsp; The
    instruction-decoding transaction filter is applied automatically by
    <b>simulateAGC</b>, but if you're interested in the details about
    how to actually apply the filters in your own simulation, they are
    covered in the <a moz-do-not-send="true" href="#visualization">Technical



      Appendix</a> below.<br>
    <p> </p>
    <ul>
    </ul>
    <h1><a name="Appendix:_Translation_from_KiCad_into"></a>Technical
      Appendix</h1>
    <h2><a name="AGCSoftwareForSimulation"></a>AGC Software for
      Simulation Purposes</h2>
    <p>Unmodified AGC software may not be 100% suitable for the purposes
      of digitally simulating the AGC electronics, and may require some
      modifications in order to be suitable.&nbsp; At this writing, the
      only example of this is in the <a moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/master/Validation">Validation</a>
      program, which is a small suite of test routines for the AGC CPU
      that I wrote, based on the original documentation.&nbsp; However,
      Validation is an interactive program, and dependence on a DSKY may
      not be very desirable in the context of simulating the digital
      electronics of the AGC.&nbsp; Much better to run AGC software
      which doesn't have to wait for the (non-existent) astronaut to do
      something on the (non-existent) DSKY!&nbsp; One approach to this
      problem would be simply to clone the AGC program one wishes to
      run, and then make whatever changes were desired directly to the
      cloned source code.<br>
    </p>
    <p>Another approach is to embed directives in the original AGC
      program that act like conditional compilation, so that sections of
      the source code can be modified at assembly time without
      maintaining two copies of the source code.&nbsp; The assembler (<b>yaYUL</b>)
      supports this approach via a command-line switch, <font
        color="#663300"><code>--simulation</code></font>, and embedded
      directives <font color="#663300"><code>-SIMULATION</code></font>
      or <font color="#663300"><code>+SIMULATION</code></font> within <i>end-of-line




        comments</i> in the AGC source code.&nbsp; Lines of AGC source
      code without either of these embedded directives, or with those
      directives embedded in full-line comments, are processed normally
      by <b>yaYUL</b> whether or not the <font color="#663300"><code>--simulation</code></font>
      command-line switch is present.&nbsp; However, if <font
        color="#663300"><code>--simulation</code></font> is in effect, <b>yaYUL</b>
      comments out any lines with an embedded <font color="#663300"><code>-SIMULATION</code></font>
      directive.&nbsp; Conversely, if <font color="#663300"><code>--simulation</code></font>
      is <i>not</i> in effect, <b>yaYUL</b> comments out any lines
      with an embedded <font color="#663300"><code>+SIMULATION</code></font>
      directive.<br>
    </p>
    <p>The AGC Validation program has such directives embedded in it,
      and when assembled with <font color="#663300"><code>--simulation</code></font>
      produces a version of the program more-suitable for simulating the
      AGC electronics.&nbsp; This alternate version of Validation is
      known as Validation-hardware-simulation, and thus is the program
      run by default when simulating the AGC electronics.<br>
    </p>
    <p>More-sophisticated AGC test programs (such as Borealis) and the
      original test programs (like Aurora and Sundial) are available as
      well, but they have not received the treatment mentioned above, as
      of this writing.<br>
    </p>
    <h2><a name="CreatingSchematic"></a>Transcribing/Editing a Schematic
      Diagram with eeschema<br>
    </h2>
    <p>This is too detailed a topic for me to give much helpful advice
      about in a limited space.&nbsp; Plus, I consider it unlikely that
      you'll find yourself needing to transcribe an AGC-related
      schematic diagram.&nbsp; I will simply point out the following:<br>
    </p>
    <ul>
      <li>The schematic-capture editor supplied with KiCad EDA is called
        <b>eeschema</b>.<br>
      </li>
      <li>Schematic diagrams transcribed from the original Apollo
        Guidance, Navigation &amp; Control (GNC) system are found in <a
          moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">the











          "schematics" branch of our Virtual AGC repository, in the
          folder called "Schematics"</a>.</li>
      <li>There is a separate folder for each original drawing number,
        such as 1005700A or 2005259-.&nbsp; All operations specific to a
        given drawing are expected to be performed within its folder
        unless otherwise stated.&nbsp; The top-level page of the
        schematic has the filename "module.sch" (for KiCad v.5 or prior)
        or "module.kicad_sch" (for KiCad v.6 or later).&nbsp; The
        descriptions below assume the latter.<br>
      </li>
      <li>All operations described on this web-page were originally
        performed with KiCad v.5 but are today tested with KiCad v.6 and
        v.7.&nbsp; If you have installed KiCad v.8 or v.9, I have every
        expectation that they will operate as described, but have not
        tested them.<br>
      </li>
    </ul>
    <h2><a name="CreatingNetlists"></a>Creating a Netlist with eeschema<br>
    </h2>
    <p>There are two methods.&nbsp; <br>
    </p>
    <p>Method 1:&nbsp; While viewing the top-level page of a schematic
      diagram in <b>eeschema</b>, select File/Export/Netlist from the
      main menu.&nbsp; In the "Export Netlist" window which pops up,
      select the tab labeled "OrcadPCB2" and click the button labeled
      "Export Netlist".&nbsp; In the "Save Netlist File" dialog which
      appears, which should have pre-chosen the folder containing the
      top-level schematic file itself, save the netlist as "module.net".<br>
    </p>
    <p>Method 2:&nbsp; For KiCad v.7 or later, the netlist can be
      created from a command line without even running <b>eeschema</b>.&nbsp;











      The command would be<br>
    </p>
    <blockquote>
      <pre>kicad-cli sch export netlist --output module.net --format orcadpcb2 module.kicad_sch<br></pre>
    </blockquote>
    <h2><a name="Converting_Netlist_to_Verilog"></a>Converting Netlists
      to Verilog Source Code with dumbVerilog.py<br>
    </h2>
    The supplied tools for converting a netlist (or more accurately, a
    netlist plus the associated schematic) to Verilog source code are
    specific to AGC logic modules as originally designed in the Apollo
    era, and to our specific manner of transcribing those those drawings
    for use with <b>eeschema</b>.&nbsp; Departing from any of those
    conditions could render the supplied tools useless, thus forcing you
    to <i>manually</i> create whatever Verilog source code you think
    represents your digital circuit.&nbsp; The conditions are:<br>
    <ul>
      <li>Only the AGC modules (i.e., drawing numbers) designated as
        "logic modules" are relevant to the digital simulation.&nbsp;
        For example, for AGC model 2003993, the logic modules are A1
        (schematic drawing 2005259), A2 (schematic drawing 2005260), and
        so on.<br>
      </li>
      <li>The only digital-logic components used in logic modules are
        dual triple-input open-drain NOR gates.<br>
      </li>
      <li>Each digital-logic component has a reference designator of the
        form U<i>snn</i>, where <i>snn</i> is a three-digit decimal
        number.&nbsp; The two NOR gates of a single dual-NOR component
        share the same reference designator.&nbsp; In other respects,
        these reference designators are unique throughout a given logic
        module (i.e., top-level schematic).&nbsp; Each logic module is a
        2-sided circuit board, with all reference designators on the
        "top" side having <i>s</i>=1 and all on the "bottom" having <i>s</i>=2.</li>
      <li>Each NOR gate has a 5-digit "location", <i>mmnnn</i> that's
        unique throughout the entire AGC.&nbsp; Any given dual-gate
        component thus has two separate locations, one for each of the
        two gates.&nbsp; The digits <i>mm</i> are specific to the logic
        module and the digits <i>nnn</i> vary across module.</li>
      <li>When the logic circuit being simulated spans more than a
        single logic module, as is the case when simulating the entirety
        of an AGC, the logic modules interconnect by being plugged into
        a common backplane.&nbsp; In the electrical schematics, this
        backplane is represented as 4 separate 72-pin connectors, with
        reference designators J1, J2, J3, and J4.&nbsp; For example, pin
        J2-5 represents the same signal within every logic module.</li>
      <li>In summary, digital circuits which can be simulated using the
        supplied tools consist entirely of triple-input open-drainNOR
        gates, backplane connectors, and the wires interconnecting them.<br>
      </li>
    </ul>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;











        To be completely honest, I'm no longer entirely sure how many of
        these rules the supplied tools actually depend upon, as opposed
        to these rules just being the ones obeyed by the original
        developers.&nbsp; <i>Most</i> of them are relied upon.</font><br>
    </blockquote>
    To convert a <i>single</i> schematic to Verilog source code, the
    Python 3 script <b>dumbVerilog.py</b> is used:<br>
    <blockquote><font face="Courier 10 Pitch">dumbVerilog.py <i>MODULE</i>
        <font face="Courier 10 Pitch">module</font>.net pins.txt <i>DELAY</i>
        <font face="Courier 10 Pitch">module.init</font>
        module.kicad_sch [<i>WIRETYPE</i>] &gt;<font face="Courier 10
          Pitch">module</font>.v</font><br>
    </blockquote>
    The files called <a moz-do-not-send="true" href="#PinsTxt">pins.txt</a>
    and <a moz-do-not-send="true"
      href="#Generating_Flip-flop_Initialization">module.init</a> are
    covered in the succeeding sections.&nbsp; The file pins.txt will be
    searched for if not found; it may be either in the current
    directory, the directory containing <b>dumbVerilog.py</b> itself
    (the usual case), or else specified with an explicit path.&nbsp; The
    parameters "module.net", "module.kicad_sch" (or just "module.sch"
    for KiCad v.5), and "module.v" are generally literal.&nbsp; As for
    the remaining command-line parameters:<br>
    <ul>
      <li><code><i>MODULE</i></code> would be something like "A1", "A2",
        etc.&nbsp; It's the designation of the specific logic module to
        which the schematic belongs.&nbsp; The tool doesn't actually use
        this for anything except as a unique identifier when multiple
        logic modules are interconnected, so if you're working with a
        circuit other than the official AGC modules, it doesn't really
        matter what you use here, though I would recommend that it still
        be of the form A<i>nn</i>.</li>
      <li><code><i>DELAY</i></code>, roughly speaking, is the
        propagation delay of signals from the input of a NOR gate to its
        output.&nbsp; The unit in which <code><i>DELAY</i></code> is
        expressed ultimately depends upon the time-scale that will be
        set in the test bench, but that's conventionally 100 ns.&nbsp;
        The nominal gate delay of AGC NOR gates was 20 ns, so that means
        a reasonable <code><i>DELAY</i></code> might be 0.2.</li>
      <li><code><i>WIRETYPE</i></code> is an optional parameter having
        the value either "<code>wire</code>" or "<code>wand</code>".&nbsp;











        It shouldn't matter which is chosen, so this parameter should
        probably be omitted.<br>
      </li>
    </ul>
    <h2><a name="PinsTxt"></a>The pins.txt File</h2>
    <p>Abstractly, the AGC circuitry consists of a number of "modules"
      (each represented by an electrical schematic), plugged into a
      "backplane".&nbsp; The backplane, again abstractly, consists of a
      set of connectors whose pins are interconnected by wires.&nbsp;
      However, there is no schematic diagram as such for the backplane,
      so to incorporate the backplane into our simulation the
      interconnections in the backplane must be specified in some other
      form.&nbsp; That alternate form of description is the pins.txt
      file, which is just a text file having a separate line in it for
      each pin of each connector on the backplane.&nbsp; <br>
    </p>
    <p>Each line of the file has four fields, delimited by space
      characters.&nbsp; Those fields are:<br>
    </p>
    <ol>
      <li>A module number (A<i>nn</i> or B<i>nn</i>).</li>
      <li>A pin number on the backplane connector for the module.<br>
      </li>
      <li>A signal type:&nbsp; IN, OUT, INOUT, BP, FIX, FOX, NC, SPARE</li>
      <li>A signal name (blank if signal type is NC or SPARE)<br>
      </li>
    </ol>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Technically, there
        are actually two separate backplanes, designated "A" and "B",
        into which the AGC modules A<i>nn</i> and B<i>n</i>n
        respectively plug, with some interconnections between the two
        backplanes.&nbsp; The pins.txt file describes both, so we may as
        well think of it simply as one big backplane.</font><br>
    </blockquote>
    <p>Regarding the module-to-backplane connectors, for the logic
      modules that interest us for simulation purposes, each module had
      a physical 284-pin connector consisting of 4 rows of 71 pins
      each.&nbsp; (The 21st pin from either end of a row was missing, so
      you could equally-well consider it physically to be a 276-pin
      connector consisting of 4 rows of 69 pins each.&nbsp; But the pin
      numbering pretends that the missing pins were present.)&nbsp; <i>On











        the other hand</i>, on the electrical schematics for the logic
      modules, each of the 71-pin rows was considered a separate
      connector, and thus the schematics show 4 separate connectors
      each, designated as J1, J2, J3, and J4.<br>
    </p>
    <p>Just to emphasize this point, in case the message was lost in the
      details:&nbsp; In pins.txt each backplane connector for a logic
      module has 284 pins, while on the logic module's electrical
      schematics there are instead 4 connectors of 71 pins each.<br>
    </p>
    <p>In principle, a separate pins.txt file should be used for each
      different AGC model.&nbsp; In practice, there's little difference
      between AGC models 2003200 and 2003993, and so there is presently
      a single pins.txt file used for those two models.&nbsp; As far as
      other AGC models is concerned, there is presently no available
      pins.txt for them.<br>
    </p>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Strictly speaking,
        this isn't quite true.&nbsp; The existing pins.txt was derived
        from Mike Stewart's digital simulation of the AGC.&nbsp; Mike's
        backplane pin data was derived in turn <a
          moz-do-not-send="true"
href="https://github.com/virtualagc/agc_simulation/blob/master/scripts/generate_agc_backplane.py">by











          a script</a> that analyzed his Verilog files.&nbsp; Thus if we
        indeed wanted to generate a separate pins.txt file for each
        Block II AGC model we'd have an awkward chicken-and-egg problem,
        since <b>dumbVerilog.py</b> needs pins.txt <i>before</i>
        generating our Verilog files, whereas the only automated way of
        generating pins.txt does so <i>after</i> creating the Verilog
        files.&nbsp; On the other hand, for Block I AGC's I've created a
        similar file, <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/pinsBlockI.txt">pinsBlockI.txt</a>,
        by processing Block I schematics (rather than Verilog files)
        using <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/pinsDbBlockI.awk">an











          AWK script</a>, so perhaps the same technique could be used
        for Block II as well.&nbsp; However, the pinsBlockI.txt file is
        in a somewhat different format than pins.txt, and <b>dumbVerilog.py</b>
        isn't presently able to support that particular format.&nbsp;
        Although I don't recall for certain, I suppose this means that I
        had only done preliminary work on Block I AGC simulation,
        without having taken it to the point of the simulation actually
        functioning.&nbsp; </font><br>
      <font size="-1"> </font></blockquote>
    <blockquote> </blockquote>
    <h2><a name="Generating_Flip-flop_Initialization"></a>The
      module.init file, dumbInitialization.py, and
      dumbInitialization0.py<br>
    </h2>
    <p><img alt="" src="dualNOR.png" moz-do-not-send="true" width="162"
        hspace="5" height="157" align="left">The only digital components
      present in AGC logic-module schematics are dual triple-input
      open-drain NOR gates (as in the figure to the left), which in
      themselves are stateless; i.e., the output signal of a NOR gate is
      directly determined by the <i>current</i> state of its input
      signals.&nbsp; Or at least, the output is determined by the state
      of the input signals after however long it takes the signals to
      propagate through the gate, which is nominally 20
      nanoseconds.&nbsp; Nevertheless, it is possible to interconnect
      NOR gates in such a way that a block of NOR gates has an output
      signal that does not necessarily depend on the current state of
      the inputs.&nbsp; In other words, the block of NOR gates has
      "memory".&nbsp; The most-common such circuit block in the AGC uses
      several NOR gates to form what's known as a "flip-flop"; i.e., a
      memory element capable of indefinitely storing a single bit
      indefinitely.&nbsp; Or rather, of storing a bit until the power is
      cycled, at which point the value of the bit is lost.&nbsp; The
      testVerilog circuit used in examples above is such a
      flip-flop.&nbsp; <br>
    </p>
    <p>This has an implication on the initial conditions for a digital
      simulation, since it might be useful to specify not only the
      levels of the input signals to the circuit being simulated, but
      the initial states of these implicit flip-flops as well.&nbsp; <i>After</i>
      power-up the simulation itself takes care of computing their
      states at later times.&nbsp; But the simulation first has to have
      some way of knowing what the states were at power-up in order to
      do that.<br>
    </p>
    <p>In the design of the <i>physical</i> AGC, almost no effort was
      given to putting these implicit flip-flops into any given
      state.&nbsp; (And in those cases where an effort had been made,
      the mechanisms used would put the simulated flip-flops into a
      known state too.)&nbsp; Rather, the developers just seemed to feel
      that the flip-flops would generally settle down into <i>some</i>
      stable state, and that happy thought proved to be adequate for
      their purposes.&nbsp; For <i>our</i> purposes, namely digital
      simulation, it's <i>not</i> enough!&nbsp; In simulation, it's
      perfectly possible for a such a flip-flop to oscillate
      indefinitely without ever settling down into some stable
      state.&nbsp; Indeed, that has happened to me many times.&nbsp; Not
      good!&nbsp; <br>
    </p>
    <p>One way to guarantee that the simulation will settle into a
      stable state is to give it initial conditions in which it's <i>already</i>
      in a stable state.&nbsp; Not all logical networks of NOR gates
      have have such a stable state.&nbsp; If, for example, our circuit
      consisted of a single NOR gate in which two of the inputs were
      tied LOW but the third input was connected to the output, then
      there is no logically-consistent set of signals, and the signal
      values change with each timestep.&nbsp; But besides being stable,
      we'd also like other properties to be satisfied, such as that all
      counter registers are zeroed out and that the RAM isn't being
      simultaneously read and written to.&nbsp; That the AGC does have
      some stable states we do know, simply because we do know that it
      can be simulated.&nbsp; Alas, finding such stable states with the
      additional constraints we'd like to impose has proven
      tricky.&nbsp; So in the interest of having a simulation which
      settles down, we're generally forced to start with some state
      having other properties that may not be entirely to our liking.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; Why the difference between
          the physical AGC and the simulated AGC?&nbsp; Why does a
          physical AGC quickly settle into a logically-consistent set of
          signal values, while Verilog simulation of it does not
          necessarily do so?&nbsp; I think it probably has to do with
          the fact that in the Verilog simulation, all of the logic
          gates have the same propagation delay at all times, whereas in
          a physical AGC the gates are all little different, as well as
          having propagation delays that vary with temperature and
          somewhat over time.&nbsp; The result is that there's a certain
          random element present in the evaluation order of the logic
          gates in the physical AGC that's not present in the
          simulation.&nbsp; Besides which, in a physical AGC, the logic
          gates are still analog circuits, so a difference of (say) a
          tenth of a volt has some effect, while in the digital
          simulation they're purely digital (exact 1's and 0's).</font><br>
      </p>
    </blockquote>
    <p>To specify the initial states of flip-flops, module.init allows
      you to state the initial output signal of any or all of the NOR
      gates.&nbsp; As we say in the figure above, a dual NOR-gate
      component used in the AGC has two outputs, which are designated as
      pin J for one of the NOR gates and K for the other of the NOR
      gates.&nbsp; The way these are specified in module.init is that
      there is a line in the file for each dual NOR component that you
      want to specify, and that line has the format<br>
    </p>
    <blockquote><i>Unnn OutputJ</i> [ <i>OutputK</i> [ <i>DelayJ</i> [
      <i>DelayK</i> ] ] ]<br>
    </blockquote>
    where <i>Unnn</i> is the reference designator of the dual-NOR
    component and <i>OutputJ</i> and <i>OutputK</i> are the output
    signal levels (0 or 1, default 0) at pins J and K of the dual-NOR
    component.&nbsp; <i>DelayJ</i> and <i>DelayK</i> are the
    respective propagation delays for the two NOR gates, in units as
    described for the <i>DELAY</i> parameter of <b>dumbVerilog.py</b>
    <a moz-do-not-send="true" href="#Converting_Netlist_to_Verilog">as
      discussed earlier</a>, which is also the default for any omitted <i>DelayJ</i>
    or <i>DelayK</i>.<br>
    <br>
    <img src="testVerilogCircuitInit.png" alt="" moz-do-not-send="true"
      width="228" hspace="5" height="319" align="right">You can also
    annotate the module.init file with comments (preceded by "#") or
    blank lines, if it helps you document what's being done.<br>
    <br>
    In general, there won't be any single "correct" module-init file,
    since the only constraint on possible module.init files is that the
    specified signal levels are logically consistent with respect to the
    properties of NOR gates.&nbsp; For a single flip-flop in its
    simplest form, there are two guaranteed consistent states, namely
    "on" and "off".&nbsp; Indeed, if there were a single
    logically-consistent configuration, then the circuit would be
    useless since its state could never change.&nbsp; So there are
    multiple consistent forms of module.init.&nbsp; For testVerilog, for
    example, one such form for module.init (and indeed, the one you may
    find within the repository) looks like:<br>
    <blockquote>
      <pre>U127 1 0<br>U129 1 0<br></pre>
    </blockquote>
    <p>In other words, U127's J output is 1 ("on") and K output is 0
      ("off"); and the same for U129.&nbsp; I've illustrated that in the
      image to the right by coloring NOR-gate outputs specified
      initially as 1 in <font color="#33cc00">green</font>, and those
      specified initially as 0 in <font color="#ff0000">red</font>.&nbsp;











      You don't need to specify the output for every NOR gate, and thus
      the outputs of U126 and U128 are left unspecified.&nbsp; But if
      you manually create the module.init file, it's entirely up to you
      to determine which ones you want to specify; and since not all
      possible combinations of signals are logically consistent, you
      must insure the consistency, which can be quite tiresome if done
      manually.&nbsp; Because of the way NOR gates work, specifying that
      U129's OutputJ is 1 <i>forces</i> U127 OutputK, U128 OutputJ, and
      U129 OutputK all to be 0.&nbsp; So if you specified any of those
      latter outputs to be 1, you'd be creating an inconsistent set of
      inital conditions.<br>
    </p>
    Fortunately, a consistent set of flip-flop initializations can
    conveniently be generated using the Python 3 script <b>dumbInitialization.py</b>.&nbsp;











    The syntax is simply<br>
    <blockquote>
      <p><font face="Courier 10 Pitch">dumbInitialization.py &lt;<i>TheVerilogSourceCode</i>.v</font></p>
    </blockquote>
    <p>where<code> <i>TheVerilogSourceCode</i>.v</code><code></code> is
      (surprise!) the Verilog source-code for which you wish to generate
      some initialization information.&nbsp; There are actually two
      basically-different scenarios in terms of acquiring the <i>TheVerilogSourceCode</i>.v










      file:<br>
    </p>
    <ol>
      <li>If you're interested in simulating a single module, you can
        just use module.v.</li>
      <li>If you're interested in simulating an entire AGC, you should
        concatenate the module.v files for each of the AGC's logic
        modules, end to end, into one big file.&nbsp; The order in which
        the individual files appear shouldn't matter (but probably
        does).<br>
      </li>
    </ol>
    <blockquote>
      <p><font size="-1"><b>Important note:</b>&nbsp; There are actually
          two such Python scripts provided, <b>dumbInitialization.py</b>
          and <b>dumbInitialization0.py</b>, with identical calling
          sequences.&nbsp; The practical difference between them is that
          they use different algorithms, and therefore have different
          convergence, as well as very likely producing different
          initializations.&nbsp; See <a moz-do-not-send="true"
            href="https://github.com/virtualagc/virtualagc/issues/1239">issue



            #1239</a>.&nbsp; <br>
        </font></p>
      <p><font size="-1">The <b>dumbInitialization0.py</b> program
          implements a kind of search algorithm, in which the "required"
          signal levels are applied and all logical consequences of
          those assignments are computed.&nbsp; Then an unassigned
          signal is chosen to have a value, and the logical consequences
          of that choice are computed too.&nbsp; And so on, until all
          signals are assigned values.&nbsp; But the logical consequence
          of such a signal assignment may turn out to be inconsistent
          with a value already assigned to a signal; in which case, the
          assignments are rolled back as far as necessary, and the
          opposite choice is made.&nbsp; This seems to work well for any
          <i>individual</i> AGC logic module, but when applied to a full
          AGC has never been found to terminate.&nbsp; Think of it this
          way:&nbsp; A full AGC has about 5000 signals, and thus a full
          assignment of signal values is a search for a consistent
          configuration within 2<sup>5000</sup> configurations.&nbsp;
          Even if the trick of computing all of the logical consequences
          of an assignment effectively removes 99% of the signals, it's
          still a search space of 2<sup>50</sup> configurations.&nbsp;
          Too big!&nbsp; Nevertheless, when it does succeed, we're
          guaranteed that the signals we'd like to force to some
          desirable value, such as the counter registers mentioned
          above, are indeed forced to those values.<br>
        </font></p>
      <p><font size="-1">The <b>dumbInitialization.py</b> program
          implements an entirely different algorithm.&nbsp; It assigns
          all of the "required" signal levels, with all of the other
          signals assigned 0, and then iterates simulations the same way
          as Verilog would do.&nbsp; Except that the "required" signals
          are reassigned their specified values at the beginning of each
          iteration, and that a random order is chosen in which to
          evaluate the logic gates.&nbsp; This algorithm did indeed
          converge to a logically-consistent configuration when used
          with <a moz-do-not-send="true" href="Verilog-KiCad-5.html">our


            older, KiCad 5 based simulation framework</a>, but fails to
          do so in the current framework that has been upgraded to KiCad
          6+.&nbsp; Presumably, that's due to some
          seemingly-insignificant difference in the order in which the
          nets are encountered in the EDA files, which tells us that the
          algorithm is somewhat fragile.&nbsp; A slight change to the
          algorithm seemingly causes it work again:&nbsp; The "required"
          signals are forced to specified values only for the first <i>N</i>
          iterations (say, 20), but then if there has been no
          convergence the signals are simply allowed to drift where they
          may on subsequent iterations.&nbsp; If this happens, most of
          the "required" signals may end up with their specified values,
          but some will not, and we just have to accept that.<br>
        </font></p>
      <p><font size="-1">In summary, we have a solution to the iteration
          problem that works pragmatically for us, at least for AGC
          models 2003200 and 2003993, but which unfortunately is not
          guaranteed in all cases.&nbsp; I wish I could think of a
          better algorithm!<br>
        </font> </p>
    </blockquote>
    <p>Actually, these are just the two extreme cases of the unified
      scenario "concatenate all of the module.v files comprising the
      circuit in which you're interested".&nbsp; But there's a practical
      difference between cases #1 and #2, in that if you decide you want
      to simulate (say) AGC model 2003993, you probably don't actually <i>know</i>
      without considerable research which particular logic modules
      comprise it, thus increasing the difficulty level.&nbsp; Another
      tricky aspect is that some logic-module drawing numbers are
      repeated in an AGC.&nbsp; For example for the Block I AGC,
      schematic 1006540A is used not only for module A1, but also for A2
      through A16 as well, and thus there is no single "module.v"
      associated with schematic 1006540A, but rather a module.v <a
        moz-do-not-send="true" href="#Converting_Netlist_to_Verilog">generated</a>
      for module A1, one generated for module A2, and so on.
      &nbsp;&nbsp; The table below is a handy cheat sheet of the logic
      modules vs schematic numbers relevant to various AGC models.&nbsp;
      I suppose I should warn you that the revision levels shown for the
      schematic drawings are simply the revisions we <i>have</i>,
      rather than necessarily the ones originally used.&nbsp; AGC model
      2003100, alas!, is highlighted mostly in <font color="#ff0000">red</font>
      to indicate schematics that haven't survived or to which we have
      no access.<a name="ReverseLookup"></a><br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th rowspan="2" colspan="1" valign="bottom" align="center">Logic<br>
            Module<br>
          </th>
          <th rowspan="1" colspan="5" valign="bottom" align="center">Drawing











            Number <br>
          </th>
          <th rowspan="1" colspan="2" valign="bottom" align="center">Module











            Description<br>
          </th>
        </tr>
        <tr>
          <th valign="bottom" align="center">AGC 1003565<br>
          </th>
          <th valign="bottom" align="center">AGC 1003700<br>
          </th>
          <th valign="bottom" align="center">AGC 2003100<br>
          </th>
          <th valign="bottom" align="center">AGC 2003200<br>
          </th>
          <th valign="bottom" align="center">AGC 2003993<br>
          </th>
          <th valign="bottom" align="center">Block I<br>
          </th>
          <th valign="bottom" align="center">Block II<br>
          </th>
        </tr>
        <tr>
          <td valign="top" align="center">A1<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005059E</font><br>
          </td>
          <td valign="top" align="center">2005259A<br>
          </td>
          <td valign="top" align="center">2005259A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Scaler Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A2<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center">2005060D<br>
          </td>
          <td valign="top" align="center">2005260A<br>
          </td>
          <td valign="top" align="center">2005260A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Scaler Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A3<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005051D</font><br>
          </td>
          <td valign="top" align="center">2005251A<br>
          </td>
          <td valign="top" align="center">2005251A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">S Q Register and Decoding<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A4<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005062C<br>
            </font></td>
          <td valign="top" align="center">2005262A<br>
          </td>
          <td valign="top" align="center">2005262A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Stage Branch Decoding Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A5<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005061D<br>
            </font></td>
          <td valign="top" align="center">2005261A<br>
          </td>
          <td valign="top" align="center">2005261A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Cross Point Generator No. I<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A6<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005063F<br>
            </font></td>
          <td valign="top" align="center">2005263A<br>
          </td>
          <td valign="top" align="center">2005263A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Cross Point Generator II<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A7<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005052D<br>
            </font></td>
          <td valign="top" align="center">2005252A<br>
          </td>
          <td valign="top" align="center">2005252A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Service Gates<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A8<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005055D<br>
            </font></td>
          <td valign="top" align="center">2005255-<br>
          </td>
          <td valign="top" align="center">2005255-<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">4 Bit Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A9<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005056C<br>
            </font></td>
          <td valign="top" align="center">2005256A<br>
          </td>
          <td valign="top" align="center">2005256A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">4 Bit Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A10<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005057E<br>
            </font></td>
          <td valign="top" align="center">2005257A<br>
          </td>
          <td valign="top" align="center">2005257A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">4 Bit Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A11<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005058D<br>
            </font></td>
          <td valign="top" align="center">2005258A<br>
          </td>
          <td valign="top" align="center">2005258A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">4 Bit Module<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A12<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005053F<br>
            </font></td>
          <td valign="top" align="center">2005253A<br>
          </td>
          <td valign="top" align="center">2005253A<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Parity and S Register<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A13<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005069E<br>
            </font></td>
          <td valign="top" align="center">2005269-<br>
          </td>
          <td valign="top" align="center">2005269-<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Alarms<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A14<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005064F<br>
            </font></td>
          <td valign="top" align="center">2005264A<br>
          </td>
          <td valign="top" align="center">2005264B<br>
          </td>
          <td valign="top">Logic Flow, Bit</td>
          <td valign="top">Memory Timing &amp; Addressing<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A15<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005065D<br>
            </font></td>
          <td valign="top" align="center">2005265A<br>
          </td>
          <td valign="top" align="center">2005265A<br>
          </td>
          <td valign="top">Logic Flow, Bit<br>
          </td>
          <td valign="top">RUPT Service<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A16<br>
          </td>
          <td valign="top" align="center">1006540A</td>
          <td valign="top" align="center">1006540A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005066D<br>
            </font></td>
          <td valign="top" align="center">2005266-<br>
          </td>
          <td valign="top" align="center">2005266-<br>
          </td>
          <td valign="top">Logic Flow, Bit<br>
          </td>
          <td valign="top">INOUT I<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A17<br>
          </td>
          <td valign="top" align="center">1006543D<br>
          </td>
          <td valign="top" align="center">1006543D<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005067B<br>
            </font></td>
          <td valign="top" align="center">2005267A<br>
          </td>
          <td valign="top" align="center">2005267A<br>
          </td>
          <td valign="top">Logic Flow "C"<br>
          </td>
          <td valign="top">INOUT II<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A18<br>
          </td>
          <td valign="top" align="center">1006542-<br>
          </td>
          <td valign="top" align="center">1006542-<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005068C<br>
            </font></td>
          <td valign="top" align="center">2005268A<br>
          </td>
          <td valign="top" align="center">2005268A<br>
          </td>
          <td valign="top">Logic Flow "B"<br>
          </td>
          <td valign="top">INOUT III<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A19<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005070E<br>
            </font></td>
          <td valign="top" align="center">2005270-<br>
          </td>
          <td valign="top" align="center">2005270-<br>
          </td>
          <td valign="top"><br>
          </td>
          <td valign="top">INOUT IV<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A20<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005054C<br>
            </font></td>
          <td valign="top" align="center">2005254-<br>
          </td>
          <td valign="top" align="center">2005254-<br>
          </td>
          <td valign="top"><br>
          </td>
          <td valign="top">Counter Cell I<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A21<br>
          </td>
          <td valign="top" align="center">1006556A<br>
          </td>
          <td valign="top" align="center">1006556A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005050J<br>
            </font></td>
          <td valign="top" align="center">2005250-<br>
          </td>
          <td valign="top" align="center">2005250-<br>
          </td>
          <td valign="top">Logic Flow "S"<br>
          </td>
          <td valign="top">Counter Cell II<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A22<br>
          </td>
          <td valign="top" align="center">1006553E<br>
          </td>
          <td valign="top" align="center">1006553E<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005071B<br>
            </font></td>
          <td valign="top" align="center">2005271-<br>
          </td>
          <td valign="top" align="center">2005271-<br>
          </td>
          <td valign="top">Logic Flow "P"<br>
          </td>
          <td valign="top">INOUT V<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A23<br>
          </td>
          <td valign="top" align="center">1006545-<br>
          </td>
          <td valign="top" align="center">1006545-<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005072C<br>
            </font></td>
          <td valign="top" align="center">2005272A<br>
          </td>
          <td valign="top" align="center">2005272A<br>
          </td>
          <td valign="top">Logic Flow "E"<br>
          </td>
          <td valign="top">INOUT VI<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A24<br>
          </td>
          <td valign="top" align="center">1006555A<br>
          </td>
          <td valign="top" align="center">1006555A<br>
          </td>
          <td valign="top" align="center"><font color="#ff0000">2005073A<br>
            </font></td>
          <td valign="top" align="center">2005273A<br>
          </td>
          <td valign="top" align="center">2005273A<br>
          </td>
          <td valign="top">Logic Flow "R"<br>
          </td>
          <td valign="top">INOUT VII<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A25<br>
          </td>
          <td valign="top" align="center">1006554-<br>
          </td>
          <td valign="top" align="center">1006554-<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow Q<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A26<br>
          </td>
          <td valign="top" align="center">1006549B<br>
          </td>
          <td valign="top" align="center">1006549B<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "J"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A27<br>
          </td>
          <td valign="top" align="center">1006544B<br>
          </td>
          <td valign="top" align="center">1006544B<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow D<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A28<br>
          </td>
          <td valign="top" align="center">1006552A<br>
          </td>
          <td valign="top" align="center">1006552A<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "N"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A29<br>
          </td>
          <td valign="top" align="center">1006559D<br>
          </td>
          <td valign="top" align="center">1006559D<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "V"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A30<br>
          </td>
          <td valign="top" align="center">1006548-<br>
          </td>
          <td valign="top" align="center">1006548-<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "H"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A31<br>
          </td>
          <td valign="top" align="center">1006548-</td>
          <td valign="top" align="center">1006548-<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "H"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A32<br>
          </td>
          <td valign="top" align="center">1006546A</td>
          <td valign="top" align="center">1006546A<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "F"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A33<br>
          </td>
          <td valign="top" align="center">1006547G<br>
          </td>
          <td valign="top" align="center">1006547G<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "G"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A34<br>
          </td>
          <td valign="top" align="center">1006547G<br>
          </td>
          <td valign="top" align="center">1006547G<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "G"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A35<br>
          </td>
          <td valign="top" align="center">1006541B<br>
          </td>
          <td valign="top" align="center">1006541B<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "A"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A36<br>
          </td>
          <td valign="top" align="center">1006557D<br>
          </td>
          <td valign="top" align="center">1006557D<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "T"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A37<br>
          </td>
          <td valign="top" align="center">1006550F<br>
          </td>
          <td valign="top" align="center">1006550F<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "L"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">A38<br>
          </td>
          <td valign="top" align="center">1006551-</td>
          <td valign="top" align="center">1006551-<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top">Logic Flow "M"<br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">A52<br>
          </td>
          <td valign="middle" align="center"><br>
          </td>
          <td valign="middle" align="center"><br>
          </td>
          <td valign="middle" align="center"><br>
          </td>
          <td valign="middle" align="center">2003305B<br>
          </td>
          <td valign="middle" align="center"><br>
          </td>
          <td valign="top"><br>
          </td>
          <td valign="top">Restart Monitor Channel 77 Alarm Box<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">Fixed and Erasable Memory<br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center"><br>
          </td>
          <td valign="top" align="center">fixed_erasable_memory<br>
          </td>
          <td valign="top" align="center">fixed_erasable_memory<br>
          </td>
          <td valign="top" align="center">fixed_erasable_memory<br>
          </td>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>Because <b>dumbInitialization.py</b> expects to be dealing with
      a collection of modules rather than necessarily an individual
      module, it does not output any file specifically called
      "module.init".&nbsp; Rather, it expects to be operating on an
      entire AGC circuit, so it outputs separate initialization files
      for each of the AGC's logic modules:&nbsp; A1.init, A2.init, and
      so on.&nbsp; As you may recall, the testVerilog circuit is a
      snippet from the circuit for logic module A1, so we'd have to
      rename A1.init as module.init after running <b>dumbInitializion.py</b>.&nbsp;











      Still, the operation seems pretty simple.<br>
    </p>
    <p>This supposed simplicity hides a nasty chicken-and-egg truth,
      namely that we need to have module.init for <b>dumbVerilog.py</b>
      to produce module.v, and we need module.v for <b>dumbInitialization.py</b>
      to produce module.init.&nbsp; Catch 22!<br>
    </p>
    <p>Fortunately, this circle is not as vicious as it appears, since
      all you really have to do is follow this 3-step procedure:<br>
    </p>
    <ol>
      <li>Use <b>dumbVerilog.py</b> with an <i>empty</i> module.init,
        or else one of your own devising, to create module.v.&nbsp; We
        actually provide such an empty module.init
        (Schematics/empty.init) for this very purpose.<br>
      </li>
      <li>Use <b>dumbInitialization.py</b> to generate A1.init, and
        rename A1.init as module.init.<br>
      </li>
      <li>Use <b>dumbVerilog.py</b> again, to regenerate module.v.</li>
    </ol>
    <p>And indeed, this process works for us, giving us<br>
    </p>
    <blockquote>
      <pre># Auto-generated for module A1 by dumbInitialization.py.<br>U127 1 0<br>U129 1 0<br></pre>
    </blockquote>
    <strike></strike>
    <h2><a name="Converting_Verilog_Module_to_Verilog"></a>Converting
      Verilog Module to Verilog Test Bench</h2>
    The preceding sections have described how to create a Verilog
    description of each individual AGC module, and the initialization
    for that Verilog, but only in such a way that the modules stand
    alone and don't fit together in any meaningful way.&nbsp; It's as if
    the individual AGC modules weren't plugged into the AGC's
    backplane.&nbsp; A "test bench", which itself is Verilog source code
    is like the backplane in that it provides a way to wire all of the
    AGC modules' Verilog files together.<br>
    <br>
    You have some choices to make and some manual work to do in creating
    the test bench.&nbsp; But first, there's an automation procedure
    that can be performed to get you partway there.&nbsp; Recall that in
    the preceding section we talked about how to create what we called <i>TheVerilogSourceCode</i>.v











    for the circuitry you want to simulate.&nbsp; We reuse that file
    right now:<br>
    <blockquote><font face="Courier 10 Pitch">dumbTestbench.py &lt;<i>TheVerilogSourceCode</i>.v











        &gt;<i>TestBench</i>.v</font><br>
    </blockquote>
    The Verilog source-code created by <b>dumbTestbench.py</b> is not <i>quite</i>
    the complete test bench, because <b>dumbTestbench.py</b> isn't
    aware of any personalized choices which needs to be made by you
    rather than by a computer.&nbsp; The file it creates, <i>TestBench</i>.v,











    itself imports another Verilog source-code file called "tb.v" to
    contain these personalized changes, and it's this file tb.v that you
    must create.&nbsp; The kinds of customizations covered by tb.v
    include such things as:<br>
    <ul>
      <li>Messages printed by the simulation at startup, on termination,
        or upon other conditions.</li>
      <li>How long the simulation is supposed to last.</li>
      <li>The name of a file to which simulated events and signals are
        logged.</li>
      <li>The list of signals that are logged.</li>
      <li>The manner in which input signals are changed over time.</li>
      <li>And so on.<br>
      </li>
    </ul>
    Unfortunately, it's outside of my scope here to give you a full
    introduction to Icarus Verilog testbenches, so I'd advise you to
    search for online tutorials and documentation that supply a better
    grounding on the subject.&nbsp; For reference in your perusing those
    materials, here's the test-bench file created by dumbTestbench.py
    for the testVerilog example used so often above,<br>
    <blockquote>
      <pre>// Verilog testbench created by dumbTestbench.py<br>`timescale 1ns / 1ps<br><br>module agc;<br><br>parameter GATE_DELAY = 20;<br>`include "tb.v"<br><br>wire F02A, F02B, FS02, FS02A;<br><br>A1 iA1 (<br>  rst, FS01_, F02A, F02B, FS02, FS02A<br>);<br>defparam iA1.GATE_DELAY = GATE_DELAY;<br><br>endmodule<br></pre>
    </blockquote>
    and here's the tb.v file it includes, as created by me:<br>
    <blockquote>
      <pre>// Include-file used by dumbTestbench.py for automating testbench generation.<br><br>reg rst = 1;<br>initial begin<br>  // Assume compilation with -fst switch.<br>  $dumpfile("testVerilog.fst");<br>  $dumpvars(0, agc);<br>  <br>  # 2000 rst = 0;<br>  # 500000 $finish;<br>end<br><br>reg FS01_ = 0;<br>always #4882.8125 FS01_ = !FS01_;<br>  <br>initial<br>  $timeformat(-6, 0, " us", 10);<br>initial<br>  $monitor("At time %t, rst=%d, FS01_=%d, F02B=%d, FS02=%d, FS02A=%d, FS02A=%d", $time, rst, FS01_, F02B, FS02, F02A, FS02A);<br></pre>
    </blockquote>
    Some of the features of this file were <a moz-do-not-send="true"
      href="#TestbenchExplanations">already explained earlier</a>, at
    least somewhat, though the testbench discussed there was a somewhat
    earlier version than the one shown above.<br>
    <h2><a name="compilation"></a>Compilation of the Verilog Source Code</h2>
    The Icarus Verilog compiler, <b>iverilog</b>, has a lot of options
    <a moz-do-not-send="true"
      href="https://steveicarus.github.io/iverilog/">that you can
      research online</a> if you need them.&nbsp; I'm not aware of any
    options we need, though, and think that compilation is just<br>
    <blockquote>
      <pre>iverilog -o <i>OUTPUT</i>.vvp <i>List_Of_Verilog_Source_Code_Files_Including_The_Test_Bench</i><br></pre>
    </blockquote>
    <p>For a single logic module or other standalone schematic, that's
      typically just<br>
    </p>
    <blockquote>
      <pre>iverilog -o module.vvp module_tb.v module.v<br></pre>
    </blockquote>
    <p>For a collection of modules, such as an entire AGC, the basic
      command is still the same, but it's a bit more complicated since
      the list of Verilog source-code files is much larger and includes:</p>
    <ul>
      <li>One source-code file for each module.&nbsp; If schematics are
        reused for several modules, there will still be separate Verilog
        files for each, since they will have been generated (using <b>dumbVerilog.py</b>)
        with different module designations (A1, A2, A3, and so on).</li>
      <li>One for the ROM containing the AGC software the simulated CPU
        will run.</li>
      <li>One for the test bench.</li>
    </ul>
    <h2><a name="RunningTheSimulation"></a>Running the Simulation</h2>
    <p>This is the easiest thing of all, since the command is simply<br>
    </p>
    <blockquote>
      <pre>vvp module.vvp -fst<br></pre>
    </blockquote>
    <p>The <font color="#663300"><code>-fst</code></font> option
      perhaps requires some explanation.&nbsp; It selects the file
      format to be used for logging simulation data.&nbsp; Because our
      intention is to use <b>gtkwave</b> to visualize the logged data
      (see the next section), it's necessary to choose a file format
      supported both by <b>vvp</b> and by <b>gtkwave</b>, or at least
      can be inter-converted.&nbsp; At the <i>present</i> writing (<b>vvp</b>
      v11 and <b>gtkwave</b> v3.3.<i>x</i>), that would appear to be a
      wide and confusing range of formats:<br>
    </p>
    <ul>
      <li><b>vvp</b>:&nbsp; VCD, LXT, LXT2, FST</li>
      <li><b>gtkwave</b>:&nbsp; VCD, FST, <i>LXT</i>, <i>LXT2</i>, <i>VZT</i>,
        <i>IDX</i>, GHW, <i>AET2</i>, <i>VPD</i>, <i>WLF</i>, <i>FSDB</i></li>
    </ul>
    <p>The bad news or good news (depending on your point of view) is
      that <b>gtkwave</b> documentation makes it clear that all of the
      formats I've <i>italicized</i> are scheduled to be deleted in <b>gtkwave</b>
      v4, in addition to which GHW is a format used only for VHDL and
      therefore is unlikely ever to be supported by Verilog
      systems.&nbsp; That leaves <i>only</i> VCD and FST likely to be
      common to <b>iverilog</b> and <b>gtkwave</b> in the
      future.&nbsp; Of these two remaining formats, VCD (from <b>gtkwave</b>
      documentation) "is the industry standard file format generated by
      most Verilog simulators and is specified in IEEE-1364. This is the
      <b>slowest</b> of the formats for the viewer to process and
      requires the most memory. However, this format is ubiquitous, and
      almost all tools support it".&nbsp; Whereas FST "is designed for
      very fast sequential and random access".&nbsp; Which to choose is,
      of course, a matter of personal preference.&nbsp; <i>My</i>
      choice is FST, due to the fact that FST files are incredibly
      smaller than VCD files.&nbsp; The use of the transaction filters
      we supply for "enhanced viewing" of the simulation results as
      described in the next section assume an FST file format.<br>
    </p>
    <h2><a name="visualization"></a>Visualization of the Simulation Data</h2>
    <p>It may be useful to review <a moz-do-not-send="true"
        href="https://gtkwave.github.io/gtkwave/index.html">the gtkwave
        documentation</a> if you have questions, rather than relying on
      anything I have to say about it.&nbsp; At the simplest level, the
      command to initiate the result viewer is just<br>
    </p>
    <blockquote>
      <pre>gtkwave agc.fst<br></pre>
    </blockquote>
    But there are additional subtleties worth knowing about.&nbsp; <br>
    <br>
    For one thing, an AGC has a lot of signals in it that are tracked by
    most simulations, and usefully viewing those signals involves
    deciding not only which signals should be displayed, but also the
    order in which they're displayed, perhaps how they are colorized,
    setting up transaction filters, and so on.&nbsp; Getting the
    displayed signals <i>just so</i>, in their most-useful form to you,
    can be a lengthy, tedious affair.&nbsp; And if you have to do it
    more than once, it can be a <i>very</i> lengthy, <i>very</i>
    tedious affair.&nbsp; One way around this, once you have things set
    up to your satisfaction, is to use GTKWave's menu option <font
      color="#663300">File</font> / <font color="#663300">Write Save
      File</font> (or <font color="#663300">File</font> / <font
      color="#663300">Write Save File As</font>).&nbsp; This operation
    saves all of the information needed to recreate your setup, as a
    file with the extension ".gtkw".&nbsp; For example, if you're
    viewing the simulation results from a log file called agc.fst, then
    using <font color="#663300">File</font> / <font color="#663300">Write



      Save File</font> might save your setup information as
    agc.fst.gtkw.&nbsp; When you later want to view data again using the
    same setup, then rather than using the command given above, you can
    instead invoke<br>
    <blockquote>
      <pre>gtkwave agc.fst.gtkw</pre>
    </blockquote>
    Or, you can use the GTKWave menu option <font color="#663300">File</font>
    / <font color="#663300">Read Save File</font>.<br>
    <br>
    Recall the instruction-decoding transaction filter that I <a
      moz-do-not-send="true" href="#decoder">illustrated earlier</a>).&nbsp;


    There are actually two separate optional transaction filters
    provided in the Virtual AGC source tree:<br>
    <ul>
      <li>Scripts/instruction_trans_decoder.py decodes the raw signals
        provided by the simulation, and interprets them essentially as
        AGC instructions, constructing a mnemonic and operand for each
        one.&nbsp; At minimum, it requires that the following signals be
        present in the log dumped by the simulation process:&nbsp; MINC,
        DINC, PINC, INKL, T07, T01, TSUDO_, G16, G15, G14, G13, G12,
        G11, G10, G09, G08, G07, G06, G05, G04, G03, G02, G01, FUTEXT,
        IC2, STG3, STG2, STG1, WSQG_, GOJAM, RPTFRC, PCDU, MCDU, SHINC,
        SHANC, S12, S11, S10, S09, S08, S07, S06, S05, S04, S03, S02,
        S01.</li>
      <li>Scripts/u_trans_decoder.py requires the signals SUMA01_
        through SUMA16_ and SUMB01_ through SUMB16_.&nbsp; Its purpose
        is to display these signals, inverted, as a single 16-bit octal
        number referred to as "U", which is actually the output of an
        adder circuit rather than a true CPU register.&nbsp; The reason
        it's useful if you're tracing through AGC program execution is
        that most of the time what that adder is used for is computing
        the address of the next word to be fetched from the core
        rope:&nbsp; i.e., the address of the next instruction or the
        next instruction's operand.&nbsp; <br>
      </li>
    </ul>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; The required signals
        just mentioned may not be the exact signal names in so far as a
        .gtkw file is concerned.&nbsp; For example, for Virtual AGC
        simulations, the names appearing in the .gtkw file are all
        prefixed by "agc.", whereas in Mike's simulations they may be
        prefixed by "main.AGC.", or by some even-more-complex
        prefix.&nbsp; Inspecting existing .gtkw files, which are just
        text files, may be more useful than trying to guess the absurd
        names being employed.</font><br>
    </blockquote>
    I've provided a convenient template file, Schematics/agc.gtkw, that
    applies both the instruction-decoder and U transaction templates to
    an assumed simulation-result dumpfile called agc.fst.&nbsp; Besides
    which, it also displays all of the required signals for those
    transaction filters.&nbsp; Of course, you probably don't care
    anything about those particular signals, and can delete their
    waveforms in order to show other signals more interesting to you,
    but you may find it a convenient starting point for your own
    customization.&nbsp; The agc.gtkw file is what the <b>simulateAGC</b>
    scripts use when they display the simulation results for your
    inspection.<br>
    <br>
    If you'd like to bypass the template agc.gtkw completely, or apply
    your own custom transaction filters, you can go about it like so:<br>
    <ul>
      <li>Cause all of the transaction filter's required signals to be
        displayed as waveforms.</li>
      <li>Highlight them (in the Signals pane to the left of the
        waveforms).</li>
      <li>Use the menu option <font color="#663300">Edit</font> / <font
          color="#663300">Combine Up</font> (or <font color="#663300">Edit</font>
        / <font color="#663300">Combine Down</font>) to "combine" all
        of those signals as a single hexadecimal number.&nbsp; Think of
        the combined signals as being a bus.&nbsp; You will be asked to
        give a name for the bus, and you can choose anything that seems
        reasonable to you, such as "Instruction" or "U".</li>
      <li>Double-click on the name of bus, so that all of the waveforms
        of the individual signals disappear, leaving just the
        hexadecimal waveform.</li>
      <li>Right-click (or use the menu option Edit), and in the pop-up
        menu that appears do <font color="#663300">Data Format</font> /
        <font color="#663300">Transaction Filter Process</font> / <font
          color="#663300">Enable and Select</font>.&nbsp; Then use <font
          color="#663300">Add Trans Filter to List</font>, to find the
        desired Python script that implements the transaction
        filter.&nbsp; Once that script appears in the pane labeled
        "Transaction Process Filter Select", highlight it and hit <font
          color="#663300">OK</font>.&nbsp; Instead of displaying a
        hexadecimal number, the waveform of the bus (after possibly some
        delay for processing) will now show the decoded instruction, the
        U register, or whatever the transaction filter you applied
        required it to display.</li>
    </ul>
    <p>As far as currently-nonexistent transaction filters that might
      prove useful are concerned, here's an idea I've had but am too
      lazy to look into myself:&nbsp; When you're using the simulation
      results to trace program execution and want to compare against the
      original assembly listing of the AGC program, something that might
      be even more useful in some ways than the decoded instructions and
      the U "register" are the octal words I've highlighted in red
      below:<br>
    </p>
    <pre><meta http-equiv="content-type" content="text/html; charset=UTF-8"><pre><font color="#63452c">000061,000061:    4000           </font><font color="#c64600">00004</font><font color="#63452c">                           INHINT                                 	# GO
000062,000062:    4001           </font><font color="#c64600">37613</font><font color="#63452c">                           CA       O37774                        	# Schedule the first TIME3 interrupt
000063,000063:    4002           </font><font color="#c64600">54026</font><font color="#63452c">                           TS       TIME3                         	#
000064,000064:    4003           </font><font color="#c64600">14054</font><font color="#63452c">                           TCF      INIT                          	# Proceed with initialization
000121,000121:    4054           </font><font color="#c64600">00003</font><font color="#63452c">        INIT               RELINT                                 	#
000122,000122:    4055           </font><font color="#c64600">30007</font><font color="#63452c">                           CA       ZEROES                        	# zero out A
000123,000123:    4056           </font><font color="#c64600">54061</font><font color="#63452c">                           TS       ERRNUM                        	# and the error-code
000124,000124:    4057           </font><font color="#c64600">54062</font><font color="#63452c">                           TS       ERRSUB                        	#
					      <i>			 ... Some comments omitted ...</i>
000152,000152:    4060           </font><font color="#c64600">24061</font><font color="#63452c">                           INCR     ERRNUM                        	#
000153,000153:    4061           </font><font color="#c64600">30005</font><font color="#63452c">                           CA       Z                             	# fetch Z.
000154,000154:    4062           </font><font color="#c64600">54001</font><font color="#63452c">        DEST1              TS       L  </font></pre></pre>
    <p>But I leave that as an exercise for the reader.&nbsp; If you
      manage to invent a transaction filter that produces these numbers,
      let me know.&nbsp; Eternal glory awaits!&nbsp; Mike Stewart offers
      the following hints for any takers of this challenge:<br>
    </p>
    <blockquote><font size="-1"><b>Hints:</b>&nbsp; You could capture
        them from the sense amplifier lines. The full word is briefly
        loaded into B between instructions. And the bits are written
        into the SQ and S registers. All of this is pretty transient, so
        if you want your display to be correct for the entire
        instruction you'll probably have to make a transaction decoder
        that only latches changes when the instruction word is available
        wherever you're grabbing it from.<br>
      </font></blockquote>
    But if you want to <i>really</i> have fun, here's my suggestion for
    you:&nbsp; Make a transaction filter that captures signals to/from
    the DSKY, and implement a simulated DSKY in your transaction filter
    ... which, remember, is just a Python program.&nbsp; Yum!<br>
    <ul>
    </ul>
    <h2><a name="Tying"></a>Tying It All Together</h2>
    <h3><a name="simulateBlockII"></a>For a Single Block II Logic
      Module, a Portion Thereof, or Similar</h3>
    As mentioned earlier, if you're running Linux or Windows, I've
    written a shell script (for Linux) and a corresponding batch file
    (for Windows) that combines all of the steps, mostly.&nbsp; So far,
    I have no Mac OS equivalent.<br>
    <br>
    All you have to do is this:<br>
    <ol>
      <li>Create a schematic (module.sch for KiCad v5- or
        module.kicad_sch for KiCad v6+), if it doesn't already exist.<br>
      </li>
      <li><a moz-do-not-send="true"
href="file:///mnt/STORAGE/home/rburkey/git/virtualagc-web/Verilog.html#tbdotv">Create







          a tb.v file, as described above</a>.</li>
      <li>From within the folder containing your schematic and the tb.v
        file, run the following command:</li>
    </ol>
    <blockquote>
      <blockquote>
        <pre>simulateBlockII A1 [<i>NETLIST</i>.net]<br></pre>
      </blockquote>
    </blockquote>
    <p>Of course, the parameter A1 is specific to the testVerilog
      example, and probably would be something else for you.&nbsp; The
      module.net parameter is optional, in the sense that <b>simulateBlockII</b>
      will try to generate a file called module.net itself if the
      parameter is missing, but <i>NETLIST</i>.net must already exist
      if the parameter is present.&nbsp; KiCad v7 or later is required
      if you're going to omit the <i>NETLIST</i>.net parameter.</p>
    <h3> <a name="simulateAGC"></a>For an Entire AGC</h3>
    The equivalent to <b>simulateBlockII</b> for an entire AGC is the
    shell script <b>simulateAGC</b>.&nbsp; I do not yet have a Windows
    batch that duplicates this shell script, so for now it's only for
    platforms like Linux or Mac OS that support <b>bash</b>-type shell
    scripts unless you have some way to run <b>bash</b> scripts on your
    Windows machine.&nbsp; The script is run from the Schematics/ folder
    containing the folders for the individual schematics.&nbsp; The
    usage is:<br>
    <blockquote>
      <pre><font color="#663300">simulateAGC <i>AGC_MODEL</i> <i>AGC_SOFTWARE</i> "<i>VERILOG_OPTIONS</i>"</font><br></pre>
    </blockquote>
    Any of the command-line parameters can be omitted (from the end of
    the line) or replaced by "" to use default values for them.<br>
    <br>
    These parameters are:<br>
    <ul>
      <li><i><code>AGC_MODEL</code></i>:&nbsp; One of 1003565, 1003700,
        2003100, 2003200, or 2003993 (the default).&nbsp; However,
        1003565 and 1003700 are in fact equivalent, as are 2003200 and
        2003993.&nbsp; At present, the simulation isn't yet expected to
        work for Block I AGC's, and we do not yet have any of the
        schematic diagrams for Block II model 2003100.&nbsp; So in
        reality, the only truly-useful choice is essentially 2003993.</li>
      <li><i><code>AGC_SOFTWARE</code></i>:&nbsp; Any of the software
        versions present in Schematics/roms/, such as Comanche055,
        Luminary099, or Borealis.&nbsp; The default is
        Validation-hardware-simulation.</li>
      <li><code>"<i>VERILOG_OPTIONS</i>"</code>:&nbsp; A quoted list of
        space-separated options used to override hard-coded values in
        the testbench files tb-<i><code>AGC_MODEL</code></i>.v.&nbsp;
        Here are some of the individual options which can appear in the
        list:</li>
      <ul>
        <li><code>-Pagc.GATE_DELAY=<i>N</i> </code>— Specify the
          NOR-gate propagation delay in nanoseconds.&nbsp; Default is
          20.</li>
        <li><code>-DRUNLENGTH=<i>N</i></code> <code></code>— Length of
          the simulation run, in nanoseconds.&nbsp; Default is 250000000
          (i.e., 250 milliseconds).<br>
        </li>
        <li><code>-DSPOOF_SC</code><code> </code>— Provides a Verilog
          model for certain signals from the spacecraft.&nbsp; It is
          primarily useful in attempting to match simulation results
          versus simulation results from Mike Stewart's Verilog-based
          simulation of the AGC.</li>
        <li><code>-DDUMP_ALL</code><code> </code>— Dump <i>all</i> AGC
          signals to the simulation-result dumpfile.&nbsp; <b>Note:</b>&nbsp;




          The various <code>DUMP_<i>xxx</i></code> options are mutually
          exclusive, and <code>-DDUMP_ALL</code><code></code> is the
          default. <br>
        </li>
        <li><code>-DDUMP_DECODER</code><code> </code>— Dump just those
          signals needed for the instruction-decoder and U "transaction
          filters" to the simulation-result dumpfile.&nbsp; I'd regard
          this as the minimal useful set of signals logged for a
          full-AGC simulation.</li>
        <li><code>-DDUMP_HELPFUL</code> <code> </code>— Dump the <code>DUMP_DECODER</code>
          signals, along with the signals for the contents of the CPU
          registers A, L, Z, S, EB, and FB. </li>
        <li><code>-DDUMP_BACKPLANE</code> <code> </code>— Dump all
          signals from the AGC's backplane to the simulation's output
          dataset.<br>
        </li>
      </ul>
    </ul>
    A number of the <code><i>VERILOG_OPTIONS</i></code> settings have
    significant effects on the size of the simulation-result dumpfile
    produced when the simulation is run.&nbsp; The effect of <code>RUNLENGTH</code>
    on filesize is (obviously) that they are more-or-less
    proportional.&nbsp; But the <code>DUMP_<i>xxx</i></code> settings
    have a very dramatic effect on filesize as well.&nbsp; It's up to
    you to figure out the tradeoff of signal availability vs filesize,
    since only you can guess how useful various signals are going to be
    to you.&nbsp; For a 250 ms simulation run, here's the rough tradeoff
    in dumpfile-size vs signal selection:<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="top">Signal Selection<br>
          </th>
          <th valign="top">Number of Available AGC Signals<br>
          </th>
          <th valign="top">Simulation-Result Dumpfile Size<br>
          </th>
        </tr>
        <tr>
          <td valign="middle" align="center"><code>DUMP_DECODER</code></td>
          <td valign="middle" align="center">~80<br>
          </td>
          <td valign="middle" align="center">~240 KB<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><code>DUMP_HELPFUL</code></td>
          <td valign="middle" align="center">~150<br>
          </td>
          <td valign="middle" align="center">~400 KB<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><code>DUMP_BACKPLANE</code></td>
          <td valign="middle" align="center">~2000<br>
          </td>
          <td valign="middle" align="center">~14 MB<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><code>DUMP_ALL</code></td>
          <td valign="middle" align="center">~5000<br>
          </td>
          <td valign="middle" align="center">~27 MB<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    Of course, if you don't like the signal choices provided by the <code>DUMP_<i>xxx</i></code>
    constants, there's nothing at all to stop you from inventing your
    own selection of signals, as well as inventing your own name for the
    group (such as <code>DUMP_MINE</code>), and adding them to the tb-<i>AGC_MODEL</i>.v


    file of your choice.<br>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center> <br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">Creative
Commons











          No Rights Reserved License</a></span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2025-02-21<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" width="300" height="100"
              border="0"></a><br>
        </font></i> </center>
    <br>
    <br>
  </body>
</html>
