<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Virtual AGC Electrical/Mechanical Page</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <div align="center">
      <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Hardware Simulation Page").replace("@SUBTITLE@","Digital Simulation of the AGC Electronics"))</script><br>
      <font size="+1"><i>(This page is currently being substantially
          reworked!)<br>
        </i></font></div>
    <br>
    <h1><a name="Contents"></a>Contents</h1>
    <ul>
      <li><a href="#Introduction">Introduction</a><br>
      </li>
      <li><a href="#References">References</a></li>
      <li><a moz-do-not-send="true" href="#WorkstationSetup">Workstation
          Setup</a><br>
      </li>
      <li><a href="#An_Example:_testVerilog">First Example: Simulating a
          Small Digital Circuit</a></li>
      <li><a moz-do-not-send="true" href="#EntireAGC">Big Example:&nbsp;
          Simulating an Entire AGC</a></li>
      <ul>
        <li><a moz-do-not-send="true" href="#SomeBackground">Some
            Background Information</a><br>
        </li>
        <li><a href="#Steps_1_2_and_3:_Creating_Verilog">Workflow Steps
            1, 2, and
            3: Creating Verilog Source-Code Files Corresponding To the
            AGC Schematics</a><br>
        </li>
        <li><a href="#Step_4:_The_Test_BenchTBD">Workflow Step 4: The
            Test Bench,
            and Initial States and Gate Delays<br>
          </a></li>
        <ul>
          <li><a href="#module.init">module.init</a></li>
          <li><a href="#Testbench_files">Testbench files</a><br>
          </li>
        </ul>
        <li><a href="#Step_5:_Providing_ErasableFixed_Memory">Workflow
            Step 5:
            Providing Erasable/Fixed Memory</a><br>
        </li>
        <li><a href="#Step_5:_Compilation_of_the_Verilog">Workflow Step
            6:
            Compilation of the Verilog</a></li>
        <li><a href="#Step_6:_Running_the_Simulation">Workflow Step 7:
            Running the
            Simulation</a></li>
        <li><a href="#Step_7:_Viewing_the_Results">Workflow Step 8:
            Viewing the
            Results</a></li>
      </ul>
      <li><a href="#Appendix:_Translation_from_KiCad_into">Appendix:
          Technical Details</a></li>
      <ul>
        <li><a moz-do-not-send="true" href="#CreatingSchematic">Creating/Editing
            a Schematic Diagram</a><br>
        </li>
        <li><a moz-do-not-send="true" href="#CreatingNetlists">Creating
            a Netlist</a><br>
        </li>
        <li><a href="#Converting_Netlist_to_Verilog">Converting Netlists
            to Verilog Source code</a></li>
        <li><a moz-do-not-send="true" href="#PinsTxt">The pins.txt File</a><br>
        </li>
        <li><a href="#Generating_Flip-flop_Initialization">Generating
            Flip-Flop Initialization Files (module.init)</a><br>
        </li>
        <li><a href="#Converting_Verilog_Module_to_Verilog">Converting
            Verilog Module(s) to Verilog Test Bench</a><br>
        </li>
      </ul>
    </ul>
    <h1><a name="Introduction"></a>Introduction</h1>
    <p>Digital simulation of the AGC electrical design can provide
      detailed insight into how the computer functions.&nbsp; Aside from
      satisfying simple personal interest,
      this is very valuable if you wish to create a simulation of the
      AGC, in the manner of Virtual AGC Project's <a
        href="http://www.ibiblio.org/apollo/yaAGC.html">Block II AGC
        software simulator</a> or <a
        href="Block1.html#Virtual_AGCs_CPU_Simulator_yaAGCb1">Block I
        AGC software simulator</a>, or John Pultorak's <a
href="http://www.ibiblio.org/apollo/Pultorak.html#John_Pultoraks_Block_I_AGC">Block
I
        AGC hardware simulator</a>, and want to have some way of
      verifying that your creation works properly.<br>
    </p>
    <p>Realize, though, that the purpose of such simulations can only
      be accurate examination or verification of AGC behavior, and they
      are not practical substitutes for software (such as our <a
        moz-do-not-send="true" href="yaAGC.html"><b>yaAGC</b></a>
      program) designed and dedicated solely to running AGC
      software.&nbsp; While you <i>can</i> use digital electrical
      simulations to run AGC software, these simulations are very much
      slower than real
      time.&nbsp; One day, as computer speeds continue to advance, I
      expect that digital electrical simulations will be much faster
      than now!&nbsp; But not now.&nbsp; Recognize too that while
      simulation of the AGC or DSKY's <i>analog</i> circuitry is also
      possible, that's not what I'm talking about here.&nbsp; It is
      simulation of the digital circuitry — i.e., the collection of
      logic gates in the AGC — that will be of interest.<br>
    </p>
    <p>Here's an executive summary of the workflow of the
      digital-simulation process as I envisage it:&nbsp; <br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" height="739"
      align="center">
      <tbody>
        <tr>
          <th valign="bottom">#<br>
          </th>
          <th valign="bottom">Workflow Step<br>
          </th>
          <th valign="bottom">Comment<br>
          </th>
        </tr>
        <tr>
          <td valign="middle">1<br>
          </td>
          <td valign="middle">The electrical schematics — in our case,
            the original schematics of the AGC — are transcribed for use
            with modern schematic-capture software.</td>
          <td valign="middle">The schematic-capture software in question
            is called <a moz-do-not-send="true"
              href="https://www.kicad.org/"><b>KiCad</b> EDA</a>.&nbsp;
            The transcribed schematic files are <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">here</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">2<br>
          </td>
          <td valign="middle">Netlists — i.e., files that list
            every electrical connection in a given electrical schematic
            — are created.<br>
          </td>
          <td valign="middle"><b>KiCad</b> itself creates the netlist
            files.&nbsp; There are many different formats of netlist
            files, all containing roughly the same information.&nbsp;
            For our workflow, the specific format known in <b>KiCad</b>
            as ORCAD PCB 2 is required.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">3<br>
          </td>
          <td valign="middle">The netlists+schematics+initial conditions
            are translated into Verilog source code.</td>
          <td valign="middle"> <a moz-do-not-send="true"
              href="https://en.wikipedia.org/wiki/Verilog">Verilog</a>
            is a high-level
            hardware description language.&nbsp; The translation into
            Verilog source code is performed by <a
              moz-do-not-send="true"
              href="https://github.com/virtualagc/virtualagc/tree/schematics/Scripts">a
              Python 3 script called <b>dumbVerilog.py</b></a> that we
            provide.&nbsp; <br>
            <br>
            <b>Note:</b>&nbsp; The script <b>dumbVerilog.py</b> is
            specialized for AGC digital circuits ~1970, and will not
            produce anything useful when applied to non-AGC circuitry or
            to analog circuitry.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">4<br>
          </td>
          <td valign="middle">A "test bench" — i.e., a description in
            Verilog source code of the external
            inputs into the emulated circuitry vs time — is written.</td>
          <td valign="middle">There's a helpful Python 3 script, <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/dumbTestbench.py">dumbTestbench.py</a>,
            which can automate a little of this for you, but the script
            can't read your mind (yet!), so you still have to make some
            choices for yourself.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">5<br>
          </td>
          <td valign="middle">A model of the Erasable/Fixed Memory —
            i.e., the executable form of the AGC software that the
            emulated AGC circuitry is going to run — is converted into
            Verilog source code.</td>
          <td valign="middle"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/roms">This
              has already been done</a>, at least for an incomplete
            selection of the AGC software versions available to us.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">6<br>
          </td>
          <td valign="middle">The Verilog source code for the AGC
            circuitry, the test bench, and the
            erasable/fixed memory are compiled together into an
            executable
            form.</td>
          <td valign="middle">Our workflow specifically uses the <a
              moz-do-not-send="true"
              href="https://en.wikipedia.org/wiki/Icarus_Verilog">Icarus
              Verilog</a> (<b>iVerilog</b>) compiler for this.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">7<br>
          </td>
          <td valign="middle">The executable Verilog program is then run
            in an emulator. <br>
          </td>
          <td valign="middle">Our workflow uses the <b>iVerilog</b>
            emulator for this.&nbsp; Typically, this creates a "dump
            file" of
            whichever of the AGC's signals were considered to be
            interesting when the test bench was written.</td>
        </tr>
        <tr>
          <td valign="middle">8<br>
          </td>
          <td valign="middle">The output data dumped by the emulation is
            viewed as
            waveforms, similar to an oscilloscope, or else is
            post-processed in some other manner.</td>
          <td valign="middle">Our workflow uses a program called <a
              moz-do-not-send="true"
              href="https://gtkwave.sourceforge.net/"><b>GTKWave</b></a>
            for this visualization of the results.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Regarding the choice
        of software used in the workflow&nbsp;</font><font size="-1"><font
          size="-1">— i.e., the holy trinity <b>KiCad</b>, <b>iVerilog</b>,
          and <b>GTKWave</b> </font>—, disagreement as to whether
        these are the optimal choices is always possible, and indeed
        likely if you happen to be a person with expertise in this
        particular area.&nbsp; The programs were chosen because they are
        free of charge (and indeed are open source, like the Virtual AGC
        Project itself) and available for Linux, Windows, and Mac
        OS.&nbsp; If you can make it work with the fancier tools a
        professional may have at their disposal, then by all means do so
        and let me know.&nbsp; I won't change an open-source workflow
        into a non-open-source workflow no matter how terrific an
        alternate tool may be, but at least I'll be interested to hear
        the news and can parrot it back to the general public!<br>
      </font></blockquote>
    <p>Multiple types of simulation are possible, including:<br>
    </p>
    <ul>
      <li>Full AGC + DSKY</li>
      <li>Full AGC</li>
      <li>Individual AGC "module" (A1 - A24)</li>
      <li>Individual circuit board within an AGC module<br>
      </li>
    </ul>
    <p>Indeed, if you are capable of writing your own Verilog
      descriptions of <i>Other</i> peripheral hardware in the LM or CM,
      you can
      probably even simulate AGC+DSKY+<i>Other</i>.&nbsp; What we'll
      concentrate on discussing, however, is the full AGC.&nbsp;
      Hopefully, with that background, you'll be able to see for
      yourself how to create and run some other granularity of the
      simulation.<br>
    </p>
    <p>One slight point of confusion is that in the AGC design, the
      various plug-in circuits are called "modules", while Verilog also
      uses the term "modules" for its constructs that are similar to
      "functions" or "subroutines" in other programming languages.&nbsp;
      Now as it happens, we've implemented the simulation in such a way
      that each AGC module <i>actually is</i> modeled as a single
      Verilog module.&nbsp; That's more-or-less a coincidence, though,
      and if you attempt to work with any simulations that differ from
      those we've pre-prepared for you, you may have to watch out for
      the dual meaning of this term.<br>
    </p>
    <ul>
    </ul>
    <h1><a name="References"></a>References</h1>
    <p><a href="ElectroMechanical.html">The Virtual AGC Project's
        Electro-Mechanical page</a>.<br>
    </p>
    <p>Apollo-era AGC/DSKY electrical-schematic diagrams:<br>
    </p>
    <ul>
      <li>Block I AGC/DSKY schematic diagrams redrawn in AC Electronics
        Manual ND-1021041, with theory of operation: <a
          href="https://archive.org/details/apollocommandmodacel">Volume
          1</a> and <a
          href="https://archive.org/details/apollocommandmodacel_0">Volume
          2</a>.<br>
      </li>
      <li><a href="klabs/history/agc_schematics_block2/">Scans of the
          original electrical-schematic drawings for Block II AGC p/n
          2003993.</a> <br>
      </li>
      <li><a href="https://archive.org/details/agc_handbook_jp2">Scans
          of the original electrical-schematic drawings for Block II AGC
          p/n 2003100 &amp; 2003200, and associated DSKYs.</a>&nbsp; <br>
      </li>
      <li>Block II AGC/DSKY schematic diagrams redrawn in AC Electronics
        Manual ND-1021042, with theory of operation: <a
          href="Documents/acelectroniclmma00acel_0.pdf">Volume 2</a>.<br>
      </li>
      <li><a
          href="ElectroMechanical.html#Appendix:_Index_and_Links_to_all_AGC_">Drawing-by-drawing
index
          into the items above.</a></li>
    </ul>
    AGC/DSKY electrical schematics transcribed into KiCad
    electrical-design software, plus Verilog translations:<br>
    <ul>
      <li><a
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">GitHub
          repository</a></li>
    </ul>
    <p>Open-source software:<br>
    </p>
    <ul>
      <li><a href="http://kicad-pcb.org/">KiCad (Electrical
          schematic-capture CAD)</a></li>
      <li><a
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/dumbVerilog.py">KiCad-to-Verilog
translator
          script</a></li>
      <li><a href="http://iverilog.icarus.com/">Icarus Verilog (Verilog
          compiler and simulator)</a></li>
      <li><a href="http://gtkwave.sourceforge.net/">GTKWave (viewer for
          waveforms output by Icarus Verilog)</a></li>
    </ul>
    <p>Mike Stewart's similar transcription + simulation effort:<br>
    </p>
    <ul>
      <li><a href="https://github.com/virtualagc/agc_hardware/">KiCad
          schematics</a></li>
      <li><a href="https://github.com/virtualagc/agc_simulation/">Verilog
          translations</a></li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; It should be noted that the
          AGC simulations described on
          this page were <i>not</i> based on Mike Stewart's
          pre-existing
          project, other than in spirit.&nbsp; Mike's simulation was a
          very important resource in the
          sense that cross comparisons of the results output by Mike's
          implementation with those output by mine provided a way to
          detect errors in both implementations
          that would not have been easily discoverable otherwise.&nbsp;
          And I can honestly tell you that it would never even have
          occurred to me to try this if Mike hadn't already done what he
          did!&nbsp; It's very much a case of "me too!" on my part.
          &nbsp; With that said, there are some pros and cons that work
          in both directions.&nbsp; My schematics closely match the
          original AGC schematics, so closely that you can overlay them,
          while Mike's schematics are intended to be — and I believe,
          are! — <i>functionally</i> identical to the original
          schematics, but impossible to verify vs the original
          schematics without considerable intellectual effort.&nbsp;
          Mike's version is more efficient in the sense that his
          simulation runs significantly faster than mine ... but you
          can't compare his side-by-side with the original schematics to
          verify correctness as you can with mine.&nbsp; Which approach
          you prefer is a matter of taste.&nbsp; What I'll be discussing
          <i>here</i> is my own approach rather than Mike's.</font><br>
      </p>
    </blockquote>
    <ul>
    </ul>
    <h1><a name="WorkstationSetup"></a>Workstation Setup</h1>
    <p>Install the following software on your computer:<br>
    </p>
    <ul>
      <li><a moz-do-not-send="true" href="https://www.kicad.org/">KiCad
          EDA</a><br>
      </li>
      <li><a moz-do-not-send="true"
          href="https://steveicarus.github.io/iverilog/">Icarus Verilog</a><br>
      </li>
      <li><a moz-do-not-send="true"
          href="https://gtkwave.github.io/gtkwave/">GTKWave</a></li>
    </ul>
    <p>On Ubuntu or Linux Mint, this is as simple as using the command<br>
    </p>
    <blockquote>
      <pre>sudo apt install kicad iverilog gtkwave<br></pre>
    </blockquote>
    <p>On other platforms, installation may or may not be something as
      simple, but you should follow the hyperlinks given above to find
      out.<br>
    </p>
    <p>Download <a moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/schematics">the
        "schematics" branch of the Virtual AGC repository</a> from
      GitHub.&nbsp; There are many different ways you might do this,
      depending on your computer platform and personal tastes, and I
      wouldn't presume to dictate to you.&nbsp; For the sake of
      discussion, however, I'll assume that you've done this by creating
      a folder called "virtualagc-schematics" in your "home
      directory".&nbsp; For example, if you have the git program
      installed on your computer, you could do it with a command like:<br>
    </p>
    <blockquote>
      <pre>git clone --depth=1 -b schematics https://github.com/virtualagc/virtualagc.git virtualagc-schematics<br></pre>
    </blockquote>
    <p>Within the folder you've just created you'll find a folder called
      "Scripts".&nbsp; Add the path to this Scripts folder into your
      PATH environment variable.&nbsp; Depending on your particular
      computer platform, the way of doing that varies.&nbsp; But the
      following should usually work:<br>
    </p>
    <ul>
      <li>Linux: Add the line "<code>export PATH=$PATH:</code><code><i>PathToYourNewFolder</i></code>"
        to the file ~/.bashrc using a text editor.</li>
      <li>Mac OS: Add the line "<code>export PATH=$PATH:</code><code><i>PathToYourNewFolder</i></code>"
        to <i>both</i> of the files ~/.bashrc and ~/.zprofile using a
        text editor.</li>
      <li>Windows:&nbsp; I'd suggest opening up the desktop menu and
        searching for "edit environment variables".&nbsp; Edit the
        "Path" variable for your account and add <code><i>PathToYourNewFolder</i></code>
        to it.</li>
    </ul>
    <p>It's likely the changes the PATH won't affect any existing
      command lines which are open, so you'll probably have to open a
      new command-line terminal to get the benefit of the change.<br>
    </p>
    <h1><a name="An_Example:_testVerilog"></a>First Example: Simulating
      a Small Digital Circuit<br>
    </h1>
    <p>The Virtual AGC software repository already contains some
      fully-worked out examples of digital simulations. The simplest
      example is
      something called "<a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/testVerilog">testVerilog</a>",
      which is actually a small circuit
      block extracted from the AGC's circuit module A1, the "scaler"
      module.&nbsp; In this section we'll cover the testVerilog
      simulation workflow.<br>
    </p>
    <p>Workflow Step #1:&nbsp; Start with the original Apollo Program
      schematic-diagram drawing for module A1, which is drawing
      2005259A, two sheets (click to enlarge):<br>
    </p>
    <div align="center"><a
        href="klabs/history/agc_schematics_block2/logic/a01-1.jpg"><img
          src="a01-1-small.jpg" alt="" border="2" height="241"
          width="300"></a>&nbsp; <a
        href="klabs/history/agc_schematics_block2/logic/a01-2.jpg"><img
          src="a01-2-small.jpg" alt="" border="2" height="239"
          width="300"></a><br>
    </div>
    <p>Don't be confused by the fact that the inputs of NOR gates in the
      circuit are decorated with little triangles that make the gates
      look like rocket ships.&nbsp; (Was it intentional, I
      wonder?)&nbsp; They're just regular NOR gates in
      spite of that.&nbsp; The numbered oval pads are the inputs from or
      outputs to the AGC backplane into which the various AGC circuitry
      modules plug.&nbsp; Perhaps I should also point out that the NOR
      gates used in the AGC were open-drain gates, in which you can
      directly tie together outputs from different gates (effectively
      AND'ing them without any literal AND gate).&nbsp;&nbsp; <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; I won't cover here how to
          actually transcribe paper drawings of electrical schematics
          into KiCad schematic files.&nbsp; It's a complicated
          affair.&nbsp; Just any old transcription won't do.&nbsp; And
          honestly, you may not have to understand how to make
          transcriptions anyway, since I've already transcribed all of
          the pre-existing AGC schematics for you.&nbsp; Nevertheless,
          in the Appendix there's <a moz-do-not-send="true"
            href="#Converting_Netlist_to_Verilog">a list of some of the
            rules</a> you'd have to follow to get schematic files that
          are usable for our simulation workflow.&nbsp; There are also
          common-sense rules that aren't covered in the Appendix, such
          as "you have to use wires for electrical interconnections
          rather than just lines".&nbsp; One rule not in the Appendix
          that I've personally followed in order to make verification of
          correctness of the transcriptions much simpler is that the
          transcribed schematics should appear to be so visually
          identical to the originals that you can overlay them with
          nothing perceptibly out of place.&nbsp; There's no technical
          necessity for that particular rule.&nbsp; Mike Stewart's
          transcriptions, for example, are designed entirely for
          functional correctness and have no visual resemblance whatever
          to the originals.&nbsp; On the other hand, Mike's
          transcriptions don't follow the rules laid out in the Appendix
          either, so certain steps in our simulation workflow (which
          post-date Mike's transcriptions) will fail.&nbsp; In case
          you're wondering how to transcribe a circuit so as to make it
          visually identical to the original, KiCad's schematic capture
          program, <b>eeschema</b>, allows you to use a JPG image as
          the backdrop of your schematic.&nbsp; Thus if you use the
          scanned images (as seen above) for your backdrops in <b>eeschema</b>,
          you can almost-trivially insure that all of your components
          and wires are in exactly the right places, which also helps to
          insure that the nets in the transcription are as they should
          be. </font><br>
      </p>
    </blockquote>
    <p>Transcriptions which follow the rules in the Appendix (and my
      additional criteria) look like this: <br>
    </p>
    <div align="center"><a href="KiCad/2005259A-p1of2.png"><img
          src="2005259A-p1of2-small.png" alt="" border="2" height="232"
          width="300">&nbsp; </a><a href="KiCad/2005259A-p2of2.png"><img
          src="2005259A-p2of2-small.png" alt="" border="2" height="232"
          width="300"></a><br>
    </div>
    <p>Now as I mentioned, AGC module A1 is the "scaler" circuit.&nbsp;
      If you want to
      read about it in some detail, you can look at <a
href="https://archive.org/stream/acelectroniclmma00acel#page/n290/mode/1up">section
4-5.3.4
        of document ND-1021042</a>, which covers the theory of
      operation of this module.&nbsp; The module's purpose is to take
      clock signal called FS01/ (a 102.4 KHz square wave), which you can
      see coming into the module from the AGC's backplane near the upper
      left on the first sheet of the schematic, and to run it through a
      sequence of identical circuit blocks that successively cut the
      frequency of
      that signal in half, as follows, and outputting those slower
      clocks back to the AGC's backplane:<br>
    </p>
    <ul>
      <li>Output signal FS02 is 51.2 KHz</li>
      <li> Output signal FS03 is 25.6 KHz</li>
      <li>...</li>
      <li>Output signal FS33 is 0.000023842 Hz</li>
    </ul>
    <p>To simplify things, the testVerilog example cuts this all down so
      that just the <i>first</i> of the many divide-by-two circuit
      blocks.&nbsp; The abridged circuit produces
      the output signal FS02 from input signal FS01/ and implements
      what's known to electrical engineers as a "flip-flop". &nbsp; Here
      is an
      image of that circuit:<br>
    </p>
    <div align="center"><img src="testVerilogCircuit.png" alt=""
        height="549" width="643"><br>
    </div>
    <p>Workflow Step 2:&nbsp; <a moz-do-not-send="true"
        href="#CreatingNetlists">Consult the Appendix</a> for an
      explanation of how to create the netlist.&nbsp; While it isn't
      terribly instructive in itself, the netlist file for this circuit
      is
      relatively short and relatively readable without any explanation,
      so here it is in full:<br>
    </p>
    <blockquote>
      <p>
        <meta http-equiv="content-type" content="text/html;
          charset=UTF-8">
      </p>
      <pre style="color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; white-space: pre-wrap;"><font color="#663300" face="Courier">( { EESchema Netlist Version 1.1 created  Wed 26 Sep 2018 08:21:48 AM CDT }
( /5D281B38 $noname  J2 ConnectorA1-200
(  202 Net-(J2-Pad202) )
(  204 Net-(J2-Pad204) )
(  205 Net-(J2-Pad205) )
(  206 Net-(J2-Pad206) )
(  208 Net-(J2-Pad208) )
(  209 Net-(J2-Pad209) )
(  212 0VDCA )
(  222 +4VDC )
(  236 0VDCA )
(  250 +4VDC )
(  260 0VDCA )
)
( /5D281B3E $noname  U126 D3NOR-+4VDC-0VDCA-A_B-E_F
(    6 0VDCA )
(    7 Net-(U126-Pad7) )
(    8 Net-(J2-Pad206) )
(    9 Net-(J2-Pad208) )
)
( /5D281B45 $noname  U128 D3NOR-+4VDC-0VDCA-ABC-E_F
(    1 Net-(U127-Pad2) )
(    2 Net-(U127-Pad8) )
(    3 Net-(J2-Pad205) )
(    4 Net-(J2-Pad209) )
(    5 0VDCA )
(    6 0VDCA )
(    7 Net-(U126-Pad7) )
(    8 Net-(U127-Pad2) )
(    9 Net-(J2-Pad209) )
(   10 +4VDC )
)
( /5D281B77 $noname  U127 D3NOR-+4VDC-0VDCA-B_C-E_F
(    1 Net-(U126-Pad7) )
(    2 Net-(U127-Pad2) )
(    3 Net-(J2-Pad204) )
(    4 0VDCA )
(    5 0VDCA )
(    6 0VDCA )
(    7 Net-(U126-Pad7) )
(    8 Net-(U127-Pad8) )
(    9 Net-(J2-Pad204) )
(   10 +4VDC )
)
( /5D281B9B $noname  U129 D3NOR-+4VDC-0VDCA-ABC-E_F
(    1 Net-(U127-Pad8) )
(    2 Net-(J2-Pad202) )
(    3 Net-(J2-Pad205) )
(    4 Net-(U127-Pad2) )
(    5 0VDCA )
(    6 0VDCA )
(    7 Net-(U127-Pad8) )
(    8 Net-(J2-Pad204) )
(    9 Net-(J2-Pad202) )
(   10 +4VDC )
)
)
*</font><br></pre>
    </blockquote>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
        I hinted earlier that some of the tools in the workflow have
        evolved since this section was written.&nbsp; The principal
        offender in this regard is the KiCad EDA program, which has
        moved from v.5 when the netlist file above was created, to v.8
        now, with major changes having occurred in the transition from
        v.5 to v.6.&nbsp; The moral is that if you creat the same
        netlist <i>today</i>, it will look very different than what you
        see above, though it will be functionally identical.</font><br>
    </blockquote>
    Workflow Step #3: Conversion to Verilog.&nbsp; <br>
    <br>
    The Verilog source code is created by the command:<br>
    <blockquote><font face="Courier 10 Pitch">dumbVerilog.py A1 <font
          face="Courier 10 Pitch">module</font>.net pins.txt 0.2 <font
          face="Courier 10 Pitch">module.init</font> module.kicad_sch
        &gt;<font face="Courier 10 Pitch">module</font>.v</font><br>
    </blockquote>
    The command-line parameters are the AGC logic module designation
    (A1, since testVerilog was snipped out of module A1), the name of
    the netlist file (module.net), <a moz-do-not-send="true"
      href="#PinsTxt">a file describing backplane connections</a>
    (pins.txt), the propagation delay of NOR gates ("0.2" meaning "20
    ns"), <a moz-do-not-send="true"
      href="#Generating_Flip-flop_Initialization">the initial states of
      flip-flops</a> (module.init), and the name of the top-level
    schematic file (module.kicad_sch for KiCad v.6 or later, module.sch
    for KiCad v.5 or earlier).&nbsp; For the purpose of this particular
    simulation, the module.init file looks like,<br>
    <blockquote>
      <pre>U127 1 0<br>U129 1 0<br></pre>
    </blockquote>
    <br>
    <br>
    <br>
    The Verilog source code you get looks somewhat similar to the
    following.&nbsp; (It's only "somewhat similar" because this is
    another case of tools that have evolved since I first wrote this
    section.)&nbsp; Even if you don't know Verilog, I think you can get
    a good sense of what's what.&nbsp; The <font color="#663300"><code>rst</code></font>
    signal is not present in the schematic, and is simply always added
    by the program we use to synthesize the Verilog source code; it's
    what allows the initial conditions of memory — in this case, the
    flip-flop — to be set up, but is normally active only at the very
    beginning of the simulation.&nbsp; Verilog doesn't allow signal
    names like "FS01/", because the character "/" isn't legal for signal
    names, so the translator has automatically changed "FS01/" to
    "FS01_".<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <pre style="font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; overflow-wrap: break-word; white-space: pre-wrap;"><font color="#663300" face="Courier">// Verilog module auto-generated for AGC module A1 by dumbVerilog.py
module A1 (
rst, FS01_, F02A, F02B, FS02, FS02A
);
input wire rst, FS01_;
output wire F02A, F02B, FS02, FS02A;
assign FS02A = rst ? 0 : ~(0|U126Pad7);
assign FS02 = rst ? 0 : ~(0|U126Pad7|U127Pad8);
assign U127Pad8 = rst ? 1 : ~(0|F02B|FS01_|U127Pad2);
assign U126Pad7 = rst ? 1 : ~(0|U127Pad2|FS02);
assign U127Pad2 = rst ? 0 : ~(0|U127Pad8|FS01_|F02A);
assign F02A = rst ? 0 : ~(0|U126Pad7|U127Pad2);
assign F02B = rst ? 0 : ~(0|U127Pad8|FS02);
endmodule</font></pre>
    </blockquote>
    Workflow Step #4: Creation of a test bench.&nbsp; This is the point
    in a simulation workflow where you would have to decide how you want
    the input signals supplied to the circuit to vary over time, as well
    as which output signals from the circuit you want to log for later
    viewing or analysis.&nbsp; Those decisions together comprise what's
    called the "test bench".&nbsp; The test bench is yet another Verilog
    source-code file.&nbsp; But you have to write it or tweak it
    yourself, at least partially, rather than expecting it to be created
    automatically for you.&nbsp; The test-bench file I've created for
    testVerilog looks like this:<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <pre style="font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; overflow-wrap: break-word; white-space: pre-wrap;"><font color="#663300" face="Courier">// Test bench for testVerilog.v
`timescale 1us / 1ns
module testVerilog;
reg rst = 1;
initial begin
$dumpfile("testVerilog.vcd");
$dumpvars(0, testVerilog);
# 2 rst = 0;
# 500 $finish;
end
reg FS01_ = 0;
always #4.883 FS01_ = !FS01_;
wire F02A, F02B, FS02, FS02A;
A1 A1A (
rst, FS01_, F02A, F02B, FS02, FS02A
);
initial
$timeformat(-6, 0, " us", 10);
initial
$monitor("At time %t, rst=%d, FS01_=%d, F02B=%d, FS02=%d, FS02A=%d, FS02A=%d", $time, rst, FS01_, F02B, FS02, F02A, FS02A);
endmodule</font></pre>
    </blockquote>
    Let's take a look at this test-bench source-code file and see what
    it's trying to say.&nbsp; First, the "timescale" directive explains
    how to understand the timings (the things marked with "#") that
    appear within the test-bench file.&nbsp; It says that the time scale
    will be 1 μs, so that the numbers for the "#" timings are in
    microseconds.&nbsp; <br>
    <br>
    The "reg rst =1" means that the <font color="#663300"><code>rst</code></font>
    signal is going to be an input signal into the circuit we're
    testing, but here within the test bench it's going to be a
    "register" that remembers it's own settings, as opposed to a "wire"
    (which cannot remember anything).&nbsp; Thus, we set <font
      color="#663300"><code>rst</code></font> to 1 and it will stay that
    way until we say otherwise.&nbsp; A few lines later we see "# 2 rst
    = 0", which means that 2 us after startup, the test bench is going
    to reset the <font color="#663300"><code>rst</code></font> signal
    to 0, and leave it there.&nbsp; The "# 500 $finish" that you also
    see there says that the simulation itself will actually end after
    500 μs.&nbsp; The "$dumpfile" and "$dumpvars" statements say that an
    output logfile called testVerilog.vcd is going to be opened, and
    that the values of all of the input and output variables are going
    to be dumped into it on a cycle-by-cycle basis, for later analysis.<br>
    <br>
    The "reg FS01_ = 0" means that <font color="#663300"><code>FS01_</code></font>
    (FS01/) is also an input to the circuit being tested, and that it
    starts out at 0.&nbsp; But "always #4.883 FS01_ = !FS01_" means that
    <font color="#663300"><code>FS01_</code></font> is going to be
    toggled every 4.883 us during the simulation.&nbsp; Recall that
    FS01/ is a 102.4 KHz square wave in the AGC, and therefore it
    toggles from low-to-high or high-to-low at a rate of 204.8 KHz, or
    (surprise!) every 4.8828125 us.<br>
    <br>
    The statements "wire F02A, ..." and "A1 A1A ( ... )" simply mean
    that a circuit module of type A1 (which is what the Verilog shown in
    step #3 above implements) is being tested, and has outputs named <font
      color="#663300"><code>F02A</code></font> etc.<br>
    <br>
    Finally, the "initial" statements at the very end describe the
    status messages which the simulation is going to print out whilst
    running.&nbsp; These messages are just informative, and have nothing
    to do with the data being dumped out on the testVerilog.vcd.&nbsp;
    You don't even need to print out any status messages if you don't
    want to.<br>
    <br>
    Workflow Step #5:&nbsp; Modeling memory.&nbsp; Since we're just
    simulating a single logic module of the AGC, rather than the AGC as
    a whole, we don't need any memory other than the flip-flop that the
    circuit implements, so&nbsp; we don't need this step.<br>
    <br>
    Workflow Step #6:&nbsp; Compiling the Verilog source-code
    files.&nbsp; There's really nothing to show you; it's dead simple.<br>
    <br>
    Workflow Step #7:&nbsp; Running the simulation.&nbsp; After
    compilation, when you run the simulation, you see something like
    this:<br>
    <blockquote><font size="-1" face="Courier"><font color="#663300">VCD
          info: dumpfile testVerilog.vcd opened for output.<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 us, rst=1,
          FS01_=0, F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 us, rst=0,
          FS01_=0, F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 us, rst=0,
          FS01_=1, F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 49 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 54 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 59 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 68 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 73 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 78 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 83 us, rst=0, FS01_=1,
          F02B=1, FS02=0, FS02A=0, FS02A=0<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 88 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 93 us, rst=0, FS01_=1,
          F02B=0, FS02=1, FS02A=1, FS02A=1<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 98 us, rst=0, FS01_=0,
          F02B=0, FS02=0, FS02A=0, FS02A=0<br>
          ...<br>
          At time&nbsp;&nbsp;&nbsp;&nbsp; 498 us, rst=0, FS01_=0,
          F02B=0, FS02=1, FS02A=0, FS02A=1</font><br>
      </font></blockquote>
    Thus as promised, <font color="#663300"><code>FS01_</code></font>
    (FS01/) toggles about very 5 microseconds, while <font
      color="#663300"><code>FS02</code></font> toggles about every 10
    microseconds.<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    </blockquote>
    Workflow Step #8: Visualization.&nbsp; When the dump-file created by
    running the simulation, namely testVerilog.vcd, is pulled into the <b>GTKWave</b>
    visualization program, you see something like the following.&nbsp;
    The picture doesn't seem to require any explanation, though it's fun
    to compare it to <a
href="https://archive.org/stream/acelectroniclmma00acel#page/n296/mode/1up">the
      corresponding picture on p. 4-222A of document ND-1021042</a>,
    which I'll leave as an exercise for the reader.<br>
    <br>
    <div align="center"><img src="testVerilog.Wave.png" alt=""
        height="499" width="1030"><br>
    </div>
    <br>
    <h1><a name="EntireAGC"></a>Big Example: Simulating an Entire AGC</h1>
    <h2><a name="SomeBackground"></a>Some Background Information</h2>
    <p>As with the discussion of the simulation of the simple
      "testVerilog" circuit in the preceding section, we'll be
      concentrating on what the various steps of the simulation workflow
      produce rather than on the detailed commands needed to accomplish
      those steps.&nbsp; Coverage of those detail commands is again
      relegated to <a moz-do-not-send="true"
        href="#Appendix:_Translation_from_KiCad_into">the Appendix</a>.<br>
    </p>
    <p>Simulating an entire AGC is similar to simulating just a small
      portion of an AGC as in the example of "testVerilog" that we saw
      above.&nbsp; There are some differences, though.&nbsp; For one
      thing, we can't work with just one huge electrical schematic that
      covers the entire AGC, as we could with testVerilog.&nbsp; Well,
      we <i>could</i>, except that we don't have such a monstrous
      drawing to work with.&nbsp; Rather, we have lots of drawings of
      electrical schematics for the individual logic modules comprising
      the AGC.&nbsp; We have to cobble the simulation together using the
      various bits and pieces we can get from schematics, netlists, and
      Verilog source-code files created individually for the separate
      "logic modules" of the AGC.&nbsp; But doing that would only get us
      the AGC's CPU, and a CPU needs a program to run.&nbsp; So we also
      need Verilog source-code files that model whatever particular AGC
      program — such as LUMINARY, COLOSSUS, or whatever — that we want
      to run.&nbsp; So on choice we have to make is which AGC software
      are we going to use?<br>
    </p>
    <p>Another choice we have to make in principle is <i>which model</i>
      of AGC do we want to simulate?&nbsp; Some of the choices are:<br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="top">Generic AGC Model<br>
          </th>
          <th valign="top">Block<br>
          </th>
          <th valign="top">Mission<br>
          </th>
          <th valign="top">Spacecraft<br>
          </th>
          <th valign="top">Specific Dash Number<br>
          </th>
        </tr>
        <tr>
          <td valign="middle">1003565<br>
          </td>
          <td valign="middle">I<br>
          </td>
          <td valign="top">AS-202<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003565-011<br>
          </td>
        </tr>
        <tr>
          <td rowspan="2" colspan="1" valign="middle">1003700<br>
          </td>
          <td rowspan="2" colspan="1" valign="middle">I<br>
          </td>
          <td valign="top">Apollo 4<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003700-051<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Apollo 6<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">1003700-071<br>
          </td>
        </tr>
        <tr>
          <td valign="middle">2003100</td>
          <td valign="middle">II<br>
          </td>
          <td valign="top">2TV-1<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">2003100-061<br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top">II<br>
          </td>
          <td valign="top">LTA-8<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003100-071<br>
          </td>
        </tr>
        <tr>
          <td rowspan="2" colspan="1" valign="middle">2003200<br>
          </td>
          <td rowspan="2" colspan="1" valign="middle">II<br>
          </td>
          <td valign="top">(None)<br>
          </td>
          <td valign="top">CM<br>
          </td>
          <td valign="top">2003200-031<br>
          </td>
        </tr>
        <tr>
          <td valign="top">(None)<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003200-041<br>
          </td>
        </tr>
        <tr>
          <td rowspan="3" colspan="1" valign="middle">2003993<br>
          </td>
          <td rowspan="3" colspan="1" valign="middle">II<br>
          </td>
          <td valign="top">Apollo 5<br>
          </td>
          <td valign="top">LM<br>
          </td>
          <td valign="top">2003993-011<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Apollo 7</td>
          <td valign="top">CM</td>
          <td valign="top">2003993-031</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="3" valign="top"><i>etc.</i><br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>Model 2003993, in differing specific dash numbers, was used for
      almost all missions, so I hope you'll forgive me for running out
      of steam at the end of the table and just covering all of the
      remaining missions with a bland "<i>etc.</i>" rather than giving
      you 20 more rows of model 2003993!&nbsp; The way to get the
      information for the missing entries is by drilling down into <a
        moz-do-not-send="true"
        href="ElectroMechanical.html#Navigate_the_Assembly_Hierarchy_">the
        GN&amp;C mission hierarchy table</a>.&nbsp; That is also the
      place to go in order to match a particular AGC model to a specific
      set of electrical schematics.<br>
    </p>
    <p>The good news is that in so far as the digital logic is
      concerned, there is very little difference between the different
      Block II AGC models.&nbsp; Mike Stewart, who is far more
      knowledgeable about this topic than I am, explains it thusly (as
      slightly edited by me):<br>
    </p>
    <blockquote>
      <div>
        <meta http-equiv="content-type" content="text/html;
          charset=UTF-8">
        "It doesn't actually matter that much, because there were very
        nearly&nbsp;no <i>logic</i> changes between 2003200 and
        2003993. Probably the best [or possibly only difference] is the
        signal MAMU as an input to module A14 (on sheet 1). That
        backplane wire was introduced with 2003993-011 and was not
        present on any 2003200 computers. Most of the other changes
        between the two models were in the B tray or power supply, which
        [isn't being simulated] with the Verilog sim."</div>
    </blockquote>
    <p>With that said, the full-AGC example we'll be working through
      below is for the model 2003200, which never flew in any mission
      though it was in fact installed in LM-2.&nbsp; Why I made the
      oddball choise of this particular model for the example, rather
      than the far-more-common 2003993, is a mystery.<br>
    </p>
    <h2><a name="Steps_1_2_and_3:_Creating_Verilog"></a>Workflow Steps
      1, 2, and 3: Creating Verilog Source-Code Files Corresponding To
      the AGC Schematics</h2>
    There's really nothing to see here, so let's move on.<br>
    <h2><a name="Step_4:_The_Test_BenchTBD"></a>Workflow Step 4: The
      Test Bench, and Initial States and Gate Delays<br>
    </h2>
    <h3><a name="module.init"></a>module.init</h3>
    <p><img src="testVerilogCircuit.png" alt="" height="372"
        align="left" width="438">The AGC's logic module circuits,
      modules A1-A24, mostly consist of so-called "combinational" logic,
      in which a unique set of inputs determines a unique set of outputs
      at any specific moment of time.&nbsp; However, some of the NOR
      gates, such as those in the figure to the left (which is from <a
        href="#An_Example:_testVerilog">the testVerilog example</a>
      given earlier), contain feedback in which the inputs to a NOR gate
      may depend indirectly on its output.&nbsp; The net result is for
      those portions of the circuit to have a kind of "memory", in which
      the current output depends not just on the inputs at this precise
      moment in time, but also on the inputs at earlier times as well.<br>
    </p>
    <p>When confronted with a situation like this, the Verilog simulator
      software may not be able to initially figure out what the outputs
      of the circuit are, because those depend on times before the
      simulation started, about which the simulator software has no
      information. In <i>real</i> life, such as in the real physical
      AGC units, those circuits will settle very quickly into <i>some</i>
      stable state.&nbsp; But in simulation that may not be the case,
      and the circuit may oscillate endlessly.&nbsp; So we have to have
      some way to initially get the system into some stable state in
      which all of the feedback signals have some nice, consistent
      values. <br>
    </p>
    <p><img alt="" src="dualNOR.png" height="216" align="right"
        width="224">The way that is done is with module.init
      files.&nbsp; Each schematic drawing needs to have one of
      these.&nbsp; A module.init file can provide settings for any or
      all of the NOR gates, driving their outputs to a desired state
      when a signal ("rst") is initially applied to the circuit.<br>
    </p>
    <p>Before describing the format of the module.init files, though, we
      need to agree on some basic facts about the NOR gates used in the
      AGC circuits.&nbsp; The NOR gates are packaged into 10-pin
      integrated circuits, each of which contains two independent NOR
      gates, as in the figure to the right.&nbsp; One of the NOR-gates
      outputs to the chip's pin 1 (called "J") on the schematics, while
      the other NOR-gate outputs to pin 9 (or "K").<br>
    </p>
    <p>The other thing to notice is that, as in the figure to the left,
      the dual NOR-gates are identified in the Verilog design by
      reference designators like U1<i>nn</i>, U2<i>nn</i>, or U3<i>nn</i>,
      where <i>nn</i> is a 2-digit number written on the NOR-gate's
      schematic symbol.&nbsp; In the figure at left, for example, we
      have both NOR gates from U127, both NOR gates from U128, both NOR
      gates from U129, and one of the two NOR gates from U126.&nbsp; How
      did I know that we had U127 rather than U227?&nbsp; Well, usually
      U1<i>nn</i> is on the first sheet of the schematic and U2<i>nn</i>
      is on the second sheet.&nbsp; However, to know for sure, you
      really need to read the textual notes provided within the
      schematic.<br>
    </p>
    <p>With those understandings in mind, here's a portion of a
      module.init file for your consideration.&nbsp; (It does <i>not</i>
      belong to the example figure above.)<br>
    </p>
    <blockquote>
      <p><font face="Courier 10 Pitch"># For module A2<br>
          U151 1 0 0.<font face="Courier 10 Pitch">2</font><br>
          U152 0 0 0.<font face="Courier 10 Pitch">2</font><br>
          U153 0 0 0.<font face="Courier 10 Pitch">2</font><br>
          U155 1 0 0.<font face="Courier 10 Pitch">2</font><br>
          U156 0 0 0.<font face="Courier 10 Pitch">2</font><br>
          U157 1 0 0.<font face="Courier 10 Pitch">2</font><br>
          <br>
          U308 0 0<br>
          U309 0 0<br>
          U228 1 0<br>
          ...</font><br>
      </p>
    </blockquote>
    <p>You can decorate the module.init file with comments (preceded by
      "#") or blank lines, if it helps you document what's being
      done.&nbsp; More importantly, the file can be edited in a
      text-editor and consists of lines of the form<br>
    </p>
    <blockquote>
      <p>U<i>nnn</i> [ <i>JVALUE</i> [ <i>KVALUE</i> [ <i>JDELAY</i>
        [ <i>KDELAY</i> ]]]<br>
      </p>
    </blockquote>
    <p>by which I mean that the lines consist of the chip's reference
      designator, follow by 0 to 4 numerical values. <i>JVALUE</i> and
      <i>KVALUE</i> are simply the values of the NOR gates' outputs at
      reset, and always have the settings 0 or 1.&nbsp; 0 is the
      default, meaning that the output of the NOR is LOW.<br>
    </p>
    <p>How does one determine what values <i>JVALUE</i> and <i>KVALUE</i>
      should be given?&nbsp; What you are looking for, minimally, is
      that all of the outputs from the NOR gates should be consistent
      with their inputs.&nbsp; You know that that's possible, since the
      original AGCs didn't simply oscillate out of control,&nbsp; But
      how?&nbsp; <br>
    </p>
    <p>One way is to use a handy script we've provided,
      Scripts/dumbInitialization.py, which I describe in more detail in
      <a href="#Appendix:_Translation_from_KiCad_into">the Appendix</a>.&nbsp;
      This was the method used to create the module.init files presently
      in the repository.&nbsp; But if the initializations created this
      way don't satisfy you, you can edit them according to your own
      liking, because they're just text files.&nbsp; It is certainly a
      drawback of dumbInitialization.py that the initializations aren't
      necessarily "natural", since the only guarantee is that they are
      mutually consistent rather than to have any other properties you
      might like.&nbsp; For example, module A1 is basically just a
      33-bit counter, and that counter is initialized to some "random"
      value by dumInitialization.py, whereas <i>you</i> might like it
      to be initialized to 0.&nbsp; I fear that's just a consequence of
      how the flip-flops were implemented in the AGC, as there's nothing
      (as far as I know) that guarantees how they're initialized.&nbsp;
      And sadly, I have nothing other than that smug platitude to offer
      you about creating your own custom initializations.<br>
    </p>
    <p>What are <i>JDELAY</i> and <i>KDELAY</i>?&nbsp; Well, they have
      to do with a completely different topic.&nbsp; The Verilog
      description of the design allows you to assign any gate delay you
      like to any of the NOR gates.&nbsp; Mostly it isn't critical, and
      the default we use is a delay of 0.&nbsp; But in some cases it <i>is</i>
      critical that it be non-zero, or even that it is confined within a
      narrow range of acceptable values.&nbsp; The units of time are
      defined by the "timescale" operative that appears near the top of
      many of the Verilog files.&nbsp; Usually this is 100 ns per
      simulator timer tick.&nbsp; Therefore, for example, a <i>JDELAY</i>
      or <i>KDELAY</i> of 0.1 would be 10 ns.<br>
    </p>
    <h3><a name="Testbench_files"></a>Testbench files</h3>
    <p>A "test bench" is a Verilog file that lets you define how to
      stimulate the inputs of the Verilog file(s) for an individual AGC
      module or combination of AGC modules, and therefore to produce
      outputs that you can either view immediately or log for later
      analysis/viewing.&nbsp; When you compile the Verilog file for the
      test bench along with the Verilog file(s) it is the test bench
      for, you get a file that can be used to simulate the design
      without further ado.<br>
    </p>
    <p>Unfortunately, I cannot tell you much about how to write Verilog
      test-bench files, since it's going to depend so much on the
      particular AGC p/n or AGC module or PCB you're trying to test, and
      what you're trying to test within it.&nbsp; You'll simply have to
      research these topics for yourself.<br>
    </p>
    <p>I will tell you that the software repository does have template
      testbench files (produced by the script dumbTestbench.py as
      described in the preceding section) that you can use as starting
      points, or else completely-working testbench files in a few cases,
      wherever it makes sense in the present state of development to do
      so:<br>
    </p>
    <ul>
      <li>Each AGC logic module (Schematics/<i>DRAWING</i>/tb.v)</li>
      <li>Each AGC unit (Schematics/tb_2003200.v, ...)</li>
    </ul>
    <h2><a name="Step_5:_Providing_ErasableFixed_Memory"></a>Workflow
      Step 5: Providing Erasable/Fixed Memory</h2>
    <p>Alas! there's one point in the simulation where we depart
      somewhat from absolute verisimilitude with respect to the original
      AGC circuitry, and that's in the simulation of the AGC's erasable
      memory (the "RAM") and fixed memory (the "ROM"). Because the AGC's
      memory was made from Permalloy-wire cores, surrounded by lots of
      analog circuitry to drive them and to sense their states, it
      becomes a bit tricky to simulate their behavior in essentially
      digital simulation tools like Icarus Verilog.&nbsp; <br>
    </p>
    <p>What's done in the simulation instead is to continue to use the
      digital signals that the AGC feeds into the analog circuitry
      driving the cores or extracts from the analog circuitry sensing
      the cores, but to replace the cores themselves and their
      surrounding analog circuitry with <a
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/fixed_erasable_memory">a
        fully digital model whose schematics and associated Verilog can
        be found in the github repository</a>.&nbsp; Specifically, the
      fixed memory ends up being <a
        href="http://ww1.microchip.com/downloads/en/DeviceDoc/25001A.pdf">modeled
        after a Microchip SST39VF200A flash-memory chip</a> (Verilog
      module ROM.v), not that the choice of this specific part has too
      much significance, as long as it has sufficient capacity.&nbsp; As
      far as the <i>contents</i> of the memory are concerned, it can be
      any of the AGC programs available to us in the Virtual AGC project
      — though not all of them have been pre-converted to Verilog as of
      yet —, such as Artemis 072, Aurora 12, Colossus 237, etc.&nbsp;
      It's only necessary to make sure that the particular Verilog file
      implementing the desired AGC program is present in <a
        moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics/roms">the
        Schematics/roms/ folder</a> at Verilog compile time, and is
      named "rom.v".<br>
    </p>
    <p>It is worth reiterating, though, that the simulation of the
      electronics runs <i>very slowly</i> relative to real time, and
      that there isn't presently any way to model an interactive DSKY in
      the simulation, so the choice of which AGC programs to use is
      really limited greatly by which of them are easy to use,
      pragmatically speaking.&nbsp; The AGC program called
      "Validation-hardware-simulation" is one such program: it has been
      modified to operate without DSKY input, and only require about 40
      seconds to run in real life.&nbsp; In the simulation, it requires
      much, much more time.<br>
    </p>
    <h2><a name="Step_5:_Compilation_of_the_Verilog"></a>Workflow Step
      6: Compilation of the Verilog</h2>
    If you are running Linux, or conceivably Mac OS X (I've never tested
    it there!), there is actually a Makefile (namely,
    Schematics/Makefile) for GNU 'make' which can do the following for
    you:<br>
    <ol>
      <li>Translate the AGC module netlists into Verilog files.</li>
      <li>Create empty module initialization files for them, if such
        files don't already exist.&nbsp; But you'll typically need to
        edit those files later.<br>
      </li>
      <li>Create testbench Verilog files for them, if such files don't
        already exist.&nbsp; But you'll typically need to edit those
        files later.</li>
      <li>Compile the Verilog for each AGC module along with its test
        bench to get a simulation file just for that module.</li>
      <li>Create a testbench Verilog file to the AGC unit as a whole
        (AGC model 2003200, with other models coming later).&nbsp; But
        you'll typically have to edit that file later.</li>
      <li>Compile the AGC unit testbench Verilog along with the Verilog
        for all of the modules that go into that AGC, to create a
        simulation file for the AGC as a whole</li>
    </ol>
    <p>But if you're running Windows or just want to know how to do the
      steps yourself, that doesn't really help you too much.&nbsp;
      (Unless somebody wants to fix up a Windows version of the Makefile
      for me? It shouldn't be too hard, but I don't want to mess with
      Windows myself, so it's left as an exercise for the reader.)&nbsp;
      For you folks, here's how the compilation step works.<br>
    </p>
    <p>There are really two cases of interest.&nbsp; First, you might
      want to simulate a single AGC module, to exercise its functions
      and perhaps to debug it.&nbsp; For concreteness, let's imagine
      that this module has drawing number 2005123A, and hence its files
      reside in the directory Schematics/2005123A.&nbsp; There will be
      two relevant files in that directory:&nbsp; module.v, which is the
      Verilog of the module itself, automatically translated from the
      CAD files for drawing 2005123A, and module_tb.v, the Verilog file
      of the "test bench" of the module.&nbsp; As explained earlier,
      there will be either an automatically-generated version of the
      test bench or else a manually tweaked version of the test bench
      file already in place.&nbsp; But it's up to you to insure that the
      test bench does what you want.&nbsp; The compilation is simple:<br>
    </p>
    <blockquote><font face="Courier 10 Pitch">cd Schematics/2005123A<br>
        iverilog -o module.vvp module_tb.v module.v</font><br>
    </blockquote>
    <p>which produces an object file, Schematics/2005123A/module.vvp.<br>
    </p>
    <p>The second case is simulation of a complete AGC unit.&nbsp; Let's
      suppose that this is the AGC with p/n 2003200.&nbsp; AGC p/n is
      essentially a collection of various AGC modules, plugged into a
      "backplane".&nbsp; Module A1 is drawing 2005259A, module A2 is
      drawing 2005260A, etc., up through module A24, drawing
      2005273A.&nbsp; As above, there is a testbench file, 2003200.v,
      which represents the backplane, along with any stimulation you
      need to apply to the backplane symbols, and any probing you need
      to do on those signals.&nbsp; So here is what the Verilog
      compilation looks like:<br>
    </p>
    <blockquote><font face="Courier 10 Pitch">cd Schematics<br>
        <font face="Courier 10 Pitch">iverilog -o 2003200.vvp 200<font
            face="Courier 10 Pitch">3</font>200.v 2005259A/module.v
          2005260A/module.v ... 2005273A/module.v</font><br>
      </font></blockquote>
    <p>This produces an object file, Schematics/2003200.vvp.<br>
    </p>
    <h2><a name="Step_6:_Running_the_Simulation"></a>Workflow Step 7:
      Running the Simulation</h2>
    This is simplicity itself.&nbsp; In terms of the examples in the
    preceding section, to simulate drawing 2005123A we'd do this:<br>
    <blockquote><font face="Courier 10 Pitch">cd Schematics/2005123A<br>
        <font face="Courier 10 Pitch">vvp module.<font face="Courier 10
            Pitch">vvp</font></font><br>
      </font></blockquote>
    while to simulate AGC p/n 2003200 we'd do this:<br>
    <blockquote><font face="Courier 10 Pitch">cd Schematics<br>
        <font face="Courier 10 Pitch">vvp 2003200.vvp</font></font><font
        face="Courier 10 Pitch"><font face="Courier 10 Pitch"><font
            face="Courier 10 Pitch"><font face="Courier 10 Pitch"> -lxt2</font></font></font></font></blockquote>
    Depending on your intentions — i.e., how the testbench is written —
    the simulation may or may not be a hands-off operation.&nbsp;
    Typically, though, it would result either in messages printed out to
    the terminal or creation of a log file for later viewing and
    analysis, or both.&nbsp; <br>
    <br>
    For example, the sample testVerilog design discussed earlier
    produces a log file called testVerilog.vcd, whereas the
    automatically-generated test-bench files instead cause a log file
    called module.lxt2 to be created.&nbsp; VCD and LXT2 files contain
    the same kind of information, but VCD has the advantage of being
    ASCII and therefore easily processed (for example) with scripts,
    whereas LXT2 is compressed and is therefore very tiny in
    comparison.&nbsp; It's up to you!&nbsp; Regarding the command-line
    switches given above, you'll notice the "-lxt2" switch in just one
    of the cases.&nbsp; By default, the log file will be in VCD format,
    regardless of the naming for it used in the test bench.&nbsp; By
    adding the "-lxt2" switch, we tell the simulator to use LXT2
    format.&nbsp; There are several variations of this switch, with
    "-lxt2-space" specifying you want LXT2 files as small as possible,
    and "-lxt2-space" specifying that you want LXT2 files that are
    produced as fast as possible.&nbsp; <b>Note:</b>&nbsp; It's
    important that the -lxt2 switch, or similar switches, come <i>after</i>
    the filename on the 'vvp' command line.<br>
    <br>
    On the other hand, if you want to instead (or additionally) view
    messages printed out in "real" time by the simulation, you do this
    with the $monitor command in the test bench Verilog.&nbsp; Again,
    it's up to you!<br>
    <h2><a name="Step_7:_Viewing_the_Results"></a>Workflow Step 8:
      Viewing the Results</h2>
    <p>Assuming that your simulation produces a log file for later
      viewing or analysis, there are several choices.<br>
    </p>
    <p>For example, as mentioned in the preceding section, a VCD log
      file is ASCII, and therefore very suited for some kind of
      post-processing with scripts written in AWK or Python or some
      other language.&nbsp; <br>
    </p>
    <p>Often, though, it's nicer to just view some set of signals of
      interest as if using an oscilloscope or logic analyzer.&nbsp; A
      program like GTKWave is great for this, in that it can view either
      VCD or LXT2 files, and you can select the specific signals you
      want to view, and the ordering of those signals.&nbsp; For the
      examples we've been using, you'd do one of the following and then
      just monkey around in GTKWave's GUI:<br>
    </p>
    <blockquote>
      <p><font face="Courier 10 Pitch">cd Schematics/2005123A<br>
          <font face="Courier 10 Pitch">gtkwa<font face="Courier 10
              Pitch">ve module.vcd</font></font><br>
        </font></p>
    </blockquote>
    <p>or<br>
    </p>
    <blockquote><font face="Courier 10 Pitch">cd Schematics<br>
        <font face="Courier 10 Pitch">gtk<font face="Courier 10 Pitch">wave
            2003200.lxt2</font></font><br>
      </font></blockquote>
    <ul>
    </ul>
    <h1><a name="Appendix:_Translation_from_KiCad_into"></a>Appendix:
      Technical Details<br>
    </h1>
    <p>This Appendix discusses the details of how to perform the
      operations that have only been described in general terms
      above.&nbsp; Those operations are presented in roughly the order
      they are used.<br>
    </p>
    <h2><a name="CreatingSchematic"></a>Creating/Editing a Schematic
      Diagram</h2>
    <p>This is too detailed a topic for me to give much helpful advice
      about in a limited space.&nbsp; I will simply point out the
      following:<br>
    </p>
    <ul>
      <li>The schematic-capture editor supplied with KiCad EDA is called
        <b>eeschema</b>.<br>
      </li>
      <li>Schematic diagrams transcribed from the original Apollo
        Guidance, Navigation &amp; Control (GNC) system are found in <a
          moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/schematics/Schematics">the
          "schematics" branch of our Virtual AGC repository, in the
          folder called "Schematics"</a>.</li>
      <li>There is a separate folder for each original drawing number,
        such as 1005700A or 2005259-.&nbsp; All operations specific to a
        given drawing are expected to be performed within its folder
        unless otherwise stated.&nbsp; The top-level page of the
        schematic has the filename "module.sch" (for KiCad v.5 or prior)
        or "module.kicad_sch" (for KiCad v.6 or later).&nbsp; The
        descriptions below assume the latter.<br>
      </li>
      <li>All operations described on this web-page were originally
        performed with KiCad v.5 but are today tested with KiCad v.6 and
        v.7.&nbsp; If you have installed KiCad v.8 or v.9, I have every
        expectation that they will operate as described, but have not
        tested them.<br>
      </li>
    </ul>
    <h2><a name="CreatingNetlists"></a>Creating a Netlist</h2>
    <p>There are two methods.&nbsp; <br>
    </p>
    <p>Method 1:&nbsp; While viewing the top-level page of a schematic
      diagram in <b>eeschema</b>, select File/Export/Netlist from the
      main menu.&nbsp; In the "Export Netlist" window which pops up,
      select the tab labeled "OrcadPCB2" and click the button labeled
      "Export Netlist".&nbsp; In the "Save Netlist File" dialog which
      appears, which should have pre-chosen the folder containing the
      top-level schematic file itself, save the netlist as "module.net".<br>
    </p>
    <p>Method 2:&nbsp; For KiCad v.7 or later, the netlist can be
      created from a command line without even running <b>eeschema</b>.&nbsp;
      The command would be<br>
    </p>
    <blockquote>
      <pre>kicad-cli sch export netlist --output module.net --format orcadpcb2 module.kicad_sch<br></pre>
    </blockquote>
    <h2><a name="Converting_Netlist_to_Verilog"></a>Converting Netlists
      to Verilog Source Code<br>
    </h2>
    The supplied tools for converting a netlist (or more accurately, a
    netlist plus the associated schematic) to Verilog source code are
    specific to AGC logic modules as originally designed, and to our
    specific manner of transcribing those those drawings for use with <b>eeschema</b>.&nbsp;
    Departing from any of those conditions could render the supplied
    tools useless, thus forcing you to <i>manually</i> create whatever
    Verilog source code you think represents your digital circuit.&nbsp;
    The conditions are:<br>
    <ul>
      <li>Only the AGC modules (i.e., drawing numbers) designated as
        "logic modules" are relevant to the digital simulation.&nbsp;
        For example, for AGC model 2003993, the logic modules are A1
        (schematic drawing 2005259), A2 (schematic drawing 2005260), and
        so on.<br>
      </li>
      <li>The only digital-logic components used in logic modules are
        dual triple-input open-drain NOR gates.<br>
      </li>
      <li>Each digital-logic component has a reference designator of the
        form U<i>snn</i>, where <i>snn</i> is a three-digit decimal
        number.&nbsp; The two NOR gates of a single dual-NOR component
        share the same reference designator.&nbsp; In other respects,
        these reference designators are unique throughout a given logic
        module (i.e., top-level schematic).&nbsp; Each logic module is a
        2-sided circuit board, with all reference designators on the
        "top" side having <i>s</i>=1 and all on the "bottom" having <i>s</i>=2.</li>
      <li>Each NOR gate has a 5-digit "location", <i>mmnnn</i> that's
        unique throughout the entire AGC.&nbsp; Any given dual-gate
        component thus has two separate locations, one for each of the
        two gates.&nbsp; The digits <i>mm</i> are specific to the logic
        module and the digits <i>nnn</i> vary across module.</li>
      <li>When the logic circuit being simulated spans more than a
        single logic module, as is the case when simulating the entirety
        of an AGC, the logic modules interconnect by being plugged into
        a common backplane.&nbsp; In the electrical schematics, this
        backplane is represented as 4 separate 72-pin connectors, with
        reference designators J1, J2, J3, and J4.&nbsp; For example, pin
        J2-5 represents the same signal within every logic module.</li>
      <li>In summary, digital circuits which can be simulated using the
        supplied tools consist entirely of triple-input open-drainNOR
        gates, backplane connectors, and the wires interconnecting them.<br>
      </li>
    </ul>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
        To be completely honest, I'm no longer entirely sure how many of
        these rules the supplied tools actually depend upon, as opposed
        to these rules just being the ones obeyed by the original
        developers.&nbsp; <i>Most</i> of them are relied upon.</font><br>
    </blockquote>
    To convert a <i>single</i> schematic to Verilog source code, the
    Python 3 script <b>dumbVerilog.py</b> is used:<br>
    <blockquote><font face="Courier 10 Pitch">dumbVerilog.py <i>MODULE</i>
        <font face="Courier 10 Pitch">module</font>.net pins.txt <i>DELAY</i>
        <font face="Courier 10 Pitch">module.init</font>
        module.kicad_sch [<i>WIRETYPE</i>] &gt;<font face="Courier 10
          Pitch">module</font>.v</font><br>
    </blockquote>
    The files called pins.txt and module.init are described in <a
      moz-do-not-send="true" href="#Generating_Flip-flop_Initialization">the
      next section</a>.&nbsp; The file pins.txt will be searched for if
    not found; it may be either in the current directory, the directory
    containing <b>dumbVerilog.py</b> itself (the usual case), or else
    specified with an explicit path.&nbsp; The parameters "module.net",
    "module.kicad_sch" (or just "module.sch" for KiCad v.5), and
    "module.v" are literal.&nbsp; As for the remaining command-line
    parameters:<br>
    <ul>
      <li><code><i>MODULE</i></code> would be something like "A1", "A2",
        etc.&nbsp; It's the designation of the specific logic module to
        which the schematic belongs.&nbsp; The tool doesn't actually use
        this for anything except as a unique identifier when multiple
        logic modules are interconnected, so if you're working with a
        circuit other than the official AGC modules, it doesn't really
        matter what you use here, though I would recommend that it still
        be of the form A<i>nn</i>.</li>
      <li><code><i>DELAY</i></code>, roughly speaking, is the
        propagation delay of signals from the input of a NOR gate to its
        output.&nbsp; The unit in which <code><i>DELAY</i></code> is
        expressed ultimately depends upon the time-scale that will be
        set in the test bench, but that's conventionally 100 ns.&nbsp;
        The nominal gate delay of AGC NOR gates was 20 ns, so that means
        a reasonable <code><i>DELAY</i></code> might be 0.2.</li>
      <li><code><i>WIRETYPE</i></code> is an optional parameter having
        the value either "<code>wire</code>" or "<code>wand</code>".&nbsp;
        It shouldn't matter which is chosen, so this parameter should
        probably be omitted.<br>
      </li>
    </ul>
    There is also a way to semi-automate creation of the netlist(s) and
    other portions of the simulation workflow if you want to simulate an
    <i>entire AGC</i>.&nbsp; Or at least there is such a shortcut in
    Linux and possibly Mac OS, though not presently in Windows.&nbsp;
    Specifically, there's a Makefile which can be used with the GNU <b>make</b>
    utility to batch produce Verilog source for all of the available
    schematics, as well as creating a rough draft of a "test bench" (<a
      moz-do-not-send="true"
      href="#Converting_Verilog_Module_to_Verilog">see below</a>) for a
    given AGC module.<br>
    <br>
    As mentioned earlier, we don't really translate from KiCad into
    Verilog,
    but rather from a KiCad netlist (in "OrcadPCB2" format) into
    Verilog.&nbsp; If you are lucky enough to be running Linux, or
    possibly Mac OS X, you can simply use the convenient Makefile:<br>
    <blockquote><font face="Courier 10 Pitch">cd Schematics<br>
        make</font><br>
    </blockquote>
    or perhaps<br>
    <blockquote><font face="Courier 10 Pitch">cd Schematics<br>
        make clean all</font><br>
    </blockquote>
    <h2><a name="PinsTxt"></a>The pins.txt File</h2>
    <p>Abstractly, the AGC circuitry consists of a number of "modules"
      (each represented by an electrical schematic), plugged into a
      "backplane".&nbsp; The backplane, again abstractly, consists of a
      set of connectors whose pins are interconnected by wires.&nbsp;
      However, there is no schematic diagram as such for the backplane,
      so to incorporate the backplane into our simulation the
      interconnections in the backplane must be specified in some other
      form.&nbsp; That alternate form of description is the pins.txt
      file, which is just a text file having a separate line in it for
      each pin of each connector on the backplane.&nbsp; <br>
    </p>
    <p>Each line of the file has four fields, delimited by space
      characters.&nbsp; Those fields are:<br>
    </p>
    <ol>
      <li>A module number (A<i>nn</i> or B<i>nn</i>).</li>
      <li>A pin number on the backplane connector for the module.<br>
      </li>
      <li>A signal type:&nbsp; IN, OUT, INOUT, BP, FIX, FOX, NC, SPARE</li>
      <li>A signal name (blank if signal type is NC or SPARE)<br>
      </li>
    </ol>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Technically, there
        are actually two separate backplanes, designated "A" and "B",
        into which the AGC modules A<i>nn</i> and B<i>n</i>n
        respectively plug, with some interconnections between the two
        backplanes.&nbsp; The pins.txt file describes both, so we may as
        well think of it simply as one big backplane.</font><br>
    </blockquote>
    <p>Regarding the module-to-backplane connectors, for the logic
      modules that interest us for simulation purposes, each module had
      a physical 284-pin connector consisting of 4 rows of 71 pins
      each.&nbsp; (The 21st pin from either end of a row was missing, so
      you could equally-well consider it physically to be a 276-pin
      connector consisting of 4 rows of 69 pins each.&nbsp; But the pin
      numbering pretends that the missing pins were present.)&nbsp; <i>On
        the other hand</i>, on the electrical schematics for the logic
      modules, each of the 71-pin rows was considered a separate
      connector, and thus the schematics show 4 separate connectors
      each, designated as J1, J2, J3, and J4.<br>
    </p>
    <p>Just to emphasize this point, in case the message was lost in the
      details:&nbsp; In pins.txt each backplane connector for a logic
      module has 284 pins, while on the logic module's electrical
      schematics there are instead 4 connectors of 71 pins each.<br>
    </p>
    <p>In principle, a separate pins.txt file should be used for each
      different AGC model.&nbsp; In practice, there's little difference
      between the models and there is presently a single pins.txt file
      used for all Block II AGC's.&nbsp; <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; The existing pins.txt was
          derived from Mike Stewart's digital simulation of the
          AGC.&nbsp; Mike's backplane pin data was derived in turn <a
            moz-do-not-send="true"
href="https://github.com/virtualagc/agc_simulation/blob/master/scripts/generate_agc_backplane.py">by
            a script</a> that analyzed his Verilog files.&nbsp; Thus if
          we indeed wanted to generate a separate pins.txt file for each
          Block II AGC model we'd have an awkward chicken-and-egg
          problem, since <b>dumbVerilog.py</b> needs pins.txt <i>before</i>
          generating our Verilog files, whereas the only automated way
          of generating pins.txt does so <i>after</i> creating the
          Verilog files.&nbsp; On the other hand, for Block I AGC's I've
          created a similar file, <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/pinsBlockI.txt">pinsBlockI.txt</a>,
          by processing Block I schematics (rather than Verilog files)
          using <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/schematics/Scripts/pinsDbBlockI.awk">an
            AWK script</a>, so perhaps the same technique could be used
          for Block II as well.&nbsp; However, the pinsBlockI.txt file
          is in a somewhat different format than pins.txt, and <b>dumbVerilog.py</b>
          isn't presently able to support that particular format.&nbsp;
          Although I don't recall for certain, I suppose this means that
          I had only done preliminary work on Block I AGC simulation,
          without having taken it to the point of the simulation
          actually functioning.&nbsp; <br>
        </font></p>
    </blockquote>
    <h2><a name="Generating_Flip-flop_Initialization"></a>Generating
      Flip-flop Initialization files (module.init)</h2>
    <p><img src="testVerilogCircuitInit.png" alt=""
        moz-do-not-send="true" height="485" align="right" width="348">The
      only digital components present in AGC logic-module schematics are
      dual triple-input open-drain NOR gates, which in themselves are
      stateless; i.e., the output signal of a NOR gate is directly
      determined by the <i>current</i> state of its input
      signals.&nbsp; Or at least, the state of the input signals after
      however long it takes the signals to propagate through the gate,
      which is nominally 20 nanoseconds.&nbsp; Nevertheless, it is
      possible to interconnect NOR gates in such a way that the
      constellation of NOR gates has an output signal that does not
      necessarily depend on the current state of the inputs.&nbsp; In
      other words, the constellation of NOR gates has "memory".&nbsp;
      The most-common such circuit block in the AGC uses several NOR
      gates to form what's known as a "flip-flop"; i.e., a memory
      element capable of indefinitely storing a single bit
      indefinitely.&nbsp; Or rather, of storing a bit until the power is
      cycled, at which point the value of the bit is lost.&nbsp; The
      testVerilog circuit used in examples above, and shown yet again in
      the image at the right, is such a flip-flop.<br>
    </p>
    <p>For simulation of a circuit containing flip-flops like this, the
      question becomes "What are the states of the flip-flops at
      power-up?"&nbsp; <i>After</i> power-up is no issue, since if we
      know the states of the flip-flops at power up, the simulation
      itself takes care of computing their states at later times.&nbsp;
      But we first have to have some way of knowing what the states were
      at power-up in order to do that.<br>
    </p>
    <p>In the design of the physical AGC, almost no effort is given to
      putting these implicit flip-flops into any given state.&nbsp; (And
      in those cases where an effort had been made, the mechanisms used
      would put the simulated flip-flops into a known state too.)&nbsp;
      Rather, the developers just seemed to feel that the flip-flops
      would generally settle down into <i>some</i> stable state, and
      that assurance proved to be enough for their purposes.&nbsp; For <i>our</i>
      purposes, namely digital simulation, it's <i>not</i>
      enough!&nbsp; In simulation, it's perfectly possible for a such a
      flip-flop to oscillate indefinitely without ever settling down
      into some stable state, which means that the Verilog emulator
      could get stuck in an infinite loop or timeout while trying to
      compute the initial state of the circuit.&nbsp; No good!<br>
    </p>
    <p>To specify the initial states of flip-flops, module.init allows
      you to state the initial output signal of any or all of the NOR
      gates.&nbsp; A dual NOR gate component used in the AGC has two
      outputs, which are designated as pin J for one of the NOR gates
      and K for the other of the NOR gates.&nbsp; The way these are
      specified in module.init is that there is a line in the file for
      each dual NOR component that you want to specify, and that line
      has the format<br>
    </p>
    <blockquote><i>Unnn OutputJ OutputK</i><br>
    </blockquote>
    where <i>Unnn</i> is the reference designator of the dual-NOR
    component and <i>OutputJ</i> and <i>OutputK</i> are the output
    signal levels (0 or 1).&nbsp; For testVerilog, for example,
    module.init looks like:<br>
    <blockquote>
      <pre>U127 1 0<br>U129 1 0<br></pre>
    </blockquote>
    <p>In other words, U127's J output is 1 ("on") and K output is 0
      ("off"); and the same for U129.&nbsp; I've illustrated that in the
      image to the right by coloring NOR-gate outputs specified
      initially as 1 in <font color="#33cc00">green</font>, and those
      specified initially as 0 in <font color="#ff0000">red</font>.&nbsp;
      You don't need to specify the output for every NOR gate, and thus
      the outputs of U126 and U128 are left unspecified.&nbsp; But if
      you manually create the module.init file, it's entirely up to you
      to determine which ones you want to specify; and worse, not all
      possible combinations of signals are consistent, and <i>you</i>
      must insure the consistency.&nbsp; Because of the way NOR gates
      work, specifying that U129's OutputJ is 1 <i>forces</i> U127
      OutputK, U128 OutputJ, and U129 OutputK all to be 0.&nbsp; So if
      you specified any of those latter outputs to be 1, you'd be
      creating an inconsistent set of inital conditions.<br>
    </p>
    <p>Fortunately, a consistent set of flip-flop initializations can
      conveniently be generated using the Python 3 script <b>dumbInitialization.py</b>.&nbsp;
      The syntax is simply<br>
    </p>
    <blockquote>
      <p><font face="Courier 10 Pitch">dumbInitialization.py
          &lt;module.v</font></p>
    </blockquote>
    <p>where<code> module.v</code><code></code> is the Verilog
      source-code file associated with the module.&nbsp; As it happens,
      <b>dumbInitialization.py</b> does not output any file specially
      called module.init.&nbsp; Rather, it expects to be operating on an
      entire AGC circuit, so it outputs separate initialization files
      for each of the AGC's logic modules:&nbsp; A1.init, A2.init, and
      so on.&nbsp; As you may recall, the testVerilog circuit is a
      snippet from the circuit for logic module A1, so we'd have to
      rename A1.init as module.init after running <b>dumbInitializion.py</b>.&nbsp;
      Still, the operation seems pretty simple.<br>
    </p>
    <p>This apparent simplicity hides a nasty chicken-and-egg truth,
      namely that we need to have module.init for <b>dumbVerilog.py</b>
      to produce module.v, and we need module.v for <b>dumbInitialization.py</b>
      to produce module.v.&nbsp; Catch 22!<br>
    </p>
    <p>Fortunately, this circle is not
      as vicious as it appears, since all you really have to do is
      follow this 3-step procedure:<br>
    </p>
    <ol>
      <li>Use <b>dumbVerilog.py</b> with an empty module.init, or else
        one of your own devising, to create module.v.<br>
      </li>
      <li>Use <b>dumbInitialization.py</b> to generate A1.init, and
        rename A1.init as module.init.<br>
      </li>
      <li>Use <b>dumbVerilog.py</b> again, to regenerate module.v.</li>
    </ol>
    <p>And indeed, this process works for us, giving us<br>
    </p>
    <blockquote>
      <pre># Auto-generated for module A1 by dumbInitialization.py.<br>U127 1 0<br>U129 1 0<br></pre>
    </blockquote>
    <p><strike>(</strike><strike><i>Come back to the following later and
          fix it up.)</i></strike></p>
    <p><strike>If you are running Linux then the simplest thing to do
        (for, say, AGC model 2003200) is just</strike><strike><br>
      </strike></p>
    <blockquote>
      <p><strike><font face="Courier 10 Pitch">cd <font face="Courier
              10 Pitch">S</font>chematics<br>
            <font face="Courier 10 Pitch">make clean all <br>
              <font face="Courier 10 Pitch">make </font>2003200.init<br>
              <font face="Courier 10 Pitch"><font face="Courier 10
                  Pitch">make clea<font face="Courier 10 Pitch">n all</font></font></font><br>
            </font></font></strike></p>
    </blockquote>
    <p><strike>Of course, if you don't have Linux then this doesn't help
        you too much, so let's consider how to go about generating the
        flip-flop initialization files (</strike><strike><i>DRAWING</i></strike><strike>/module.init)
        as a manual operation rather than using the handy-dandy
        Makefile.&nbsp; The basic syntax is simply</strike><strike><br>
      </strike></p>
    <blockquote>
      <p><strike><font face="Courier 10 Pitch">dumbInitialization.py
            &lt;module.v</font></strike><strike><br>
        </strike></p>
    </blockquote>
    <strike><br>
    </strike>
    <p><strike>That's why in the Makefile example we started with, there
        are two "make clean all" steps.</strike><strike><br>
      </strike></p>
    <p><strike>There are two basic scenarios for which you'd want to
        generate initialization files, I think:&nbsp; You might want an
        initialization file for an AGC module considered as a
        stand-alone unit.&nbsp; Or, you might want an initialization
        file for the complete set of AGC modules of a given AGC part
        number.&nbsp; The latter has an advantage over the former, in
        that the initialization is internally consistent throughout the
        entire AGC.&nbsp; Besides, an initialization file of the
        full-AGC type works perfectly well for an individual module, but
        not vice-versa.&nbsp; So let's assume you really want
        initialization files for the AGC as a whole.</strike><strike><br>
      </strike></p>
    <p><strike>The first step, of course, is to take all of the Verilog
        files for the individual AGC modules, and concatenate them to
        form one large file.&nbsp; For AGC model 2003200, for example,
        those files are 2005259A/module.v, 2005260A/module.v, ...,
        2005273A/module.v.&nbsp; (The drawing numbers for the AGC
        modules, which is essentially what these are, are listed both on
      </strike><strike><a href="ElectroMechanical.html">the
          Electro-Mechanical page</a></strike><strike> of the website,
        and in Schematics/Makefile.)&nbsp; You can combine these files,
        for example, using a text-editor program.&nbsp; The second step
        is to actually run dumbInitialization.py:</strike><strike><br>
      </strike></p>
    <blockquote><strike><font face="Courier 10 Pitch">Scripts/dumbInitialization.py
          &lt; </font></strike><strike><font face="Courier 10 Pitch"><font
            face="Courier 10 Pitch">Bi<font face="Courier 10 Pitch">gCombined<font
                face="Courier 10 Pitch">VerilogFile</font></font></font>.v</font></strike></blockquote>
    <strike>
      The result is the creation of files files A1.init, A2.init, ...,
      A24.init.&nbsp; These need to be copied into the appropriate
      drawing directories and be renamed to module.init.&nbsp; For
      example, A1.init
      might become 2005259A/module.init.
    </strike>
    <h2><a name="Converting_Verilog_Module_to_Verilog"></a>Converting
      Verilog Module to Verilog Test Bench</h2>
    After you've waded through the stuff above, you've managed to create
    a Verilog description of each individual AGC module, but these are
    completely stand-alone and don't fit together in any way.&nbsp; It's
    as if the AGC modules weren't plugged into the AGC's
    backplane.&nbsp; The "test bench" is like the backplane, in that it
    provides a way to wire all of the AGC modules' Verilog files
    together.<br>
    <br>
    If you are running Linux and used the Makefile described above, in
    the form "make clean all", you will have already created a primitive
    backplane and plugged all of the AGC modules into it.&nbsp; For AGC
    model 2003200, for example, the test bench Verilog is the file
    Schematics/2003200.v, and the compiled form of it with all of the
    modules plugged in is Schematics/2003200.vvp.<br>
    <br>
    If you're not running Linux (or possibly Mac OS X), though, you have
    some manual work to do.&nbsp; First, you need the "big combined
    file" of the Verilog for all of the AGC model's modules, just like
    in the preceding section.&nbsp; Or, <i>almost</i> like in the
    preceding section:&nbsp; there it was a concatenated file of all the
    Verilog, prior to having developed initialization files for it;
    here, you need a concatenation of all the Verilog files with
    up-to-date initialization information in them.&nbsp; The conversion
    step is just<br>
    <blockquote><font face="Courier 10 Pitch">Scripts/dumbTestbench &lt;
        BigCombinedVerilogFile.v &gt; Testbench.v</font><br>
    </blockquote>
    Such a testbench probably still needs considerable tweaking, but
    it's a good place to start.<br>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center> <br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">Creative
Commons
          No Rights Reserved License</a></span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2025-01-11<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" border="0" height="100"
              width="300"></a><br>
        </font></i> </center>
    <br>
    <br>
  </body>
</html>
