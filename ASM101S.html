<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>AP-101S Macro Assembler</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <div align="center">
      <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","IBM AP-101S / AP-101B").replace("@SUBTITLE@","Macro Assembler"))
</script><br>
      <font size="+2"><i>(This page and ASM101S itself are under
          construction.)</i></font><br>
    </div>
    <h1>Table of Contents </h1>
    <ul>
      <li><a moz-do-not-send="true" href="#Introduction">Introduction</a></li>
      <li><a moz-do-not-send="true" href="#References">References</a></li>
      <li><a moz-do-not-send="true" href="#master">The Master Sequence
          Controller (MSC)</a></li>
      <li><a moz-do-not-send="true" href="#bce">The Bus Control Elements
          (BCE)</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#ASM101S">ASM101S</a></li>
      <li><a moz-do-not-send="true" href="#macros">Macro-Library Files</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#Installation">Installation of
          ASM101S</a></li>
      <li><a moz-do-not-send="true" href="#wildThings">Where Are the
          AP-101 Assembly-Language Files</a></li>
      <li><a moz-do-not-send="true" href="#Differences">Potential
          Differences from Expectations</a></li>
      <ul>
      </ul>
    </ul>
    <h1><a name="Introduction"></a>Introduction</h1>
    <b>ASM101S</b> is our "modern" version of the macro assembler for
    the assembly language of the IBM AP-101S or AP-101B computers used
    as "General Purpose Computers" (GPC) in the Space Shuttle.&nbsp; To
    the best of my knowledge, the original assembler actually used for
    Shuttle software development has not survived, so <b>ASM101S</b> is
    an entirely-new creation.&nbsp; It is a Python 3 program that should
    work on any computer having the Python 3 language installed. <br>
    <br>
    Regarding AP-101B vs AP-101S, the AP-101B was used in earlier
    Shuttle flights, while the AP-101S was used in later flights.&nbsp;
    I have almost no documentation for the AP-101B, but believe that
    insofar as software is concerned, the main difference is that a
    handful of new instruction types were made available in the AP-101S
    that hadn't existed in the AP-101B.&nbsp; Therefore, <b> ASM101S</b>
    itself makes no distinctions between the two languages:&nbsp; If you
    feed in source code using any of the newer instructions, you'll get
    object code suitable for the AP-101S only.&nbsp; If you feed in
    source code not having any of the newer instructions, you'll get
    object code suitable for both the AP-101S and AP-101B.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; That's not to say
        that the differences were insignificant, but merely that the
        differences are transparent to the assembler.&nbsp; Here's <a
          moz-do-not-send="true"
href="Shuttle/IBM%20AP-101S%20General%20Purpose%20Computer%20With%20Shuttle%20Instruction%20Set%20-%20searchable.pdf#page=40">a
          summary</a> of some of the known differences:<br>
        <br>
      </font>
      <table cellspacing="10" cellpadding="2" align="center">
        <tbody>
          <tr>
            <th valign="top" align="left"><font size="-1"><u>Feature</u><br>
              </font></th>
            <th valign="top" align="left"><u><font size="-1">AP-101B<br>
                </font></u></th>
            <th valign="top" align="left"><u><font size="-1">AP-101S<br>
                </font></u></th>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Power:<br>
              </font></td>
            <td valign="top"><font size="-1">780W<br>
              </font></td>
            <td valign="top"><font size="-1">560W<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Weight:<br>
              </font></td>
            <td valign="top"><font size="-1">117 pounds<br>
              </font></td>
            <td valign="top"><font size="-1">64 pounds<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Memory:<br>
              </font></td>
            <td valign="top"><font size="-1">104K words<br>
                (416K bytes)<br>
              </font></td>
            <td valign="top"><font size="-1">256K words<br>
                (1024K bytes)<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Memory Protection<br>
                (per 16-bit half-word):<br>
              </font></td>
            <td valign="top"><font size="-1">1 parity bit and <br>
                1 store-protect bit<br>
              </font></td>
            <td valign="top"><font size="-1">6 ECC bits and <br>
                3 store-protect bits<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Speed:<br>
              </font></td>
            <td valign="top"><font size="-1">420K operations/second<br>
              </font></td>
            <td valign="top"><font size="-1">&gt;1000K operations/second<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Battery backup:<br>
              </font></td>
            <td valign="top"><font size="-1">n/a<br>
              </font></td>
            <td valign="top"><font size="-1">Rechargeable NiCAD </font><br>
            </td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Built-in test equipment:
                &nbsp; &nbsp; &nbsp; <br>
              </font></td>
            <td valign="top"><font size="-1">n/a<br>
              </font></td>
            <td valign="top"><font size="-1">Temperature; charger;
                battery; soft error counter<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top">MTBF:<br>
            </td>
            <td valign="top"><font size="-1">5K hours<br>
              </font></td>
            <td valign="top"><font size="-1">24K hours<br>
              </font></td>
          </tr>
        </tbody>
      </table>
      <br>
    </blockquote>
    Because of this dearth of software distinction between the different
    models in a software sense, I'll generally just refer to the
    "AP-101" rather than specifying "AP-101S" or "AP-101B".&nbsp;
    Realize, though, that there were also models of the IBM AP-101
    computer other than the AP-101B or AP-101S, for uses <i>other</i>
    than the Shuttle, and there's no particular reason to believe that <b>ASM101S</b>
    could assemble their source code without some updates.<br>
    <br>
    Despite the lack of surviving documentation about the original
    AP-101 assembler, by examining the surviving AP-101
    assembly-language source code I've concluded that the syntax of the
    AP-101 assembly language must have closely mimicked that of the
    standard macro assembler for the IBM System/360 Basic Assembly
    Language (BAL).&nbsp; This observation has been central to the
    development of <b>ASM101S</b>.<br>
    <h1> <a name="References"></a>References</h1>
    <ul>
      <li>"<a moz-do-not-send="true"
          href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf">Space
          Shuttle Model AP-101S Principles of Operations with Shuttle
          Instruction Set</a>".&nbsp; Manual for the CPU instruction
        set.&nbsp; Also known as the "POO" (Principles of Operation).<br>
      </li>
      <li>"<a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231">OS








          Assembler Language - OS Release 21</a>".&nbsp; Manual for the
        System/360 macro assembler upon which <b>ASM101S</b> is
        modeled.</li>
      <li><a moz-do-not-send="true"
href="Shuttle/IBM%20AP-101S%20General%20Purpose%20Computer%20With%20Shuttle%20Instruction%20Set%20-%20searchable.pdf">A
          collection of notes about the AP-101S/AP-101B</a>.</li>
      <li>"<a moz-do-not-send="true"
href="Shuttle/Courses/AP-101S%20Assembly%20Language%20Introduction%20Course.pdf">AP








          101S Assembly Language Introduction</a>".</li>
      <li>"Space Shuttle Advanced System/4 Pi Input/Output Processor
        (IOP)":</li>
      <ul>
        <li><a moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20-%20Input,%20Output%20Processor%20(IOP)%20-%20Principles%20of%20Operation%20for%20PCI,%20PCO,%20MSC,%20and%20BCE.pdf">Parts






            I and II</a>:&nbsp; :&nbsp; Principles of Operation for
          PCI/PCO and MSC</li>
        <li><a moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Input,%20Output%20Processor%20(IOP)%20-%20Part%203%20-%20Principles%20of%20Operation%20for%20the%20Bus%20Control%20Element.pdf">Part






            III</a>:&nbsp; Principles of Operation for BCE.</li>
      </ul>
      <li>"<a moz-do-not-send="true"
href="Shuttle/IBM-75-A97-001%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Model%20AP-101%20Central%20Processor%20Unit%20-%20Technical%20Description.pdf">Space






          Shuttle Advanced System/4 Pi Model AP-101 Central Processor
          Unit Technical Description</a>".&nbsp; Note that this predates
        the AP-101S model and doesn't precisely match it.<br>
      </li>
    </ul>
    <h1><a name="master"></a>The Master Sequence Controller (MSC)<br>
    </h1>
    AP-101 assembly language includes not only pseudo-ops and AP-101 CPU
    instructions as such, but also instructions for the Master Sequence
    Controller (MSC). You might categorize the MSC as being a separate
    computer within the main computer. The CPU and MSC instructions, for
    these two essentially separate types of computers, are intermixed
    indiscriminately in AP-101 assembly-language source code and sharing
    memory.&nbsp; <a moz-do-not-send="true"
href="httpsShuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=337">The






      POO</a> explains the MSC thusly:<br>
    <blockquote><font size="-1">"The Master Sequence Controller (MSC) is
        a micro programmed computer specifically tailored for I/O
        Management within the Space Shuttle General Purpose Computer
        (GPC).&nbsp; As such, it has extensive and programmable
        capabilities for monitoring and controlling the basic I/O
        operations performed by upwards to 24 Bus Control Elements
        (BCE's) which are implemented in the baseline GPC.&nbsp; These
        capabilities include setting up, scheduling, and initiating BCE
        programs, monitoring the status of BCD operations, and
        communicating overall completion of these operations to the
        CPU."</font><br>
    </blockquote>
    MSC instructions can be distinguished from CPU instructions in that
    they begin with the character "@".<br>
    <br>
    See <a moz-do-not-send="true"
      href="Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=337">Appendix






      II of the AP-101S POO</a> or the seemingly-identical <a
      moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20-%20Input,%20Output%20Processor%20(IOP)%20-%20Principles%20of%20Operation%20for%20PCI,%20PCO,%20MSC,%20and%20BCE.pdf#page=68">Part






      II of the IOP POO</a> for more information.<br>
    <h1><a name="bce"></a>The Bus Control Elements (BCE)</h1>
    <p>Similarly, the POO tells us that<br>
    </p>
    <blockquote><font size="-1">"The Bus Control Element (BCE) is a
        microprogrammed controller specifically tailored for management
        of I/O traffic on one of the Space Shuttle system busses.&nbsp;
        Within each IOP [Input/Output Processor] there is one BCE for
        each system bus, for a total of 24 BCE's.&nbsp; Each of these
        BCE's is capable of independent program execution, data
        buffering to and from memory, and communication with the MSC."</font><br>
    </blockquote>
    Or in other words, besides the MSC discussed in the preceding
    section, there are 24 <i>additional</i> processors within the
    AP-101, yet again with their own distinct instruction set, yet again
    sharing memory and intermixed in the assembly-language source code
    with CPU instructions and MSC instructions.<br>
    <p>BCE instructions can be distinguished from CPU and MSC
      instructions in that they begin with the character "#".<br>
    </p>
    <p>See <a moz-do-not-send="true"
        href="Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=445">Appendix






        III of the AP-101S POO</a> or the seemingly-identical <a
        moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Input,%20Output%20Processor%20(IOP)%20-%20Part%203%20-%20Principles%20of%20Operation%20for%20the%20Bus%20Control%20Element.pdf">Part






        III of the IOP POO</a> for more information.<br>
    </p>
    <ul>
    </ul>
    <h1><a name="ASM101S"></a>ASM101S</h1>
    <p>(To be clear, <b>ASM101S</b> is <i>not yet functional</i>.&nbsp;






      I am simply documenting it as I proceed with development!)<br>
    </p>
    The modern assembler is typically invoked as<br>
    <blockquote>
      <pre><font color="#663300">ASM101S.py [ --library=<i>LIBRARY</i> ] [ --sysparm=BFS ] --object=<i>OBJECT</i>.obj <i>SOURCE1</i>.asm <i>SOURCE2</i>.asm ...</font><br></pre>
    </blockquote>
    You can see a list of the available command-line options by using
    the command<br>
    <blockquote>
      <pre><font color="#663300">ASM101S.py --help</font>
</pre>
    </blockquote>
    Invoked in this fashion, the action of the assembler is roughly the
    following:<br>
    <ol>
      <li>(Optionally.)&nbsp; Loads the macro definitions found in the
        assembly-language source-code files (*.asm) found in the <font
          color="#663300"><code><i>LIBRARY</i></code></font>
        folder.&nbsp; (More on this is in the next section.)<br>
      </li>
      <li>Load all of the <font color="#663300"><code><i>SOURCEx</i>.asm</code></font>
        files specified on the command line, in the order that they are
        specified.&nbsp; Macro definitions should precede any
        source-code files using those macros, but the ordering of macro
        files among themselves is not significant.</li>
      <li>Process the entire set of source code which has been loaded.</li>
      <li>Output an assembly report (on <font color="#663300"><code>stdout</code></font>)
        and if there were no fatal errors, an AP-101 object-code file
        named <font color="#663300"><code><i>OBJECT</i></code><code>.obj</code></font>
        that contains the results of the assembly process.<br>
      </li>
    </ol>
    Recognize that at least as far as Space Shuttle flight software is
    concerned, the full flight software consists of a large number of
    assembly language modules and modules written in the high-level
    language HAL/S.&nbsp; So the object file emitted by the assembler is
    not a full executable program — or <i>load file</i> in this
    particular jargon — but rather just one of many object files which
    need to be <i>linked</i> by an AP-101 linker utility before
    becoming an executable program.<br>
    <h1><a name="macros"></a>Macro-Library Folders<br>
    </h1>
    AP-101 assembly language is a macro language.&nbsp; The Shuttle
    software developers made constant and frequent use of these macro
    capabilities, to the point where it's difficult even to find an
    AP-101 assembly-language file that is not dependent on macros.&nbsp;
    Thus, we have to understand various things about this macro
    capability from the very beginning, rather than concentrating merely
    on translation of AP-101 instructions into object code and leaving
    the topic of macros for future consideration.&nbsp; You can read
    about it for yourself in the IBM 360 assembler language manual,
    where <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/59/mode/1up?view=theater">macros







      occupy the entire 2nd half of that document</a>.&nbsp; Learning
    the syntax and other usage details of macros is as important for
    understanding the flight software, or perhaps even more important,
    and likely more difficult, than understanding the AP-101 instruction
    set.<br>
    <br>
    But I won't talk here about the technical details of macro
    definitions or expansions.&nbsp; Rather, here I merely need to talk
    about the organizational principles of the associated source-code
    files.<br>
    <p>When assembling an assembly-language file whose code depends on
      macros, there are three different ways in which the definitions of
      those macros may be made available to the code using them:<br>
    </p>
    <ol>
      <li>Macro definitions may explicitly appear within the
        assembly-language file in which they're used, in which case the
        scope of those macro definitions is that file alone.<br>
      </li>
      <li> Macro definitions may appear in a "macro library", and the
        macros defined in the library are accessible to any
        assembly-language file using that library.&nbsp; Speaking
        generally, the <a moz-do-not-send="true" href="HAL.html">HAL/S
          compiler</a>'s runtime library (which is written in AP-101
        assembly language) has a macro library known as RUNMAC, whereas
        the Shuttle flight software has a macro library known as
        MLIB80.&nbsp; But each release of the flight software has a
        version of MLIB80 specific to that release.</li>
      <li>Macro definitions may appear, along with non-macro code, in
        AP-101 assembly-language files "included" by other AP-101
        assembly-language files via an assembly-language pseudo-op
        called <font color="#663300"><code>COPY</code></font>.&nbsp; (<b>Note</b>:
        <a moz-do-not-send="true" href="#forbiddenCOPY"><font
            color="#663300"><code>COPY</code></font>'d files cannot
          contain macro definitions in System/360, but can do so in
          AP-101.</a>)<br>
      </li>
    </ol>
    <ul>
    </ul>
    In the current implementation of <b>ASM101S</b>, macro libraries
    are literally just folders of assembly-language files.&nbsp; Recall
    from the preceding section that <b>ASM101S</b> is invoked with one
    or more optional command-line arguments of the form <font
      color="#663300"><code>--library=<i>LIBRARY</i></code></font>.&nbsp;






    <font color="#663300"><code><i>LIBRARY</i></code></font> is just a
    path to a macro-library folder.&nbsp; Macro definitions in any
    libraries specified in this manner are loaded by the assembler along
    with the specific source-code file(s) being assembled, thus
    automatically making <i>all</i> of the macro definitions in that
    library available during the assembly process.<br>
    <br>
    Relative to where AP-101 assembly-language source code is stored in
    the source-code tree, <b>ASM101S</b> would typically be used with
    either the option <font color="#663300"><code>--library=../RUNMAC</code></font>
    or <font color="#663300"><code>--library=../MLIB80</code></font>,
    assuming the current working directory was the one storing the
    source-code files being assembled.<br>
    <br>
    There's a slight problem, though, in that for some reason, all of
    the assembly-language files includeable via <font color="#663300"><code>COPY</code></font>
    pseudo-ops are <i>also</i> located within the macro libraries,
    intermixed with the files intended to contain only macros.&nbsp; But
    we do not want any of the code from these <font color="#663300"><code>COPY</code></font>'able






    files (even if there are some macro definitions within them) to be
    automatically be made available during assembly.&nbsp; Rather, we
    want their code to be made available <i>only</i> when they're <font
      color="#663300"><code>COPY</code></font>'d!&nbsp; Or to put it
    differently, categories #2 and #3 of files containing macro
    definitions, as discussed above, must be mutually exclusive.<br>
    <br>
    It's unclear to my why the Shuttle developers chose to house these
    mutually-exclusive categories of files together in the same
    directory — or as they thought of it, the same "Partitioned Data
    Set" (PDS) —, nor how they handled this ambiguity in their
    assembler.&nbsp; As for <b>ASM101S</b>, though, it handles the
    ambiguity as follows:<br>
    <ul>
      <li>If a file in the macro library contains <i>only</i> macro
        definitions (and comments and blank lines), it is automatically
        loaded by the assembler (category #2).</li>
      <li>If a file in the macro library contains <i>anything other
          than</i> macro definitions (and comments), it is not
        automatically loaded, and can only be loaded via <font
          color="#663300"><code>COPY</code></font> (category #3).<br>
      </li>
    </ul>
    <p><b>ASM101S</b> does not attempt to determine these distinctions
      for itself.&nbsp; Rather, the files in the macro library (or
      libraries) must have been preprocessed in such a manner as to
      determine which of the two categories each file in the library
      falls into.&nbsp; Each macro library is assumed to contain a file
      called MACROFILES.txt containing this information, and <b>ASM101S</b>
      simply uses the categorization provided by MACROFILES.txt.&nbsp;
      The format of MACROFILES.txt is that it lists the names all of the
      macro-definition files, one per line.&nbsp; Full-line comments
      (having a semicolon in column 1) are also allowed.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; A utility program
          (makeMACROFILES.py)</font><font size="-1"><font size="-1"> is
            provided</font> to create MACROFILES.txt.&nbsp; Admittedly,
          insofar as legacy code related to Shuttle flight software is
          concerned, this is probably of little interest to you, the end
          user, since all such preprocessing is likely to have been
          performed prior to you seeing any of the assembly-language
          source-code files anyway.&nbsp; But if you do happen to
          acquire flight software or other AP-101 software from sources
          other than Virtual AGC — send it to me! — then I suppose you
          might need to do the preprocessing yourself.<br>
        </font></p>
    </blockquote>
    <h1><a name="Installation"></a>Installation of ASM101S</h1>
    <p>For Linux, Mac OS, or Windows.&nbsp; If the HAL/S compiler (<b>HALSFC</b>)
      has been installed <a moz-do-not-send="true"
        href="HAL.html#Installation">per the instructions</a>, then <b>ASM101S</b>
      will automatically be available as well.<br>
    </p>
    <p>If for some inexplicable reason you want to have <b>ASM101S</b>
      just for itself, without the HAL/S assembler (or any of the AP-101
      source-code files) provided by the normal installation, you could
      instead just download the file <a moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/master/ASM101S">ASM101S.py</a>.&nbsp;







      You simply need Python 3 to run it.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; If you choose the latter
          installation method, I can only assume that you already have
          some AP-101 source-code files that you want to assemble.&nbsp;
          You might consider sending them to me.</font><br>
      </p>
    </blockquote>
    <h1><a name="wildThings"></a>Where Are the AP-101 Assembly-Language
      Files?</h1>
    <ul>
      <li>HAL/S-FC runtime library:</li>
      <ul>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNASM">Source-code
            files</a><br>
        </li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNLST">"Assembly
            listings"</a> (see <a moz-do-not-send="true"
            href="#assemblyListings">here</a>)<br>
        </li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC">Macro
            library</a></li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/ZCONASM">Interface
            files</a><br>
        </li>
      </ul>
      <li>Shuttle FSW OI-30.17 (presently restricted, sorry!):</li>
      <ul>
        <li>Source-code files</li>
        <li>Assembly listings</li>
        <li>Macro library<br>
        </li>
      </ul>
      <li>Shuttle FSW OI-34.06 (presently restricted, sorry!):</li>
      <ul>
        <li>Source-code files</li>
        <li>Disassemblies<br>
        </li>
        <li>Macro library<br>
        </li>
      </ul>
    </ul>
    <h1><a name="Differences"></a>Potential Differences from
      Expectations</h1>
    <p>Given that the connection between the AP-101 assembly language
      and the System/360 assembly language is undocumented (in <i>surviving</i>
      documentation) and is based only upon my own inferences, it's not
      surprising that there are some discrepancies between theory and
      practice, or between what I've implemented in <b>ASM101S</b> vs
      what's documented for IBM 360 assembly language.&nbsp; I'll
      explain those differences in the subsections below.<br>
    </p>
    <h2><a name="assemblyListings"></a>Assembly Listings</h2>
    <p>By an "assembly listing", I mean a printout from the assembler
      itself, typically showing how each line of source code has been
      transformed into binary codes, and providing useful extra
      information such as symbol tables and other cross
      references.&nbsp; <br>
    </p>
    <p>Unfortunately, there are no surviving assembly listings produced
      by the AP-101S original assembler that I'm aware of, or even
      substantial fragments of such listings.&nbsp; (If you notice any,
      be sure to call my attention to them!)&nbsp; Therefore, without
      any of the original assembly listings to mimic, assembly listings
      as produced by <b>ASM101S</b> are unlikely to match those of the
      original assembler with exactitude .... though <i>of course</i> I
      expect the same binary codes to be produced at the same addresses,
      since if not, then the entire exercise of creating <b>ASM101S</b>
      in the first place would be pointless.&nbsp; But even if I had
      such original assembly listings, one wouldn't expect them to be
      any guide as to the wording or format of warning or error messages
      produced by the assembler, since any Space Shuttle flight software
      source code available for assembly presumably would be error-free,
      at least to the point that no warning or error messages are likely
      to appear in any assembly listings.<br>
    </p>
    <p>With that said, there is some assembly-listing-like material
      available.&nbsp; Among the files presently publicly visible, I
      refer to <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNLST">the
        folder called RUNLST in our source-code repository</a>, which
      naively appears to be assembly listings generated by assembling
      the files in <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNASM">the
        repository's RUNASM folder</a>.&nbsp; RUNASM contains the
      AP-101S assembly language source code, in conjunction with <a
        moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC">the
        macro library folder RUNMAC</a>, and assisted by <a
        moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/ZCONASM">the
        interface-file folder ZCONASM</a>, for the runtime library used
      with AP-101S object code created by the HAL/S compiler, <b>HAL/S-FC</b>.<br>
    </p>
    <p>Upon closer inspection, however, the contents of RUNLST cannot
      actually have been produced directly by the original AP-101S
      assembler.&nbsp; And similarly for materials not presently
      publicly visible.&nbsp; I assume, rather, that listings produced
      by the original assembler were stored somehow, probably in a
      so-called partitioned data set (PDS), and that the listings in
      RUNLST were produced by running some kind of report generator on
      those stored listings.&nbsp; Here's a fragment of the listing
      RUNLST/ACOS:<br>
    </p>
    <pre><font color="#663300">						.<br>						.<br>						.<br>				&nbsp;28 ACOS     AMAIN ACALL=YES                                                00002200<br>                                 29+***********************************************************************<br>                                 30+*<br>                                 31+*        PRIMARY ENTRY POINT<br>                                 32+*<br>                                 33+***********************************************************************<br>00000                            34+ACOS     CSECT                                                          01-AMAIN<br>00000                            35+STACK    DSECT                                                          01-AMAIN<br>                                 36+*        DS    18H            STANDARD STACK AREA DEFINITION<br>00000                            37+         DS    F              PSW (LEFT HALF)                           01-AMAIN<br>00002                            38+         DS    2F             R0,R1                                     01-AMAIN<br>00006                            39+ARG2     DS    F              R2                                        01-AMAIN<br>00008                            40+         DS    F              R3                                        01-AMAIN<br>0000A                            41+ARG4     DS    F              R4                                        01-AMAIN<br>0000C                            42+ARG5     DS    F              R5                                        01-AMAIN<br>0000E                            43+ARG6     DS    F              R6                                        01-AMAIN<br>00010                            44+ARG7     DS    F              R7                                        01-AMAIN<br>                                 45+*        END OF STANDARD STACK AREA<br>00012                            46+SAVE6    DS    D              TO SAVE REGISTERS F6,F7                   02-00025<br>00016                            47+SWITCH   DS    F              TO SAVE R4 ACROSS INTRINSIC CALL          02-00026<br>00018                            48+STACKEND DS    0F             END OF COMBINED STACK AREA                01-AMAIN<br>00000                            49+ACOS     CSECT                                                          01-AMAIN<br>0000000                          50+         USING STACK,0        ADDRESS STACK AREA                        01-AMAIN<br>00000 E0FB 0018      0018        51+         IAL   0,STACKEND-STACK SET STACK SIZE                          01-AMAIN<br>00002 B624 0000      0009 0000   52+         NIST  9(0),0         CLEAR ON ERROR INFO (LCL DATA PTR)        01-AMAIN<br>                                 54 *COMPUTES ARC-COSINE(X) OF SINGLE PRECISION SCALAR                      00002300<br>                                 55          INPUT F0             SCALAR SP                                 00002400<br>0000000                          56+F0       EQU   0                                                        01-INPUT<br>                                 58          OUTPUT F0            SCALAR SP RADIANS                         00002500<br>						.<br>						.<br>						.</font><br></pre>
    <p>To anybody who is familiar with assembly language, this certainly
      <i>looks</i> like an assembly listing produced by an assembler, so
      why do I say that it's not?&nbsp; The first clue is the line
      numbering:&nbsp; There's a line 52 and a line 54, but no line
      53.&nbsp; And there are lines 56 and 58, but no line 57.&nbsp;
      Admittedly, it's not 100% certain why that is, but having tried to
      track it down, it appears to me that both of those gaps correspond
      to uses of the <font color="#663300"><code>SPACE</code></font>
      pseudo-op appearing in expansions of the <font color="#663300"><code>AMAIN</code></font>
      and <font color="#663300"><code>INPUT</code></font> macros
      respectively.&nbsp; <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/52/mode/1up?view=theater">According
        to the assembly-language manual</a>, "The SPACE instruction is
      used to insert one or more blank lines in the listing."&nbsp;
      Which is clearly <i>not</i> what has happened, and indeed is the
      opposite of what has happened.<br>
    </p>
    <p>Another clue, not apparent from the fragment above, is in the
      number of lines per page of the printout.&nbsp; Originally, an
      assembly listing would have been output to a line printer having
      (nominally) ~55 lines per page.&nbsp; Whereas the file in RUNLST
      have about 80 lines per page.&nbsp; Ergo, RUNLST does not provide
      an unchanged copy of the original listing.&nbsp; Nor are there any
      embedded form-feed characters or other means to advance to the top
      of the next page before a page heading is printed.<br>
    </p>
    <p>Still, the files of RUNLST are the best guide available as to the
      format of assembly listings, and hence <b>ASM101S</b> mimics that
      format to the extent feasible (i.e., to the extent not too
      pathetically obsessive), plus the addition of form-feed characters
      to signal page breaks.<br>
    </p>
    <p>When I refer later on to "existing assembly listings", keep in
      mind that I'm referring to these files from RUNLST and not to
      actual original assembly listings.<br>
    </p>
    <p> </p>
    <h2><a name="CharacterSet"></a>Character Set</h2>
    <p><img moz-do-not-send="true" src="encodingDEU.png" alt=""
        width="638" height="468" align="right">The AP-101 character set
      does not match that of the System/360 assembler.&nbsp; The latter
      is the EBCDIC character set, or rather the variation of EBCDIC
      listed in Appendix A, but with only a subset of those used outside
      of quoted strings or comments.<br>
    </p>
    <p>As far as I can tell, the AP-101 assembly-language character set
      is not defined.&nbsp; There is some confusion regarding how
      character data is character data is supposed to be encoded in
      object files.<br>
    </p>
    <p>Examining character strings appearing in object files output by
      the HAL/S compiler <b>HAL/S-FC</b>, which one would suppose
      should be consistent with AP-101S assembly language, you find that
      text is encoded per the Space Shuttle's Display Electronics Unit
      (DEU).<br>
    </p>
    <p>The DEU character set is depicted in the table to the
      right.&nbsp; It is an ASCII-like character set, in the sense that
      almost wherever the printable characters or control codes overlap
      with printable ASCII characters or control codes, the numerical
      encoding matches.&nbsp; <br>
    </p>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; The overlaps with
        ASCII are:<br>
      </font>
      <blockquote><font size="-1">NULL<br>
          BACKSPACE<br>
          CARRIAGE RETURN<br>
          SPACE<br>
          Digits<br>
          Alphabetic letters<br>
          ! ~ # % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? |<br>
        </font></blockquote>
      <font size="-1">The mismatches with ASCII (i.e., the characters
        with differing numerical codes) are: <br>
      </font>
      <blockquote><font size="-1">&nbsp;_ [ ] ~ "</font><br>
      </blockquote>
    </blockquote>
    <blockquote> <font size="-1"><b>Aside:</b>&nbsp; <i>One</i>
        character, the ASCII back-tick (`), also appears in the Space
        Shuttle flight-software assembly-language source code available
        to us (well, to me anyway), in spite of being absent from the
        DEU and EBCDIC character sets.&nbsp; Though only the comments of
        in <i>two</i> lines of code.&nbsp; This was apparently done
        just to spite me!&nbsp; (I jest.&nbsp; It appears to have been
        done to mark a section of code so that it could be easily found
        later.)</font><br>
    </blockquote>
    <b>But wait!</b>&nbsp; In AP-101S assembly language, constant
    character data (and constant data of any other type as well) is
    stored in memory via the pseudo-op called <font color="#663300"><code>DC</code></font>.&nbsp;
    For example, to store the character data "PC" into memory at the
    current assembly location, you might employ the assembly language<br>
    <blockquote>
      <pre><font color="#663300">DC      C'PC'</font><br></pre>
    </blockquote>
    While we have assembly listings for only a limited selection of
    AP-101S source code, we do have some.&nbsp; Here's how a line such
    as the one above assembles:<br>
    <pre><font color="#663300"> 001C9 <font color="#ff0000">D7C3</font>                      964+         DC    C'PC'                                                    01-GENER       FCMCBLKS<br></font></pre>
    The part shown in red are what is supposedly stored in memory for
    "PC", those are the EBCDIC codes for the characters "P" and
    "C".&nbsp; Thus ultimately, it remains unclear as to whether it is
    the DEU encoding or the EBCDIC encoding which appears in the object
    files produced.<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
        In case you assume it's impossible that EBCDIC encoding would be
        shown on the assembly listing but that DEU encoding would occur
        in the object files, note that the assembly listings produced by
        IBM Federal Services Division's <a moz-do-not-send="true"
          href="LVDC.html">LVDC</a> assembler, at least in some
        versions, had somewhat analogous bugs for constant character
        data.&nbsp; In that case, constant character data was stored
        into memory at assembly time by a pseudo-op called <font
          color="#663300"><code>BCI</code></font> (rather than <font
          color="#663300"><code>DC</code></font>), and even though the
        object code created by the assembler must have had the correct
        character data, the character data as displayed on the assembly
        listings themselves was garbage, seemingly due to some mismatch
        between the various character sets involved.&nbsp; In creating <a
          moz-do-not-send="true"
          href="https://github.com/virtualagc/virtualagc/tree/master/yaASM.py">the
          "modern" LVDC assembler</a>, I found it difficult to decide
        whether to reproduce the original bug (thus continuing to print
        garbage in the assembly listings) or else to fix the bug (to
        make the assembly listings look right but to differ from the
        surviving printouts of assembly listings).&nbsp; Ultimately, I
        added a command-line switch (<font color="#663300"><code>--past-bugs</code></font>)
        to allow the user to make the choice for themselves as to
        whether to override the original bug.&nbsp; But the LVDC
        assembler is unrelated to the AP-101S assembler, and there's no
        reason at all to suppose that a bug in one would somehow carry
        over into the other.&nbsp; Nevertheless, it's a good
        illustration of the danger associated with assuming that just
        because these tools were used regularly, for a long time, that
        they were necessarily free of bugs, particularly insofar as a
        non-critical item like the assembly listing is concerned.</font><br>
    </blockquote>
    Beyond these characters, any Space Shuttle flight-software source
    code available from Virtual AGC will have been "anonymized" by
    replacing personal names or initials with randomized identifiers
    beginning with either the ASCII carat (^) or backslash (\)
    characters, and thus either of these characters may appear in such
    source code even though not in either the DEU or EBCDIC character
    sets.<br>
    <br>
    Finally, the reason I'm making a big deal of this is that for
    technical reasons, <b>ASM101S</b> wants to reserve some ASCII
    character absent from the DEU and EBCDIC character sets to represent
    breaks between punch-cards and their continuation cards (if
    any).&nbsp; The ASCII brace characters { and } meet these
    criteria.&nbsp; Therefore, <b>ASM101S</b> reserves them for its own
    internal purposes, and they should not be used in any newly-written
    AP-101 assembly-language source code, if such a thing ever
    exists.&nbsp; They is not used in any extant AP-101
    assembly-language source code available to me.<br>
    <h2><a name="instructionAliases"></a>Instruction Aliases</h2>
    <p>In IBM 360 Basic Assembly Language (BAL), various aliases exist
      for the branch instructions <font color="#663300"><code>BCR</code></font>
      and <font color="#663300"><code>BC</code></font><code></code><font
        color="#663300"><code></code></font>.&nbsp; These are described
      in <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/33/mode/1up?view=theater">Figure







        4-1 of the assembler-language manual</a>.&nbsp; While it is
      tempting to say that Figure 4-1 should be accepted as-is for
      AP-101S assembly language, that's unfortunately impossible:&nbsp;
      Conditional-branch instructions encode a "mask" to be applied to
      the CPU's condition codes, but the mask is 4 bits wide for
      System/360 and only 3 bits wide for AP-101S.<br>
    </p>
    <p>Something has to give!&nbsp; But Figure 4-1 does serve as a
      starting point for reverse-engineering AP-101 aliases for
      conditional-branch instructions.&nbsp; Here's my own list of
      AP-101S mnemonics for aliased branch instructions, grouped by
      condition-code mask.<br>
    </p>
    <ol start="0">
      <li><font color="#663300"><code>NOP</code></font>,<font
          color="#663300"><code>NOPR</code></font> — No Operation.<br>
      </li>
      <li><font color="#663300"><code>BH</code></font>,<font
          color="#663300"><code>BO</code></font>,<font color="#663300"><code><font
              color="#663300"><code>BP</code></font> </code></font>—
        Branch on High, Branch on Overflow, Branch on Plus</li>
      <li><font color="#663300"><code>BL</code></font>,<font
          color="#663300"><code>BM</code></font>,<font color="#663300"><code>BN</code></font>
        — Branch on Low, Branch on Minus, Branch on Negative</li>
      <li><font color="#663300"><code>BNE</code></font>,<font
          color="#663300"><code>BNZ</code></font> — Branch on Not Equal,
        Branch on Not Zero</li>
      <li><font color="#663300"><code>BE,BZ</code></font> — Branch on
        Equal, Branch on Zero<br>
      </li>
      <li><font color="#663300"><code>BNL,</code></font><font
          color="#663300"><code></code></font><font color="#663300"><code>BNM</code></font>
        — Branch on Not Low, Branch on Not Minus</li>
      <li><font color="#663300"><code>BNH</code></font>,<font
          color="#663300"><code>BNP</code></font>,<font color="#663300"><code>BLE</code></font>,<font
          color="#663300"><code>BNO</code></font> — Branch on Not High,
        Branch on Not Plus, Branch on Less-or-Equal, Branch on Not
        Overflow<br>
      </li>
      <li><font color="#663300"><code>B</code></font>,<font
          color="#663300"><code>BR</code></font> — Unconditional Branch<br>
      </li>
    </ol>
    <blockquote><font size="-1"><b>Note:</b>&nbsp; While the mnemonics
        and condition masks in the list above are accurate (I hope!),
        but textual descriptions are less certain and should be taken
        with a grain of salt.&nbsp; Corrections are welcome!<br>
        <br>
        <b>Aside:</b>&nbsp; The original Figure 4-1 explained how each
        alias corresponded specifically to <font color="#663300"><code>BCR</code></font>
        or (much-more commonly) <font color="#663300"><code>BC</code></font><code></code><font
          color="#663300"><code></code></font> instructions, but I've
        skipped that explanation here.&nbsp; (Look at the file
        model101.py of the ASM101S source code if you're
        interested.)&nbsp; Partly that's because it's unlikely to be of
        interest, but also because it's far more complicated for AP-101S
        than for System/360:&nbsp; For example, mnemonic alias like <font
          color="#663300"><code>BNP</code></font> might be coded as a <font
          color="#663300"><code>BC</code></font> instruction under some
        circumstances, as a <font color="#663300"><code>BCB</code></font>
        instruction in other circumstances, or as a <font
          color="#663300"><code>BCF</code></font> instruction under
        still other circumstances.</font><br>
    </blockquote>
    <ul>
    </ul>
    <p><font color="#663300"><code>LHI</code></font>:&nbsp; Besides the
      branch-instruction aliases, Shuttle flight-software code uses the
      operator <font color="#663300"><code>LHI</code></font>, but
      without any AP-101 instruction or any macro definition
      corresponding to it.&nbsp; There is such an instruction in IBM 360
      assembly language.&nbsp; <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=79">The






        AP-101S POO notes</a> in its discussion of the <font
        color="#663300"><code>LA</code></font> instruction that there is
      a particular configuration of operands for which <font
        color="#663300"><code>LA</code></font> will be "functionally
      equivalent to a LOAD HALFWORD IMMEDIATE instruction".&nbsp; My
      guess is that the original assembler therefore accepted the
      mnemonic <font color="#663300"><code>LHI</code></font> but
      silently transformed it in the appropriate <font color="#663300"><code>LA</code></font>
      instruction.&nbsp; <b>ASM101S</b> treats it in that manner as
      well.<br>
    </p>
    <p><font color="#663300"><code>SHI</code></font>:&nbsp; Similarly,
      flight software uses the non-existent <font color="#663300"><code>SHI</code></font>
      instruction.&nbsp; The program comment at those points clearly
      indicate that this is a kind of subtract-immediate instruction,
      presumably Subtract Halfword Immediate.&nbsp; Unlike the case of <font
        color="#663300"><code>LHI</code></font>, there is no
      corresponding <font color="#663300"><code>SHI</code></font>
      instruction for System 360.&nbsp; Nevertheless, we might suppose
      that the case is still similar, in that this could be an alias for
      (perhaps) a particular configuration of operands for some other
      AP-101 instruction.&nbsp; Fortunately, we have plenty of examples
      of assembly listings for code using <font color="#663300"><code>SHI</code></font>.&nbsp;






      Consider this example:<br>
    </p>
    <blockquote>
      <pre>B0E5  FFFE                   SHI    R5,2<br></pre>
    </blockquote>
    <p>The value 0xFFFE is a halfword with the value -2, which leaves us
      to suspect that this is actually an addition.&nbsp; There is
      indeed an <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=66">Add






        Halfword Immediate</a> instruction (<font color="#663300"><code>AHI</code></font>),






      and "<font color="#663300"><code>AHI R5,-2</code></font>" would
      indeed assemble as shown.<br>
    </p>
    <p><font color="#663300"><code>LACR</code></font>:&nbsp; There is no
      corresponding System/360 instruction to guide our thinking.&nbsp;
      However, there are lots of examples in AP-101 assembly listings,
      such as those for the CTOI.txt file of the HAL/S-FC runtime
      library.&nbsp; <font color="#663300"><code>LACR</code></font> is
      seen to be a register-to-register operation.&nbsp; For (say)
      general-registers <i>N</i> and <i>M</i>, it assembles to the bit
      pattern 11101<i>nnn</i> 11101<i>mmm</i>.&nbsp; This is the same
      pattern that the LOAD ARITHMETIC COMPLEMENT (<font color="#663300"><code>LCR</code></font>)
      instruction assembles to.&nbsp; Therefore, <font color="#663300"><code>LACR</code></font>
      is nothing more than a synonym for <font color="#663300"><code>LCR</code></font>.<br>
    </p>
    <p><font color="#663300"><code>PC</code></font>:&nbsp; Similarly,
      this undocumented instruction is found from available assembly
      listings to assembly as a synonym for <font color="#663300"><code>MVH</code></font>
      (move halfword).&nbsp; There's no rationale obvious to me for the
      specific mnemonic "PC" for this operation.<br>
    </p>
    <ul>
    </ul>
    <h2>Unused Pseudo-ops</h2>
    <p>Not all pseudo-ops described in the System/360 assembler manual
      appear in surviving AP-101 assembly-language source code.&nbsp;
      I've chosen to believe that rather than the omissions being
      coincidental, those pseudo-ops are instead specific to System/360
      and thus had been entirely omitted from AP-101
      assembly-language.&nbsp; Admittedly, that inference is probably
      wrong in the case of certain of the pseudo-ops.&nbsp;
      Nevertheless, they have not been implemented in <b>ASM101S</b>.&nbsp;







      <br>
    </p>
    <p>The omitted pseudo-ops are:<br>
    </p>
    <ul>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/49/mode/1up?view=theater">CCW</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/27/mode/1up?view=theater">COM</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/26/mode/1up?view=theater">CXD</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/26/mode/1up?view=theater">DXD</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/53/mode/1up?view=theater">ICTL</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/54/mode/1up?view=theater">ISEQ</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/36/mode/1up?view=theater">OPSYN</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/n36/mode/1up?view=theater">WXTRN</a><br>
      </li>
    </ul>
    <ul>
    </ul>
    <ol start="4">
    </ol>
    <p> </p>
    <ul>
    </ul>
    <p> </p>
    Obviously, this list is subject to change, if legacy AP-101
    assembly-language source code using any of these pseudo-ops is
    discovered.<br>
    <h2>Mystery Pseudo-ops</h2>
    <p>The <font color="#663300"><code>SPOFF</code></font> and <font
        color="#663300"><code>SPON</code></font> pseudo-ops — if they <i>are</i>
      pseudo-ops — seem typically to be used in pairs:&nbsp; <font
        color="#663300"><code>SPOFF</code></font> is used to disable
      something unknown, then an instruction or two later, <font
        color="#663300"><code>SPON</code></font> is used to re-enable
      whatever it was that <font color="#663300"><code>SPOFF</code></font>
      disabled.&nbsp; They are not pseudo-ops in IBM 360 assembly
      language, and hence must be specific to AP-101S.<br>
    </p>
    <p>Fortunately, we have a few contemporary assembly listings in
      which these pseudo-ops appear in the source code, and thus their
      effect can be observed somewhat.&nbsp; They do not generate any
      binary, hence they are definitely not instructions of any
      kind.&nbsp; Furthermore, they do not affect whether or not the
      source code they enclose is assembled, nor whether that source
      code appears in the assembly listing.<br>
    </p>
    <p>I would tentatively conclude that at least for the moment they
      can simply be ignored, and that's what <b>ASM101S</b> does with
      them for now.<br>
    </p>
    <h2><a name="forbiddenCOPY"></a>Forbidden Pseudo-Ops in <font
        color="#663300"><code>COPY</code></font>'d Files</h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/57/mode/1up?view=theater">The






        System/360 assembler manual tells us</a> that assembly-language
      files included in other assembly-language files via the <font
        color="#663300"><code>COPY</code></font> pseudo-op cannot
      contain various other pseudo-ops, two of which are <font
        color="#663300"><code>MACRO</code></font> and <font
        color="#663300"><code>MEND</code></font>.&nbsp; That implies
      that a <font color="#663300"><code>COPY</code></font>'d file
      cannot contain any macro definitions.&nbsp; Nevertheless, Space
      Shuttle flight software has file inclusions that violate this
      restriction.&nbsp; Specifically, the files MLIB80/MACSMITH.asm and
      MLIB80/MACROS.asm do contain macro definitions, and yet are
      themselves <font color="#663300"><code>COPY</code></font>'d into
      other assembly-language files.&nbsp; Consequently, this
      restriction (at least insofar as <font color="#663300"><code>MACRO</code></font>
      and <font color="#663300"><code>MEND</code></font> are concerned)
      does not apply in AP-101 assembly-language.<br>
    </p>
    <h2>Macro-Definition Prototypes</h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/65/mode/1up?view=theater">The






        assembler manual tells us</a> that <br>
    </p>
    <blockquote>"The macro instruction prototype statement (hereafter
      called the prototype statement) specifies the mnemonic operation
      code and the format of all macro instructions that refer to the
      macro definition. It must be the second statement of every macro
      definition."<br>
    </blockquote>
    For example, in a macro definition such as<br>
    <blockquote>
      <pre><font color="#663300">         MACRO<br>         MYMACRO   &amp;ARG1,&amp;ARG2<br>         .<br>         .<br>         .<br>         MEND</font><br></pre>
    </blockquote>
    no other statements must appear between the first two lines shown
    here.&nbsp; <br>
    <br>
    In contradiction to the claim in the manual, though, there are
    instands in flight-software code in which there are comments between
    these lines, as in<br>
    <blockquote>
      <pre><font color="#663300">         MACRO<br>.* THIS IS A COMMENT<br>.* THIS IS ANOTHER COMMENT<br>         .<br>         .<br>         .<br>.* THERE WERE  A WHOLE LOT OF COMMENTS, SEE?<br>         MYMACRO   &amp;ARG1,&amp;ARG2<br>         .<br>         .<br>         .<br>         MEND</font><br></pre>
    </blockquote>
    I guess we'd infer from this, and very reasonably, that comments are
    not "statements", but more importantly, that the macro prototype is
    not necessarily the second line in a macro definition.<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;




        I don't know if anybody will read these words, ever, but my
        sixth sense tells me that some folks who do might be smugly
        saying to themselves right now that "<i>of course</i> full-line
        comments are not 'statements' in any language, so what's this
        fool on about?"&nbsp; As it happens, <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/69/mode/1up?view=theater">on




          p. 69 of the assembler manual</a>, we find a section actually
        entitled "Comments Statements", which proceeds to define the
        term <i>comments statement</i> as being precisely the thing
        we're discussing right now.&nbsp;
        <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo></mo></mrow><annotation
              encoding="TeX">&lt;img src="smiley.png"&gt;</annotation></semantics></math></font><br>
    </blockquote>
    <h2>Silly Suffixes</h2>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
          AP-101 CPU instructions fall into 5 categories, depending on
          the pattern of operands they accept.&nbsp; These 5 categories
          are designated RR, RS, SRS, SI, and RI.&nbsp; The differences
          between these relate to the number of operands and the means
          of addressing them, but the specifics aren't important for our
          discussion here.</font><br>
      </p>
    </blockquote>
    <p>All AP-101 CPU instructions of type RS can optionally have
      suffixes "@", "#", or "@#" added to their mnemonics.&nbsp; For
      example, just as there is an <font color="#663300"><code>SCAL</code></font>
      instruction of type RS, there are also <font color="#663300"><code>SCAL@</code></font>,
      <font color="#663300"><code>SCAL#</code></font>, and <font
        color="#663300"><code>SCAL@#</code></font> instructions of type
      RS.<br>
    </p>
    <p>To be picky about it, this usage is indeed documented, but it
      took me so long to figure out that I thought I should take
      explicit notice of it here anyway.<br>
    </p>
    <p><a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=63">The






        AP-101S POO tells us</a> that <br>
    </p>
    <blockquote>
      <p>"... [@] [#] indicates that the use of indirect addressing
        and/or autoindexing is optional.&nbsp; For example, [instruction
        mnemonic] <font color="#663300"><code>M</code></font> specifies
        direct addressing without autoindexing, while <font
          color="#663300"><code>M#</code></font> specifies direct
        addressing with autoindexing."<br>
      </p>
    </blockquote>
    And in case it's not obvious to you what the POO means by "indirect
    addressing" and/or "autoindexing", there is much greater detail in <a
      moz-do-not-send="true"
      href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=39">the
      POO's explanation of RS type instructions</a>.&nbsp; <br>
    <h2>Mystery Instructions or Macros</h2>
    The following operators appear in flight software source code, and I
    am so far unable to determine if they are supposed to be
    instructions, macros, or pseudo-ops:<br>
    <ul>
      <li><font color="#663300"><code>LB</code></font> is used in the
        same manner as the instruction <font color="#663300"><code>LA</code></font>
        (load address), but it is a mystery what it signifies.&nbsp; I
        presently have no examples of assembly listings containing it
        from which I can deduce anything.&nbsp; One possibility is that
        it's simply an error&nbsp; never detected during Shuttle
        software development because the only known usage is in the
        definition of a macro (<font color="#663300"><code>LD</code></font>)
        which in fact is never invoked by any of the other source
        code.&nbsp; In other words, perhaps <b>ASM101S</b> shouldn't
        have been getting uppity by trying to parse that macro in the
        first place!</li>
      <li>AREAD</li>
      <li>BC$</li>
      <li>STH$<br>
      </li>
    </ul>
    <h2><a name="Implementation"></a>Syntax of Various Fields<br>
    </h2>
    Recall that the four fields potentially present in a line of
    assembly language (whether instructions, pseudo-ops, macro
    invocations, etc.) are the <i>name</i> field (beginning in column
    1), the <i>operation</i> field, the <i>operand</i> field, and the
    <i>comment</i> field.&nbsp; It turns out that parsing these fields
    is quite tricky, particularly the operand field.&nbsp; <br>
    <br>
    I won't bore you with the details as to why this is so, but simply
    say that except for the comment field, each of these fields has been
    given its own simple BNF-style grammar in <b>ASM101S</b>, and
    usually multiple separate grammars that are applied for different
    contexts.&nbsp; This is, of course, transparent to the user of <b>ASM101S</b>,
    and is only significant to someone wishing to maintain the
    assembler.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; "BNF", of course,
        stands for <a moz-do-not-send="true"
          href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur


          form</a>.&nbsp; Technically, the grammars are actually written
        in the modified EBNF (<a moz-do-not-send="true"
          href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended


          Backus-Naur form</a>) supported by <a moz-do-not-send="true"
          href="https://tatsu.readthedocs.io/en/stable/">the TatSu
          parser module for the Python language</a>.&nbsp; See the
        Python source-code file <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/ASM101S/fieldParser.py">fieldParser.py</a>
        for the grammars themselves.</font><br>
    </blockquote>
    Nevertheless, even having adding this level of complexity to the
    parser, it's not necessarily the case that the syntax parsed by <b>ASM101S</b>
    matches that parsed by the original assembler.&nbsp; For example,
    arithmetic expressions as specified by the System/360
    assembly-language manual are constrained in various ways — e.g.,
    cannot begin with '+' or '-', cannot have have more than 16 terms,
    cannot have more than 5 levels of parentheses —, but have not been
    endowed with the same constraints in <b>ASM101S</b>.&nbsp; On the
    other hand, I haven't necessarily bothered to implement
    theoretically-possible syntax that isn't present in actual flight
    software.&nbsp; Consequently, it's likely that <b>ASM101S</b>
    accepts a more-complex syntax in some contexts than did the original
    assembler, and vice-versa.&nbsp; Or course, <b>ASM101S</b> can be
    upgraded as needed to support such missing syntax, if it turns out
    to be desirable, whereas the original assembler cannot.<br>
    <h2>EQU and CPU Registers</h2>
    <p>The AP-101 CPU has 8 general registers, typically referred to
      symbolically in assembly language as <font color="#663300"><code>R0</code></font>
      through <font color="#663300"><code>R7</code></font>, as well as
      8 floating-point registers, typically referred to as <font
        color="#663300"><code>F0</code></font> through <font
        color="#663300"><code>F7</code></font>.&nbsp; This is the same
      situation as in System/360 assembly language, except that in
      System/360 there are more of each kind of register.&nbsp; For
      example, an assembly-language instruction that performs an integer
      addition from register <font color="#663300"><code>R7</code></font>
      to register <font color="#663300"><code>R3</code></font> would
      look like this in either of the two assembly languages:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">AR	R3,R7</font><br></pre>
    </blockquote>
    But there's a catch.&nbsp; The assembly-language manual <a
      moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/31">explains</a>
    that<br>
    <blockquote><font size="-1">"All symbols that specify register
        numbers ... must be assumed to be equated elsewhere to absolute
        values."</font><br>
    </blockquote>
    In other words, the register-name symbols <font color="#663300"><code>R3</code></font>
    and <font color="#663300"><code>R7</code></font> in this example
    are <i>not</i> tokens or syntactical elements of the assembly
    language, and the pure syntax for the instruction example shown
    above should actually be this:<br>
    <blockquote>
      <pre><font color="#663300">AR	3,7</font><br></pre>
    </blockquote>
    The only reason that the former instruction would be accepted by the
    assembler, the manual is explaining, is that the full example should
    have read something like this:<br>
    <blockquote>
      <pre><font color="#663300">R3      EQU     3<br>R7      EQU     7<br>	.<br>	.<br>	.<br>&nbsp;       AR      R3,R7</font></pre>
    </blockquote>
    In turn, this means that in <a moz-do-not-send="true"
      href="#macros">the macro libraries loaded by the assembler</a>, we
    should should find various <font color="#663300"><code>EQU</code></font>ates


    similar to the ones above, for the general registers and
    floating-point registers.&nbsp; And indeed, for the macro libraries
    used for the Space Shuttle primary flight software (PASS), and
    backup flight software (BFS), we find exactly such declarations in
    the PASS module MLIB80/MACSMITH or the BFS module MLIB80/EQU, along
    with numerous other <font color="#663300"><code>EQU</code></font>ates


    of a similar nature:<br>
    <blockquote>
      <pre><font color="#663300">         .<br>         .<br>         .<br>F0       EQU   0              FP 0 = FLOATING POINT REGISTER            <br>F1       EQU   1                 1                                      <br>F2       EQU   2                 2                                      <br>F3       EQU   3                 3                                      <br>F4       EQU   4                 4                                      <br>F5       EQU   5                 5                                      <br>F6       EQU   6                 6                                      <br>F7       EQU   7                 7                                      <br>G0       EQU   0   SET 1      GR 0 = GENERAL REGISTER                   <br>G1       EQU   1                 1                                      <br>G2       EQU   2                 2                                      <br>G3       EQU   3                 3                                      <br>G4       EQU   4                 4                                      <br>G5       EQU   5                 5                                      <br>G6       EQU   6                 6                                      <br>G7       EQU   7                 7                                      <br>R0       EQU   0   SET 2      GR 0 = GENERAL REGISTER                   <br>R1       EQU   1                 1                                      <br>R2       EQU   2                 2                                      <br>R3       EQU   3                 3                                      <br>R4       EQU   4                 4                                      <br>R5       EQU   5                 5                                      <br>R6       EQU   6                 6                                      <br>R7       EQU   7                 7                                      <br>         .<br>         .<br>         .</font>    <br></pre>
    </blockquote>
    Unfortunately, that's not the full story.&nbsp; Besides the flight
    software as such, AP-101 assembly-language files also exists in the
    runtime library provided by <b>HAL/S-FC</b>, the HAL/S
    compiler.&nbsp; Those assembly-language files reference the CPU
    general registers and floating-point registers just as any of the
    flight-software files do, except that <i>there are no </i><i><font
        color="#663300"><code>EQU</code></font></i><i>ates for those
      registers</i> in any of those source-code files, nor in the macro
    library used by those files.<br>
    <br>
    It is, of course, possible that the reason these <font
      color="#663300"><code>EQU</code></font>ates are missing is that
    our <b>HAL/S-FC</b> runtime-library source code is
    incomplete.&nbsp; Unfortunately, there is no way to know whether
    that is correct or not.&nbsp; Another possibility is that the
    System/360 assembly-language manual is incorrect, and that the
    assembler <i>does</i> by default recognize the general registers <font
      color="#663300"><code>R<i>n</i></code></font> and float-point
    registers <font color="#663300"><code>F</code><code><i>n</i></code></font>,
    and possibly other symbols, without explicit <font color="#663300"><code>EQU</code></font>ates.<br>
    <br>
    Lacking any palatable alternatives here, <b>ASM101S</b> assigns
    default values to the various register symbols, but allows those
    defaults to be overridden by explicit <font color="#663300"><code>EQU</code></font>ates,


    if such are encountered.<br>
    <h2>Type Attributes, <code>T'</code></h2>
    <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/77/mode/1up">The

      System/360 assembly-language manual</a> tells us prefixing a
    symbolic variable (such as <font color="#663300"><code>&amp;A</code></font>)
    with the notation <font color="#663300"><code>T'</code></font>
    returns an assembly-time string consisting of a single character
    that corresponds to the type of data the variable contains.&nbsp;
    For example, if <font color="#663300"><code>&amp;A</code></font>
    were a character-string variable as declared via the <font
      color="#663300"><code>GBLC</code></font> or <font color="#663300"><code>LCLC</code></font>
    pseudo-op, then the assembler's preprocessor would replace <font
      color="#663300"><code>T'&amp;A</code></font> by the single
    character <font color="#663300"><code>C</code></font> at
    assembly-time.<br>
    <br>
    The manual lists 27 such "types", corresponding to the "letters" A-Z
    and $.&nbsp; (In the worldview of the assembler, 29 characters are
    defined as being "letters":&nbsp; A through Z, #, $, and @.)&nbsp;
    But it isn't clear at the present time how many of these types will
    be supported in <b>ASM101S</b>, since only the following seem to
    appear in actual flight-software source code:<br>
    <ul>
      <li>C — character constant</li>
      <li>N — self-defining term<br>
      </li>
      <li>O — omitted operand<br>
      </li>
      <li># — (not mentioned in the manual)</li>
    </ul>
    <p>It isn't entirely clear to me what # indicates.&nbsp; My current
      <i>very tentative</i> interpretation is this:<br>
    </p>
    <ul>
      <li>If applied to the formal parameter of a macro, it means that
        the formal parameter is a position-dependent
        parameter.&nbsp;&nbsp; I.e., that it is not a named parameter.</li>
      <li>If applied to a character-string variable, the variable is
        assumed to contain the name of a formal parameter of a macro,
        and the formal parameter is position-dependent.</li>
    </ul>
    <h2><a name="definedAttribute"></a>The <code>D'</code> Attribute</h2>
    <p>AP-101S assembly-language source code uses an attribute operator
      <font color="#663300"><code>D'</code></font>, which is not defined
      in the assembly-language manual.&nbsp; From the way it is used, I
      infer when applied to an identifier, it returns "true" (1) if the
      identifier has been previously defined within the source-code
      being assembled and "false" (0) if not.&nbsp; A typical usage
      would be something like <br>
    </p>
    <blockquote>
      <pre>	<font color="#663300">AIF     (D'MYSYM).OKAY<br>	EXTRN	MYSYM<br>OKAY    ...</font><br></pre>
    </blockquote>
    <p>Thus if the identifier is not defined, it allows the code to
      detect that condition and to mark the identifier as being declared
      externally.<br>
    </p>
    <ul>
    </ul>
    <h2><code>AIF</code> and <code>AGO<br>
      </code><code></code></h2>
    The <font color="#663300"><code>AIF</code></font> and <font
      color="#663300"><code>AGO</code></font> pseudo-ops provide "goto"
    functionality (respectively conditionally or unconditionally) at
    assembly time (rather than at runtime).&nbsp; <a
      moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/88/mode/1up">The

      System/360 assembly-language manual</a> makes it clear that these
    "goto" operations can operate only with the same macro depth, and
    further, if within a macro, only within the <i>same</i>
    macro.&nbsp; For example, in the "pseudo-instruction" <br>
    <blockquote>
      <pre><font color="#663300"><code>AGO .MYSEQ</code></font> </pre>
    </blockquote>
    the locations of the pseudo-instruction itself and of the sequence
    symbol <font color="#663300"><code>.MYSEQ</code></font> could be
    both outside of any macro, or they could be within the same macro
    definition.&nbsp; But it could <i>not</i> be the case (say) that
    the pseudo-instruction was within a macro definition and the
    sequence symbol was within a macro invoked by that macro.<br>
    <br>
    One important case about which the assembly-language manual says
    nothing, I think, is the case in which a source-code file is being
    imported via a <font color="#663300"><code>COPY</code></font>
    pseudo-op.&nbsp;&nbsp; Is it possible for the <font color="#663300"><code>AGO</code></font>
    or <font color="#663300"><code>AIF</code></font> pseudo-instruction
    to be in a file containing a <font color="#663300"><code>COPY</code></font>
    pseudo-op while the target sequence symbol is in the file being <font
      color="#663300"><code>COPY</code></font>'d?&nbsp; Or vice-versa?<br>
    <br>
    <b>ASM101S</b> does <i>not</i> allow the case just mentioned.&nbsp;
    In other words in <b>ASM101S</b>, for any file being imported via <font
      color="#663300"><code>COPY</code></font>, any <font
      color="#663300"><code>AGO</code></font>/<font color="#663300"><code>AIF</code></font>
    pseudo-instruction and its target sequence symbol must reside within
    the same <font color="#663300"><code>COPY</code></font>'d file.<br>
    <br>
    I do not presently know if this usage occurs within Shuttle flight
    software or not.&nbsp; <br>
    <h2>Arithmetical Peculiarities and Evaluation of Expressions<br>
    </h2>
    <p>Certain arithmetical quirks are inherent in System/360 assembly
      language, and I must presume that these peculiarities carry over
      into AP-101S assembly language as well. Therefore, <b>ASM101S</b>
      retains these peculiarities rather than eliminating them.<br>
    </p>
    <p>The peculiarities I regard as worth noting are these:<br>
    </p>
    <ul>
      <li>As far as I can tell, there are no negative-number literals,
        nor are there any legal arithmetical expressions that are
        superficially equivalent to them.&nbsp; For example, you could
        not assign the symbolic variable <font color="#663300"><code>&amp;A</code></font>
        the value <font color="#663300"><code>-5</code></font> via a
        line of pseudo-code such as "<font color="#663300"><code>&amp;A
            SETA -5</code></font>", because "<font color="#663300"><code>-5</code></font>"
        is neither a legal literal nor a legal arithmetic
        expression.&nbsp; (Nor would <font color="#663300"><code>+5</code></font>
        be legal.)&nbsp; <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/16/mode/1up">The

          assembly-language manual</a> seems to advise using workarounds
        such as "<font color="#663300"><code>&amp;A SETA 0-5</code></font>".</li>
      <li>Division by 0 is allowed, and always results in 0.&nbsp; For
        example, 5/0 is equal to 0.</li>
      <li>Arithmetic expressions are always integer, so the "<font
          color="#663300"><code>/</code></font>" operator is integer
        division.&nbsp; For example, 5/2 evaluates to 2.&nbsp; The
        manual does not explain what the result of an operation like
        (0-5)/2 would be; either -3 or -2 is plausible.&nbsp; Until the
        correct behavior is somehow determined, <b>ASM101S</b> uses the
        Python convention (i.e., it uses the Python <font
          color="#663300"><code>//</code></font> operator), which would
        result in -3 in this case.</li>
      <li>Operator precedence:&nbsp; Consider an expression consisting
        of "terms" that are separated by the operators <font
          color="#663300"><code>+</code></font>, <font color="#663300"><code>-</code></font>,
        <font color="#663300"><code>*</code></font>, or <font
          color="#663300"><code>/</code></font>.&nbsp; ("Terms" is
        quoted here to distinguish the System/360 usage from the normal
        mathematical usage, in which <i>terms</i> are added or
        subtracted from to/from each other, while <i>factors</i> are
        multiplied or divided to/by each other.)&nbsp; These operations
        are performed in <i>left-to-right order</i>, except that
        multiplications or divisions are performed prior to additions or
        subtractions.&nbsp; In particular, in an expression like 3*5/2,
        division does not have a higher precedence than multiplication,
        so it is evaluated as (3*5)/2 rather than as 3*(5/2).<br>
      </li>
      <li>The final result of evaluation of any arithmetic expression is
        always truncated to 24 bits (2's complement), but intermediate
        results are 32 bits.<br>
      </li>
    </ul>
    <p>On the other hand, <b>ASM101S</b> does remove some of the
      constraints of System/360 assembly-language arithmetical
      restrictions, namely:<br>
    </p>
    <ul>
      <li>Expressions can contain any number of terms, rather than being
        limited to a maximum of 16.</li>
      <li>Expressions can have any depth of parentheses, rather than
        being limited to 5 levels.</li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; Regarding peculiarities of
          my own making, as opposed to those of the language itself or
          the original assembler, I'm obliged to admit that I don't
          quite understand how to perfectly handle assembly-time
          evaluation of arithmetic expressions involving program labels:
          i.e., involving the addresses of symbols rather than the
          values of constants.&nbsp; <br>
        </font></p>
      <p><font size="-1">To do so, <b>ASM101S</b> instead uses an
          imperfect trick, making use of the facts that the address
          space of the AP-101S is limited to 24 bits and that the number
          of allowed control sections in a program (at least in
          System/360) is limited to 255.&nbsp; The addresses of program
          labels (prior to linking) is precisely an ordered pair of the
          form (control section, offset into control section), but
          performing arithmetical computations is easiest when these
          values can somehow be converted to single numbers rather than
          ordered pairs.&nbsp; The trick is to assign each control
          section a unique but randomized 64-bit value whose
          least-significant 24 bits are all 0, and to convert addresses
          of symbols to a sums of these 64-bit values plus 24-bit
          offsets into the control sections.&nbsp; (I don't mean that
          the codes for the symbols are actually random, but rather that
          they are selected in a way that makes it unlikely to produce
          their values by common types of calculations.)&nbsp; In this
          way, calculations like <font color="#663300"><code>SYMBOL+OFFSET</code></font>
          or <font color="#663300"><code>SYMBOL1-SYMBOL2</code></font>
          (for symbols in the same section) produce the expected
          results, and indeed, produces correct results for all <i>correct</i>
          expressions.&nbsp; Unfortunately it remains possible to
          combine symbols in an <i>incorrect</i> manner from two
          different control sections and get a result that appears to be
          in yet a third control section, which is incorrect.&nbsp; This
          potential is part of the reason for using 64-bit
          pseudo-addresses (and distributing the unique numerical codes
          for the control sections throughout a 40-bit space) rather
          than 32-bit pseudo-addresses (and distributing the unique
          numerical codes in an 8-bit space):&nbsp; It reduces</font><font
          size="-1"><font size="-1"> to a very low level</font> the
          probability of producing "fake" control sections in
          calculations.<br>
        </font></p>
      <p><font size="-1">According to the System/360 assembly-language
          manual, although </font><font size="-1"><font size="-1"><font
              color="#663300"><code>EXTRN</code></font> symbols can
            appear in expressions, they cannot be paired.&nbsp; This
            implies, I think, that they can be handled interoperably
            with the description in the preceding paragraph, by using </font></font><font
          size="-1"><font size="-1"><font size="-1">unique but
              randomized 64-bit values with the lower 24 bits all 0 in
              place of those symbols.<br>
            </font></font></font></p>
      <p><font size="-1">I thought at first that the same trick could be
          used to handle calculations other not-yet-defined
          symbols.&nbsp; Unfortunately, such an attempt would be
          guaranteed to produce incorrect results in calculations like <font
            color="#663300"><code>KNOWN-UNKNOWN</code></font>, even if <font
            color="#663300"><code>KNOWN</code></font> and <font
            color="#663300"><code>UNKNOWN</code></font> both turned out
          to be members of the same control section.&nbsp; Therefore,
          the addresses of all symbols in the current file must be
          ascertained in a separate pass before computations of
          expressions involving such symbols are performed.<br>
        </font></p>
    </blockquote>
    <ul>
    </ul>
    <h2>Relational Expressions Involving Strings</h2>
    <p>Among the types of expressions computed by the assembler at
      assembly-time for use with pseudo-ops such as <font
        color="#663300"><code>SETB</code></font> or <font
        color="#663300"><code>AIF</code></font> are the boolean
      expressions, of which one sub-type is relational expressions
      involving string values.<br>
    </p>
    <p>A relational expression is used to determine that two values
      (either two numbers or two strings) are equal (<font
        color="#663300"><code>EQ</code></font>), not-equal (<font
        color="#663300"><code>NE</code></font>), less-than (<font
        color="#663300"><code>LT</code></font>), less-than-or-equal (<font
        color="#663300"><code>LE</code></font>), greater-than (<font
        color="#663300"><code>GT</code></font>), or
      greater-than-or-equal-to (<font color="#663300"><code>GE</code></font>)
      each other.&nbsp; For example, the relational expression<br>
    </p>
    <blockquote>
      <pre><font color="#663300">3 LT 4</font><br></pre>
    </blockquote>
    returns the value "true" (which in System/360 assembly language is
    numerically equivalent to 1) since 3 is less than 4.<br>
    <br>
    <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/138/mode/1up">AP-101S

      assembly language</a> shares the obnoxious (in my opinion!)
    property of string comparisons in <a moz-do-not-send="true"
      href="XPL-I.html">the XPL language</a> that a shorter string is
    always "less than" a longer string.&nbsp; For example, <br>
    <blockquote>
      <pre><font color="#663300">'Z' LT 'AA'</font><br></pre>
    </blockquote>
    returns "true".<br>
    <br>
    Unfortunately, as far as I can tell, the System/360
    assembly-language manual does not explicitly state the collation
    sequence to be used for comparing strings of equal length, though it
    seems to me to be implied that it is based on the EBCDIC encoding of
    the characters.<br>
    <br>
    Which is fine for the System/360 assembler.&nbsp; But recall that
    the AP-101S assembler's character set is <i>not</i> EBCDIC, at
    least in terms of the object files it produces, but is instead <a
      moz-do-not-send="true" href="#CharacterSet">the Display
      Electronics Unit (DEU) character set</a>.&nbsp; Of course, it is
    entirely likely that EBCDIC was used at early stages of the original
    assembler's processing and the DEU character set was used in the
    latter stage of processing, but we have no way of knowing whether
    than switch occurred before or after relational expressions were
    computed.&nbsp; Recall that the DEU character set is ASCII-like in
    so far as alphanumeric characters are concerned, and most
    punctuation.<br>
    <p>Thus we really don't know what collation sequence is
      appropriate.&nbsp; Until such time as this question can be
      resolved in a more-authoritative manner, <b>ASM101S</b> assumes
      that the collation sequence is ASCII.<br>
    </p>
    <h2>Character Expressions</h2>
    <p>Character expressions consist of text delimited by single-quotes,
      as for example <font color="#663300"><code>'HELLO'</code></font>,
      plus various additional flourishes that you can read about in the
      System/360 assembly-language manual but which I won't bother to
      rehash here.<br>
    </p>
    One flourish which must be mentioned is <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/84/mode/1up">the

      so-called substring notation</a>, which can be used to extract a
    substring from a string, as in:<br>
    <blockquote>
      <pre><font color="#663300">'HELLO'(<i>start</i>,<i>length</i>)</font><br></pre>
    </blockquote>
    This means that the substring to be extracted begins at <i><font
        color="#663300"><code>index</code></font></i> start and is <font
      color="#663300"><code><i>length</i></code></font> characters in
    width.<br>
    <br>
    One trivial detail which the manual doesn't seem to think worth
    explicitly mentioning, as far as I have been able to ascertain so
    far, is whether the indexing of the string characters is 0-based or
    whether it is 1-based.&nbsp; As curious as it seems, sticklers for
    detail might think this information could be valuable from time to
    time.&nbsp; If you read far enough into the manual, there are
    eventually a couple of examples which indirectly demonstrate that
    indexing of the string is 1-based.<br>
    <h2><a name="declarationSET"></a>Declaration of "SET Symbols"</h2>
    <p>Before describing the specific AP-101S versus System/360 issue
      associated with the items known as "SET symbols", let me summarize
      some of what the System/360 assembly-language manual has to say
      about them.<br>
    </p>
    <p>In System/360 assembly language there is the concept of symbols
      known only to the assembler, in contradiction to symbols
      representing addresses in the runtime memory of the assembled
      program.&nbsp; These symbols are distinguished in that their names
      are prefixed by the character '&amp;'.&nbsp; Thus <font
        color="#663300"><code>MYVAR</code></font> might be a variable
      representing a memory location, whose contents can be modified by
      the assembly-language program when it is run, while <font
        color="#663300"><code>&amp;MYVAR</code></font> might represent
      an assembly-time variable, assigned a value that can be
      manipulated during the assembly process, but that is not known or
      modifiable by the assembled program.<br>
    </p>
    These assembler-only variables can be classified in a number of
    ways, one of which is that they can be of one of three
    mutually-exclusive types:<br>
    <ol>
      <li>"Symbolic parameters" are the formal parameters found in macro
        definitions.&nbsp; They are assigned values at the time of the
        invocation of the macro, but cannot otherwise be changed.</li>
      <li>"System variables" are assigned values by the assembler
        itself, conceivably different on each use of the variable, and
        cannot be changed by software.&nbsp; They're distinguished by
        the fact that they always begin with the characters "&amp;SYS".</li>
      <li>"SET symbols" can be explicitly created, assigned values, and
        reassigned values by software at will.</li>
    </ol>
    <p>Here, we're concerned only by the latter category, namely the SET
      symbols.<br>
    </p>
    <p>SET symbols can be categorized another way, namely by their
      datatypes, which cannot be changed once established.&nbsp; The
      three types are:<br>
    </p>
    <ol type="A">
      <li>Integer</li>
      <li>Boolean</li>
      <li>Character string</li>
    </ol>
    <p>Yet a third way that they can be characterized is as:<br>
    </p>
    <ul>
      <li>GBL: "global" variables accessible identically in all
        software, whether inside or outside of macro definitions and
        invocations.<br>
      </li>
      <li>LCL: "local" variables accessible only within a single
        invocation of the macro definition in which they are
        defined.&nbsp; (Or else if declared outside of all macro
        definitions, accessible only outside of all macro definitions or
        invocations.)<br>
      </li>
    </ul>
    Prior to the first use of any SET symbol, it must be declared via of
    the macro-language instructions <font color="#663300"><code>GBLA</code></font>,
    <font color="#663300"><code>GBLB</code></font>, <font
      color="#663300"><code>GBLC</code></font>, <font color="#663300"><code>LCLA</code></font>,
    <font color="#663300"><code>LCLB</code></font>, or <font
      color="#663300"><code>LCLC</code></font>.&nbsp; Any of these
    instructions also assigns an initial value the symbol, either 0,
    False (0), or '' (empty string), depending on the datatype. &nbsp;
    For example, the instruction "<font color="#663300"><code>LCLB
        &amp;BOO</code></font>" declares a local boolean SET symbol
    called <font color="#663300"><code>&amp;BOO</code></font> and
    assigns it the default value False (numerically, 0).<br>
    <br>
    After declaration, the value of a SET symbol may be changed (within
    its global or local scope, as appropriate) via one of the
    macro-language instructions <font color="#663300"><code>SETA</code></font>,
    <font color="#663300"><code>SETB</code></font>, or <font
      color="#663300"><code>SETC</code></font>.<br>
    <br>
    Okay, that was the background, but here's the AP-101S specific
    issue:&nbsp; In actual AP-101S assembly-language source code, there
    are SET symbols modified by <font color="#663300"><code>SETA</code></font>,
    <font color="#663300"><code>SETB</code></font>, or <font
      color="#663300"><code>SETC</code></font> (or used in other
    manners) without any declaration via <font color="#663300"><code>GBLA</code></font>,
    <font color="#663300"><code>GBLB</code></font>, <font
      color="#663300"><code>GBLC</code></font>, <font color="#663300"><code>LCLA</code></font>,
    <font color="#663300"><code>LCLB</code></font>, or <font
      color="#663300"><code>LCLC</code></font> whatsoever (prior or
    otherwise), which is a possibility denied by the System/360
    assembly-language manual.<br>
    <br>
    For example, consider <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC/INPUT.asm">the

      INPUT macro</a>, provided as part of the AP-101S runtime library
    by the original source code of the HAL/S compiler HAL/S-FC.&nbsp; It
    has four SET symbols that are used without declarations, highlighted
    in <font color="#33cc00">green</font> in the listing below:<br>
    <blockquote>
      <pre>         MACRO                                                          00000100<br>         INPUT &amp;X                                                       00000200<br>         GBLA  &amp;ENTCNT                                                  00000300<br>         GBLB  &amp;INPUT(20),&amp;LIB                                          00000400<br>         AIF   (N'&amp;SYSLIST EQ 0).EMPTY                                  00000500<br>&amp;INPUT(&amp;ENTCNT) SETB 1                                                  00000600<br>         AIF   ('&amp;X' EQ 'NONE').SPACE                                   00000700<br><font color="#33cc00">&amp;I</font>       SETA  1                                                        00000800<br><font color="#33cc00">&amp;LAST</font>    SETA  N'&amp;SYSLIST                                               00000900<br>.LOOP    AIF   (K'&amp;SYSLIST(<font color="#33cc00">&amp;I</font>) NE 2).BADREG                             00001000<br><font color="#33cc00">&amp;R</font>       SETC  '&amp;SYSLIST(<font color="#33cc00">&amp;I</font>)'                                           00001100<br>         AIF   ('<font color="#33cc00">&amp;R</font>'(1,1) NE 'F' AND '<font color="#33cc00">&amp;R</font>'(1,1) NE 'R').BADREG           00001200<br>         AIF   ('<font color="#33cc00">&amp;R</font>' EQ 'R0').BADREG                                    00001300<br>         AIF   (&amp;LIB AND ('<font color="#33cc00">&amp;R</font>' EQ 'R1' OR '<font color="#33cc00">&amp;R</font>' EQ 'R3')).INVREG1        00001400<br>         AIF   (NOT &amp;LIB AND '<font color="#33cc00">&amp;R</font>' EQ 'R4').INVREG2                      00001500<br>         AIF   (D'<font color="#33cc00">&amp;R</font>).NEXT                                              00001600<br><font color="#33cc00">&amp;N</font>       SETC  '<font color="#33cc00">&amp;R</font>'(2,1)                                                00001700<br><font color="#33cc00">&amp;R</font>       EQU   <font color="#33cc00">&amp;N</font>                                                       00001800<br>.NEXT    ANOP                                                           00001900<br><font color="#33cc00">&amp;I</font>       SETA  <font color="#33cc00">&amp;I</font>+1                                                     00002000<br>         AIF   (<font color="#33cc00">&amp;I</font> LE <font color="#33cc00">&amp;LAST</font>).LOOP                                       00002100<br>.SPACE   SPACE                                                          00002110<br>         MEXIT                                                          00002200<br>.BADREG  MNOTE 4,' ILLEGAL REGISTER SPECIFICATION - &amp;SYSLIST(<font color="#33cc00">&amp;I</font>)'       00002300<br>         AGO   .NEXT                                                    00002400<br>.INVREG1 MNOTE 4,'<font color="#33cc00">&amp;R</font> INVALID INPUT FOR PROCEDURE ROUTINE'               00002500<br>         AGO   .NEXT                                                    00002600<br>.INVREG2 MNOTE 4,'R4 INVALID INPUT FOR INTRINSIC'                       00002700<br>         AGO   .NEXT                                                    00002800<br>.EMPTY   MNOTE 4,'OPERAND REQUIRED'                                     00002900<br>         MEND                                                           00003000<br></pre>
    </blockquote>
    What are we to make of this?<br>
    <br>
    Upon considerable reflection, my inference is that the AP-101S has a
    built-in convenience feature, either not present or not documented
    in the System/360 assembler, namely this:&nbsp; <br>
    <blockquote><i>When</i><i> a variable that has not previ</i><i>ously
        been expli</i><i>citly declared (b</i><i>y <font
          color="#663300"><code>GBLx</code></font><font size="-1"> or </font><font
          color="#663300"><code>LCLx</code></font></i><font size="-1"><u><i><font
              color="#663300"><code></code></font></i></u></font><i>) is
        the target of a <font color="#663300"><code>SETx</code></font>
      </i><u><i><font color="#663300"><code></code></font></i></u><i>instruction,

        it is declared automatically by the assembler as if via </i><i><font
          color="#663300"><code></code></font></i><i><font
          color="#663300"><code>LCLx</code></font></i><i>.</i><br>
    </blockquote>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;

        If this inference is correct, it might seem naively that there's
        no need for the instructions </font><font size="-1"><font
          color="#663300"><code>LCLA</code></font>, <font
          color="#663300"><code>LCLB</code></font>, or <font
          color="#663300"><code>LCLC</code></font> at all, since a </font><font
        size="-1"><font color="#663300"><code>SETA</code></font>, <font
          color="#663300"><code>SETB</code></font>, or <font
          color="#663300"><code>SETC</code></font> could always be used
        instead.&nbsp; Upon closer inspection that's not true, since </font><font
        size="-1"><font color="#663300"><code>LCLx</code><font
            color="#000000"> (like </font></font></font><font size="-1"><font
          color="#663300"><font color="#000000"><font color="#663300"><code>GBLx</code></font>)
            can additionally be used to declare SET symbols as arrays,
            which a </font></font></font><font size="-1"><font
          color="#663300"><font color="#000000"><font color="#663300"><code>SETx</code></font>
            instruction with this convenience feature could not.&nbsp;
            And even in the non-arrayed case, there are certainly
            instances in existing code in which </font></font></font><font
        size="-1"><font color="#663300"><font color="#000000"><font
              size="-1"><font color="#663300"><code>LCLx</code></font></font>
            is indeed used explicitly even though the described
            convenience feature would not require it.&nbsp; For example,
            consider <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC/AERROR.asm">this

              macro from the AP-101S runtime-library source code</a>,
            which unlike the problematic macro listed above corresponds
            exactly to the System/360 assembly-language manual's
            pronouncements:<br>
          </font></font></font>
      <blockquote>
        <pre><font size="-2">         MACRO                                                          00000100<br>&amp;NAME    AERROR &amp;NUM,&amp;GROUP=4                                           00000200<br>         GBLA  &amp;ERRCNT,&amp;ERRNUMS(10),&amp;ERRGRPS(10)                        00000300<br>         <font color="#009900">LCLA  &amp;I</font>                                                       00000400<br>         AIF   (&amp;NUM GT 62).BADNUM                                      00000500<br><font color="#009900">&amp;I</font>       SETA  &amp;ERRCNT                                                  00000600<br>.DUPLOOP AIF   (<font color="#009900">&amp;I</font> LE 0).NEWERR                                         00000700<br>         AIF   (&amp;NUM EQ &amp;ERRNUMS(<font color="#009900">&amp;I</font>) AND &amp;GROUP EQ &amp;ERRGRPS(<font color="#009900">&amp;I</font>)).DUP    00000800<br><font color="#009900">&amp;I</font>       SETA  <font color="#009900">&amp;I</font>-1                                                     00000900<br>         AGO   .DUPLOOP                                                 00001000<br>.NEWERR  ANOP                                                           00001100<br>&amp;ERRCNT  SETA  &amp;ERRCNT+1                                                00001200<br><font color="#009900">&amp;I</font>       SETA  &amp;ERRCNT                                                  00001300<br>&amp;ERRNUMS(<font color="#009900">&amp;I</font>) SETA &amp;NUM                                                  00001400<br>&amp;ERRGRPS(<font color="#009900">&amp;I</font>) SETA &amp;GROUP                                                00001500<br>.DUP     ANOP                                                           00001600<br>*********ISSUE SEND ERROR SVC****************************************** 00001700<br>&amp;NAME    SVC   AERROR<font color="#009900">&amp;I</font>       ISSUE SEND ERROR SVC                      00001800<br>*********SEND ERROR SVC RETURNS CONTROL FOR STANDARD FIXUP************* 00001900<br>         MEXIT                                                          00002000<br>.BADNUM  MNOTE 12,'ERROR NUMBER GREATER THAN 62'                        00002100<br>         MEND                                                           00002200</font><br></pre>
      </blockquote>
      <font size="-1"> As for the origin of such a convenience feature
        in the first place, I'd note that in addition to being
        "convenient", the complexity of some AP-101S macros could make
        some of those macros very difficult or impossible to implement
        otherwise.&nbsp; According to System/360 rules, all <font
          color="#663300"><code>GBLx</code></font> and <font
          color="#663300"><code>LCLx</code></font> instructions must
        appear not merely before <font color="#663300"><code>SETx</code></font>
        instructions involving the SET symbols they declare, but indeed
        prior to everything else.&nbsp; For example, </font><font
        size="-1"><font size="-1"><font color="#663300"><code>GBLx</code></font></font>
        instructions must appear immediately after the prototype line of
        a macro definition, with nothing intervening except comments,
        while </font><font size="-1"><font size="-1"><font
            color="#663300"><code>LCLx</code></font></font> instructions
        in turn must appear immediately after that.&nbsp; Thus if a
        macro definition depends on the flexibility of allowing a SET
        symbol to be declared in alternate ways under different
        circumstances, such as arrayed vs non-arrayed or integer vs
        character, the rules of the System/360 assembler likely would
        not allow it because alternate declarations could appear in the
        prescribed location.&nbsp; Whereas the rules of implicit
        declaration via <font color="#663300"><code>SETx</code></font>
        instructions basically allow non-arrayed local declarations to
        appear anywhere.&nbsp; So the convenience feature of implicit
        declaration, if it truly exists, could have arisen from
        necessity rather than from a desire for mere convenience.&nbsp;
        Not that "mere" convenience is to be sneered at.&nbsp; But
        that's just speculation on my part, with the answer lost in the
        mists of time past.</font><br>
    </blockquote>
    <h2><code>DC</code> and <code>DS</code> Pseudo-Op Formats</h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/36/mode/1up?view=theater">The
        System/360 assembly-language manual</a> describes a
      quite-complex format for the operands of the <font
        color="#663300"><code>DS</code></font> and <font
        color="#663300"><code>DC</code></font> pseudo-ops used for
      allocating or initializing data memory.&nbsp; (The description
      takes about 11 pages, which is over 6% of the manual.)&nbsp;
      However, I see no point in implementing those features of this
      format which are not actually used in Space Shuttle
      flight-software source code.&nbsp; At present, I believe that the
      following features of the <font color="#663300"><code>DC</code></font>/<font
        color="#663300"><code>DS</code></font> format do <i>not</i>
      need to be supported in <b>ASM101S</b>:<br>
    </p>
    <ul>
      <li>Type codes L, P, Z, S, V, Q<br>
      </li>
      <li>Scale modifier</li>
      <li>Exponent modifier</li>
    </ul>
    <h2>SRS-Type Instructions Versus RS-Type Instructions</h2>
    <p>AP-101S instructions are of 5 basic types, designated (by IBM) as
      RR, RS, SRS, RI, and SI, based on the syntax patterns of their
      operands and on the way they are encoded as machine
      instructions.&nbsp; Some of these are System/360 patterns, and
      some are not.&nbsp; I won't bore you with the details, as you can
      read about them in <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=34">the
        AP-101S Principles of Operation</a>.&nbsp; However, there is a
      certain difficulty with SRS- and RS-type instructions that could <i>in
        principle</i> cause a mismatch between object code generated by
      <b>ASM101S</b> vs the original AP-101S assembler, though hopefully
      not any behavioral difference at runtime other than slight timing
      discrepancies.&nbsp; This group of instructions includes, among
      other things, all <a moz-do-not-send="true"
        href="#instructionAliases">conditional-branch instructions and
        their aliases</a>.<br>
    </p>
    <p>The difficulty relates to the fact that certain instruction
      mnemonics are used <i>both</i> for SRS-type instructions and
      RS-type instructions.&nbsp; Moreover, while some of the operand
      patterns for them are accepted for SRS instructions and not RS
      instructions, thus allowing the assembler to distinguish between
      them, <i>some</i> of the operand patterns overlap.&nbsp; In those
      cases, there is no syntactic way for the assembler to distinguish
      between the SRS instruction and the RS instruction.&nbsp; Overlap
      occurs for the following syntactical patterns (where <font
        color="#663300"><code>R1</code></font>, <font color="#663300"><code>D2</code></font>,
      and <font color="#663300"><code>B2</code></font> refer to the
      names of fields in the encoded machine instruction):<br>
    </p>
    <blockquote>
      <pre><font color="#663300">OPCODE	R1,D2<br>OPCODE	R1,D2(B2)</font><br></pre>
    </blockquote>
    <p>The vulnerable opcode mnemonics are:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">A AE AH BC C CH D DE IAL L LA LE LH M ME MH N O S SE SH SHW ST STH TD TH X ZH</font><br></pre>
    </blockquote>
    While the SRS-type and RS-type instructions are behaviorally
    identical, they are encoded differently as machine instructions, and
    in particular require different amounts of memory to do so.&nbsp;
    SRS-type instructions are encodes as half-words (2 bytes), while
    RS-type instructions are encoded as full words (4 bytes).&nbsp; For
    example, there is no syntactical way to know whether to encode the
    instruction "<font color="#663300"><code>L 4,SWITCH</code></font>"
    as 2 bytes or as 4 bytes.&nbsp; So if <b>ASM101S</b> were to encode
    an instruction as SRS while the original assembler were to encode it
    as RS, or vice-versa, then not only would the binary forms of those
    particular instructions differ, but all of the code following that
    instruction in the same control section would be aligned
    differently.<br>
    <p>As I said, there is no syntactic way for the assembler to
      distinguish between these cases, but there is a non-syntactic way
      based on the size of the <font color="#663300"><code>D2</code></font>
      sub-operand.&nbsp; If <font color="#663300"><code>D2</code></font>
      is in the numerical range 0-55, then the SRS instruction can be
      used, while if <font color="#663300"><code>D2</code></font> is 56
      or greater, the RS instruction must be used.&nbsp; But as far as I
      can see — and perhaps this is a limitation of my own imagination!
      — the size of <font color="#663300"><code>D2</code></font> can be
      determined only in case it involves only <i>previously-defined</i>
      symbols whose addresses or values are known.&nbsp; If forward
      reference is involved, I see no way to determine <font
        color="#663300"><code>D2</code></font>'s value with
      certainty.&nbsp; And there is nothing documented, as far as I
      know, that limits the determination of <font color="#663300"><code>D2</code></font>
      just to previously-defined symbols.<br>
    </p>
    <p>With that said, in <i>some</i> cases <b>ASM101S</b> can know
      with certainty that the SRS form can be used.&nbsp; For example,
      in the instruction<br>
    </p>
    <blockquote>
      <pre><font color="#663300">OPCODE	R1,<i>SYMBOL</i></font></pre>
    </blockquote>
    <p>where <i><font color="#663300"><code>SYMBOL</code></font></i>
      happens to be a program label above but within 56 words of a base
      address specified by <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/19/mode/1up?view=theater">the
        <font color="#663300"><code>USING</code></font> pseudo-op</a>,
      then the SRS encoding is certainly applicable.<br>
    </p>
    <p>In short, while <b>ASM101S</b> uses heuristic methods to try to
      make the same choices of SRS vs RS as the original assembler, but
      given that the rules used by the original assembler are not known,
      there is no guarantee that it succeeds in doing so in all possible
      cases.<br>
    </p>
    <h1>Afterthought:&nbsp; HLASM</h1>
    Belatedly, someone pointed out <a moz-do-not-send="true"
      href="https://share.confex.com/share/115/webprogram/Session7445.html">a
      presentation from 2010</a> called "Assembler Language as a Higher
    Level Language: Conditional Assembly and Macro Techniques" by John
    R. Ehrman of IBM as a possible resource for deciphering conundrums
    about gaps in the System/360 assembly-language manual vs
    AP-101S.&nbsp;&nbsp; Admittedly, John's presentation concerns the
    so-called "High Level Assembler for z/OS, z/VM, and z/VSE",
    apparently still being sold for IBM mainframes under the name
    "HLASM".&nbsp; Not being steeped in IBM lore myself, I can only make
    assumptions as to how how relevant HLASM may be to the AP-101S
    assembler.&nbsp; There's a <i>lot</i> of HLASM stuff that's
    definitely not available (or at least never used if it is available)
    in AP-101S source code, though it's unclear if there's anything in
    it that's flatly inconsistent with AP-101S.&nbsp; IBM itself
    provides <a moz-do-not-send="true"
      href="https://www.ibm.com/docs/en/SSLTBW_2.2.0/pdf/asmr1022.pdf">a
      manual for HLASM that's you can find online</a>.<br>
    <br>
    Accepting at face value the notion that statements about HLASM are
    relevant to AP-101S, various inferences I made above might be
    confirmed as indicated in the following table.&nbsp; (Note that I
    can't guarantee links into the IBM documentation, since that
    documentation is not hosted at Virtual AGC, and won't be posted here
    until at least 2100 AD due to copyright considerations.)<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="top">My Inference<br>
          </th>
          <th valign="top">HLASM Manual<br>
          </th>
        </tr>
        <tr>
          <td valign="top"><a moz-do-not-send="true"
              href="#definedAttribute">The D' operator</a><br>
          </td>
          <td valign="top"><a moz-do-not-send="true"
href="https://www.ibm.com/docs/en/SSLTBW_2.2.0/pdf/asmr1022.pdf#page=326">Defined
              Attribute (D')</a><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><a moz-do-not-send="true"
              href="#declarationSET">Declaration of SET symbols</a><br>
          </td>
          <td valign="top">I've not found this so far in the HLASM
            manual, but Ehrman's presentation says the following:&nbsp;
            SET symbols can be implicitly declared "as local variables,
            if first appearance is as the name-field symbol of a SETx
            assignment statement − this is the only implicit form whose
            values may be changed (SET)".&nbsp; (See figure Cond-10.)<br>
            <br>
            The HLASM manual, on the other hand, contains <a
              moz-do-not-send="true"
href="https://www.ibm.com/docs/en/SSLTBW_2.2.0/pdf/asmr1022.pdf#page=333">the
              following curious provision</a> that seems to partially
            contradict Ehrman:&nbsp; "If the variable symbol is the same
            as the character value, the assembler considers the variable
            symbol to be an implicitly defined local <font
              color="#663300"><code>SETC</code></font> symbol which is
            given a null character string value. For example: <font
              color="#663300"><code>&amp;C6 SETC '&amp;C6'</code></font>,
            assigns the value <font color="#663300"><code>''</code></font>
            to <font color="#663300"><code>&amp;C6</code></font>.&nbsp;
            <a moz-do-not-send="true"
href="https://www.ibm.com/docs/en/SSLTBW_2.2.0/pdf/asmr1022.pdf#page=340">Later
              on</a>, the manual makes a related assertion:&nbsp; "If
            the variable symbol is the same as the character value, the
            assembler considers the variable symbol to be an implicitly
            defined local <font color="#663300"><code>SETA</code></font>
            symbol, which is given a value of zero. For example:&nbsp; <font
              color="#663300"><code>&amp;ASYM2 SETA &amp;ASYM2</code></font>.&nbsp;
            <font color="#663300"><code>&amp;ASYM2 has a value 0</code></font>."<br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><br>
          </td>
          <td valign="top"><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <ul>
      <li><a moz-do-not-send="true"
href="file:///mnt/STORAGE/home/rburkey/git/virtualagc-web/ASM101S.html#definedAttribute">The
          D' ("defined") operator</a>.&nbsp; (See here in the HL.)<br>
      </li>
    </ul>
    <blockquote>
    </blockquote>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-10-05<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300"
              height="100"></a><br>
        </font></i></center>
    <br>
  </body>
</html>
