<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>AP-101S Macro Assembler</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <div align="center">
      <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","IBM AP-101S / AP-101B").replace("@SUBTITLE@","Macro Assembler"))
</script><br>
      <font size="+2"><i>(This page and ASM101S itself are under
          construction.)</i></font><br>
    </div>
    <h1>Table of Contents </h1>
    <ul>
      <li><a moz-do-not-send="true" href="#Introduction">Introduction</a></li>
      <li><a moz-do-not-send="true" href="#References">References</a></li>
      <li><a moz-do-not-send="true" href="#master">The Master Sequence
          Controller (MSC)</a></li>
      <li><a moz-do-not-send="true" href="#bce">The Bus Control Elements
          (BCE)</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#ASM101S">ASM101S</a></li>
      <li><a moz-do-not-send="true" href="#aBriefTour">A Brief Tour of
          the Assembly Process</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#macros">Macro-Library Files</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#Installation">Installation of
          ASM101S</a></li>
      <li><a moz-do-not-send="true" href="#wildThings">Where Are the
          AP-101 Assembly-Language Files</a></li>
      <li><a moz-do-not-send="true" href="#Differences">Potential
          Differences from Expectations</a></li>
      <li><a moz-do-not-send="true" href="#structureASM101S">Structure
          of ASM101S, for Maintainers</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#HLASM">Afterthought: HLASM</a><br>
      </li>
      <ul>
      </ul>
    </ul>
    <h1><a name="Introduction"></a>Introduction</h1>
    <b>ASM101S</b> is our "modern" version of the macro assembler for
    the assembly language of the IBM AP-101S or AP-101B computers used
    as "General Purpose Computers" (GPC) in the Space Shuttle.&nbsp; To
    the best of my knowledge, the original assembler actually used for
    Shuttle software development has not survived, so <b>ASM101S</b> is
    an entirely-new creation.&nbsp; It is a Python 3 program that should
    work on any computer having the Python 3 language installed. <br>
    <br>
    Regarding AP-101B vs AP-101S, the AP-101B was used in earlier
    Shuttle flights, while the AP-101S was used in later flights.&nbsp;
    I have almost no documentation for the AP-101B, but believe that
    insofar as software is concerned, the main difference is that a
    handful of new instruction types were made available in the AP-101S
    that hadn't existed in the AP-101B.&nbsp; Therefore, <b> ASM101S</b>
    itself makes no distinctions between the two languages:&nbsp; If you
    feed in source code using any of the newer instructions, you'll get
    object code suitable for the AP-101S only.&nbsp; If you feed in
    source code not having any of the newer instructions, you'll get
    object code suitable for both the AP-101S and AP-101B.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; That's not to say
        that the differences were insignificant, but merely that the
        differences are transparent to the assembler.&nbsp; Here's <a
          moz-do-not-send="true"
href="Shuttle/IBM%20AP-101S%20General%20Purpose%20Computer%20With%20Shuttle%20Instruction%20Set%20-%20searchable.pdf#page=40">a
          summary</a> of some of the known differences:<br>
        <br>
      </font>
      <table cellspacing="10" cellpadding="2" align="center">
        <tbody>
          <tr>
            <th valign="top" align="left"><font size="-1"><u>Feature</u><br>
              </font></th>
            <th valign="top" align="left"><u><font size="-1">AP-101B<br>
                </font></u></th>
            <th valign="top" align="left"><u><font size="-1">AP-101S<br>
                </font></u></th>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Power:<br>
              </font></td>
            <td valign="top"><font size="-1">780W<br>
              </font></td>
            <td valign="top"><font size="-1">560W<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Weight:<br>
              </font></td>
            <td valign="top"><font size="-1">117 pounds<br>
              </font></td>
            <td valign="top"><font size="-1">64 pounds<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Memory:<br>
              </font></td>
            <td valign="top"><font size="-1">104K words<br>
                (416K bytes)<br>
              </font></td>
            <td valign="top"><font size="-1">256K words<br>
                (1024K bytes)<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Memory Protection<br>
                (per 16-bit half-word):<br>
              </font></td>
            <td valign="top"><font size="-1">1 parity bit and <br>
                1 store-protect bit<br>
              </font></td>
            <td valign="top"><font size="-1">6 ECC bits and <br>
                3 store-protect bits<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Speed:<br>
              </font></td>
            <td valign="top"><font size="-1">420K operations/second<br>
              </font></td>
            <td valign="top"><font size="-1">&gt;1000K operations/second<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Battery backup:<br>
              </font></td>
            <td valign="top"><font size="-1">n/a<br>
              </font></td>
            <td valign="top"><font size="-1">Rechargeable NiCAD </font><br>
            </td>
          </tr>
          <tr>
            <td valign="top"><font size="-1">Built-in test equipment:
                &nbsp; &nbsp; &nbsp; <br>
              </font></td>
            <td valign="top"><font size="-1">n/a<br>
              </font></td>
            <td valign="top"><font size="-1">Temperature; charger;
                battery; soft error counter<br>
              </font></td>
          </tr>
          <tr>
            <td valign="top">MTBF:<br>
            </td>
            <td valign="top"><font size="-1">5K hours<br>
              </font></td>
            <td valign="top"><font size="-1">24K hours<br>
              </font></td>
          </tr>
        </tbody>
      </table>
      <br>
    </blockquote>
    Because there's little software distinction between the different
    models in a software sense, I'll generally just refer to the
    "AP-101" rather than specifying "AP-101S" or "AP-101B".&nbsp;
    Realize, though, that there were also models of the IBM AP-101
    computer other than the AP-101B or AP-101S, for uses <i>other</i>
    than the Shuttle, and there's no particular reason to believe that <b>ASM101S</b>
    could assemble their source code without some updates.<br>
    <br>
    Despite the lack of surviving documentation about the original
    AP-101 assembler, by examining the surviving AP-101
    assembly-language source code I've concluded that the syntax of the
    AP-101 assembly language must have closely mimicked that of the
    standard macro assembler for the IBM System/360 Basic Assembly
    Language (BAL).&nbsp; This observation has been central to the
    development of <b>ASM101S</b>.<br>
    <h1> <a name="References"></a>References</h1>
    <ul>
      <li><a moz-do-not-send="true" href="hal.html">The Virtual AGC
          HAL/S compiler page</a></li>
      <li><a moz-do-not-send="true" href="ASM101S.html">The Virtual AGC
          AP-101S linker page</a><br>
      </li>
      <li>"<a moz-do-not-send="true"
          href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf">Space
          Shuttle Model AP-101S Principles of Operations with Shuttle
          Instruction Set</a>".&nbsp; Manual for the CPU instruction
        set.&nbsp; Also known as the "POO" (Principles of Operation).<br>
      </li>
      <li>"<a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231">OS
















          Assembler Language - OS Release 21</a>".&nbsp; Manual for the
        System/360 macro assembler upon which <b>ASM101S</b> is
        modeled.</li>
      <li><a moz-do-not-send="true"
href="Shuttle/IBM%20AP-101S%20General%20Purpose%20Computer%20With%20Shuttle%20Instruction%20Set%20-%20searchable.pdf">A
          collection of notes about the AP-101S/AP-101B</a>.</li>
      <li>"<a moz-do-not-send="true"
href="Shuttle/Courses/AP-101S%20Assembly%20Language%20Introduction%20Course.pdf">AP
















          101S Assembly Language Introduction</a>".</li>
      <li>"Space Shuttle Advanced System/4 Pi Input/Output Processor
        (IOP)":</li>
      <ul>
        <li><a moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20-%20Input,%20Output%20Processor%20(IOP)%20-%20Principles%20of%20Operation%20for%20PCI,%20PCO,%20MSC,%20and%20BCE.pdf">Parts














            I and II</a>:&nbsp; :&nbsp; Principles of Operation for
          PCI/PCO and MSC</li>
        <li><a moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Input,%20Output%20Processor%20(IOP)%20-%20Part%203%20-%20Principles%20of%20Operation%20for%20the%20Bus%20Control%20Element.pdf">Part














            III</a>:&nbsp; Principles of Operation for BCE.</li>
      </ul>
      <li>"<a moz-do-not-send="true"
href="Shuttle/IBM-75-A97-001%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Model%20AP-101%20Central%20Processor%20Unit%20-%20Technical%20Description.pdf">Space














          Shuttle Advanced System/4 Pi Model AP-101 Central Processor
          Unit Technical Description</a>".&nbsp; Note that this predates
        the AP-101S model and doesn't precisely match it.<br>
      </li>
    </ul>
    <h1><a name="master"></a>The Master Sequence Controller (MSC)<br>
    </h1>
    AP-101 assembly language includes not only pseudo-ops and AP-101 CPU
    instructions as such, but also instructions for the Master Sequence
    Controller (MSC). You might categorize the MSC as being a separate
    computer within the main computer. The CPU and MSC instructions, for
    these two essentially separate types of computers, are intermixed
    indiscriminately in AP-101 assembly-language source code and sharing
    memory.&nbsp; <a moz-do-not-send="true"
href="httpsShuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=337">The














      POO</a> explains the MSC thusly:<br>
    <blockquote><font size="-1">"The Master Sequence Controller (MSC) is
        a micro programmed computer specifically tailored for I/O
        Management within the Space Shuttle General Purpose Computer
        (GPC).&nbsp; As such, it has extensive and programmable
        capabilities for monitoring and controlling the basic I/O
        operations performed by upwards to 24 Bus Control Elements
        (BCE's) which are implemented in the baseline GPC.&nbsp; These
        capabilities include setting up, scheduling, and initiating BCE
        programs, monitoring the status of BCD operations, and
        communicating overall completion of these operations to the
        CPU."</font><br>
    </blockquote>
    MSC instructions can be distinguished from CPU instructions in that
    they begin with the character "@".<br>
    <br>
    See <a moz-do-not-send="true"
      href="Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=337">Appendix














      II of the AP-101S POO</a> or the seemingly-identical <a
      moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20-%20Input,%20Output%20Processor%20(IOP)%20-%20Principles%20of%20Operation%20for%20PCI,%20PCO,%20MSC,%20and%20BCE.pdf#page=68">Part














      II of the IOP POO</a> for more information.<br>
    <h1><a name="bce"></a>The Bus Control Elements (BCE)</h1>
    <p>Similarly, the POO tells us that<br>
    </p>
    <blockquote><font size="-1">"The Bus Control Element (BCE) is a
        microprogrammed controller specifically tailored for management
        of I/O traffic on one of the Space Shuttle system busses.&nbsp;
        Within each IOP [Input/Output Processor] there is one BCE for
        each system bus, for a total of 24 BCE's.&nbsp; Each of these
        BCE's is capable of independent program execution, data
        buffering to and from memory, and communication with the MSC."</font><br>
    </blockquote>
    Or in other words, besides the MSC discussed in the preceding
    section, there are 24 <i>additional</i> processors within the
    AP-101, yet again with their own distinct instruction set, yet again
    sharing memory and intermixed in the assembly-language source code
    with CPU instructions and MSC instructions.<br>
    <p>BCE instructions can be distinguished from CPU and MSC
      instructions in that they begin with the character "#".<br>
    </p>
    <p>See <a moz-do-not-send="true"
        href="Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=445">Appendix














        III of the AP-101S POO</a> or the seemingly-identical <a
        moz-do-not-send="true"
href="Shuttle/IBM-6246556A%20-%20Space%20Shuttle%20Advanced%20System,%204%20Pi%20Input,%20Output%20Processor%20(IOP)%20-%20Part%203%20-%20Principles%20of%20Operation%20for%20the%20Bus%20Control%20Element.pdf">Part














        III of the IOP POO</a> for more information.<br>
    </p>
    <ul>
    </ul>
    <h1><a name="ASM101S"></a>ASM101S</h1>
    <p><i>(To be clear, </i><i><b>ASM101S</b></i><i> is not entirely
        functional</i><i>.&nbsp; I am simply documenting it as I proceed
        with development.&nbsp; Therefore, some of what's described
        might not be available yet, though of course where I show
        specific examples of output from the assembler, it is functional
        enough to produce the results shown.)</i><br>
    </p>
    The modern assembler is invoked as<br>
    <blockquote>
      <pre><font color="#663300">ASM101S.py [<i>OPTIONS</i>] <i>SOURCE1</i>.asm <i>SOURCE2</i>.asm ...</font><br></pre>
    </blockquote>
    Some of the more-significant available <i><font color="#663300"><code>OPTIONS</code></font></i>
    are:<br>
    <ul>
      <li><font color="#663300"><code>--library=<i>LIBRARY</i></code></font>
        specifies a path to a folder containing files of macro
        definitions needed for processing the source-code files.&nbsp;
        You'll see more on this topic later on.&nbsp; Though "optional",
        there are very few (if any) legacy assembly-language programs
        that you'll be able to assemble without it.</li>
      <li><font color="#663300"><code>--sysparm=BFS</code></font> tells
        the assembler that the a portion of the Space Shuttle's "backup
        flight software" is being assembled.&nbsp; By default, the
        assembler assumes instead that you're assembly a portion of the
        primary flight software.&nbsp; If you're assembling non-Shuttle
        software, it doesn't really matter which is which.&nbsp; Note
        that the "BFS" here is literal.<br>
      </li>
      <li><font color="#663300"><code>--object=<i>OBJECT</i>.obj</code></font>
        specifies the name of the object-code file generated by the
        assembler.&nbsp; This this option isn't present, <i><font
            color="#663300"><code>OBJECT</code></font></i> will match
        the name of the last source-code file specified on the command
        line.</li>
      <li><font color="#663300"><code>--compare=<i>FILENAME</i></code></font>
        specifies the name of an existing assembly-listing file against
        which you wish to compare the results of the current
        assembly.&nbsp; Byte-by-byte comparison of the generated object
        code is performed, and mismatches are noted directly in the
        assembly-listing produced by the assembler.&nbsp; This feature
        is most-useful when contemporary assembly listings are
        available, as is the case (for example) for all of the modules
        in the AP-101S runtime library of the HAL/S compiler (<b>HAL/S-FC</b>).<br>
      </li>
    </ul>
    Since you are allowed to specify multiple assembly-language
    source-code files on the command lines, it's possible in principle
    to assemble an entire program at once.&nbsp; In practice, it would
    be more usual to assemble each source-code file separately, and then
    to use a linker to merge all of those object-code files into a
    single AP-101S load file for the program as a whole.<br>
    <br>
    You can see a list (and explanations!) of all of the available
    command-line <i><font color="#663300"><code>OPTIONS</code></font></i>
    by using the command<br>
    <blockquote>
      <pre><font color="#663300">ASM101S.py --help</font>
</pre>
    </blockquote>
    The action of the assembler is roughly the following:<br>
    <ol>
      <li>(Optionally.)&nbsp; Loads the macro definitions found in the
        assembly-language source-code files (*.asm) found in the <font
          color="#663300"><code><i>LIBRARY</i></code></font>
        folder.&nbsp; (More on this is in the next section.)<br>
      </li>
      <li>Load all of the <font color="#663300"><code><i>SOURCEx</i>.asm</code></font>
        files specified on the command line, in the order that they are
        specified.&nbsp; Macro definitions should precede any
        source-code files using those macros, but the ordering of macro
        files among themselves is not significant.</li>
      <li>Process the entire set of source code which has been loaded.</li>
      <li>Output an assembly report (on <font color="#663300"><code>stdout</code></font>)
        and if there were no fatal errors, an AP-101 object-code file
        that contains the results of the assembly process.<br>
      </li>
    </ol>
    Recognize that at least as far as Space Shuttle flight software is
    concerned, the full flight software consists of a large number of
    assembly language modules, along with even more modules written in
    the high-level language HAL/S.&nbsp; So as noted above in a
    slightly-different way, the object file emitted by the assembler is
    unlikely to be a full executable program — or <i>load file</i> in
    this particular jargon — but rather just one of many object files
    which need to be <i>linked</i> by an AP-101 linker utility before
    becoming an executable program.<br>
    <br>
    Beyond the assembler itself, there is also a <b>bash</b> shell
    script — useful in Linux or Mac OS, but usually not in Windows since
    the <b>bash</b> command shell isn't commonly available in Windows
    without extra effort on your part — that performs a kind of
    regression test on <b>ASM101S</b> by assembling <a
      moz-do-not-send="true" href="#wildThings">legacy AP-101S
      assembly-language source-code files</a> for which a contemporary
    assembly listing made by the original AP-101S assembler has
    survived, and performing a byte-by-byte comparison of <b>ASM101S</b>'s



    assemblies vs the original assemblies.&nbsp; It is run simply as<br>
    <blockquote>
      <pre><font color="#663300">regressionASM101S.sh</font><br></pre>
    </blockquote>
    At this writing, 205 source-code files are included in the
    regression test, comprising around 17K lines of source code.&nbsp;
    Yes, that's a relatively small test, but I'm not responsible for the
    lack of surviving test material.&nbsp; Unfortunately, I cannot claim
    that <b>ASM101S</b> is a fast program, so this process is not as
    fast as I might hope, nor are status messages provided as long as
    the tests are successful, so you may find yourself confused that
    nothing appears to be happening.&nbsp; If you run the test instead
    as<br>
    <blockquote>
      <pre><font color="#663300">regressionASM101S.sh -v</font><br></pre>
    </blockquote>
    it will at least display the names of the files it is checking.<br>
    <h1><a name="aBriefTour"></a>A Brief Tour of the Assembly Process</h1>
    <p>As a more-concrete example than the abstract description in the
      preceding section, consider assembly of the "ACOS" module from the
      AP-101S runtime library of the HAL/S compiler.&nbsp; We'll learn
      more details about the runtime library and what's required for
      assembling it in the sections that follow.&nbsp; For our purposes
      at the moment, I'll content myself by saying that if you follow
      the installation instructions (given later) you can perform this
      assembly with these steps:<br>
    </p>
    <blockquote>
      <pre>cd "virtualagc/yaShuttle/Source Code/PASS.REL32V0/RUNASM"<br>ASM101S.py --library=../RUNMAC ACOS.asm<br></pre>
    </blockquote>
    <p>(Or at least, that's how you'd do it in Linux or Mac OS.&nbsp; In
      Windows you'd have to use '\' in place of '/'.)<br>
    </p>
    <p>Here's what the AP-101S assembly-language source code for the
      ACOS module looks like prior to assembly:<br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <td valign="top">
            <pre><font color="#663300"> TITLE 'ACOS -- SINGLE PRECISION INVERSE SINE-COSINE FUNCTION'          00000100<br>*<br>* WHEN DATA_REMOTE IS IN EFFECT, THE LDM INSTRUCTIONS ARE NEEDED<br>* AROUND THE CALL TO THIS RTL ROUTINE BECAUSE R1/R3 IS USED AS<br>* A BASE REGISTER. (CR12620)<br>*<br>*  ACOS:  INVERSE SINE-COSINE(SINGLE)                                   00000200<br>*                                                                       00000300<br>*        1. INPUT AND OUTPUT VIA F0.                                    00000400<br>*        2. FOR 0&lt;=X&lt;=1/2, COMPUTE ASIN(X) BY A RATIONAL FUNCTION.      00000500<br>*        3. FOR 1/2&lt;X&lt;=1, USE ASIN(X)=PI/2-2*ASIN(SQRT((1-X)/2)).       00000600<br>*        4. FOR X&lt;0, USE ASIN(X)=-ASIN(-X).                             00000700<br>*        5. ACOS(X)=PI/2-ASIN(X).                                       00000800<br>*        6. ERROR GIVEN IF |X|&gt;1.                                       00000900<br>*                                                                       00001000<br>*IBM CR #SS8244- RETURN PI FOR ARCCOS ARGUMENT &lt; -1; 8/14/81   A.CLOSE  00001010<br>* REGISTER R4 IS USED AS A SWITCH-                                      00001100<br>*   BIT 0 IS USED TO SIGNAL WHETHER THIS PROCEDUER IS                   00001200<br>*   CALLED AS ACOS(ON) OR ASIN(OFF). BIT 1 IS USED TO SIGNAL            00001300<br>*   IF ARG. IS POS.(OFF) OR NEG.(ON).BIT 2 IS USED TO SIGNAL            00001400<br>*   ABS. VALUE OF ARG.,IF GREATER THAN 1/2(ON) ELSE (OFF)               00001500<br>*                                                                       00001600<br>         MACRO                                                          00001700<br>         WORKAREA                                                       00001800<br>SAVE6    DS    D              TO SAVE REGISTERS F6,F7                   00001900<br>SWITCH   DS    F              TO SAVE R4 ACROSS INTRINSIC CALL          00002000<br>         MEND                                                           00002100<br>ACOS     <font color="#ff0000">AMAIN</font> ACALL=YES                                                00002200<br>*COMPUTES ARC-COSINE(X) OF SINGLE PRECISION SCALAR                      00002300<br>         <font color="#ff0000">INPUT</font> F0             SCALAR SP                                 00002400<br>         <font color="#ff0000">OUTPUT</font> F0            SCALAR SP RADIANS                         00002500<br>         <font color="#ff0000">WORK</font>  R1,R2,R3,R4,R5,R6,R7,F1,F2,F3,F4,F6                      00002600<br>         SR    R4,R4          SIGNAL ACOS ENTRY                         00002700<br>         OHI   R4,X'8000'                                               00002800<br>         B     MERGE                                                    00002900<br>ASIN     <font color="#ff0000">AENTRY</font>                                                         00003000<br>* COMPUTES ARC-SINE(X) OF SINGLE PRECISION SCALAR                       00003100<br>         <font color="#ff0000">INPUT</font> F0             SCALAR SP                                 00003200<br>         <font color="#ff0000">OUTPUT</font> F0            SCALAR SP RADIANS                         00003300<br>         <font color="#ff0000">WORK</font>  R2,R3,R4,F2,F3,F4,F6                                     00003400<br>         SR    R4,R4          SIGNAL ASIN ENTRY                         00003500<br>*                                                                       00003600<br>MERGE    STED  F6,SAVE6       SAVE REGISTERS F6,F7                      00003700<br>         LER   F6,F0          GET ARGUMENT IN F6                        00003800<br>         BNM   POS            AND TEST SIGN                             00003900<br>         OHI   R4,X'4000'     SIGNAL NEG. ARG.                          00004000<br>         LECR  F0,F0          GET |X|                                   00004100<br>*                                                                       00004200<br>POS      CE    F0,HALF        SKIP TO 'SMALL' IF                        00004300<br>         BNH   SMALL          |X|&lt;=1/2                                  00004400<br>*                                                                       00004500<br>*  Z=SQRT((1-|X|)/2) IF |X|^&gt;|1/2                                       00004600<br>*                                                                       00004700<br>         OHI   R4,X'2000'     SIGNAL |X|&gt;1/2                            00004800<br>         LECR  F0,F0                                                    00004900<br>         AE    F0,ONE         1-|X| IN F0                               00005000<br>         BNP   EXPRESS        BRANCH IF |X|&gt;=1                          00005100<br>*                                                                       00005200<br>         LER   F6,F0                                                    00005300<br>         ME    F6,HALF        Z**2 IN F6                                00005400<br>         AER   F0,F0          4*Z**2 IN F0                              00005500<br>*                                                                       00005600<br>         ST    R4,SWITCH      SAVE R4 ACROSS INTRINSIC CALL             00005700<br>         <font color="#ff0000">ABAL</font>  SQRT           GET 2Z IN F0 BY CALL TO                   00005800<br>         L     R4,SWITCH      RESTORE R4                                00005900<br>         B     POLY           SQRT, AND RETURN TO POLY                  00006000<br>*                                                                       00006100<br>SMALL    CE    F0,UNFLO                                                 00006200<br>         BNH   TESTS                                                    00006300<br>         MER   F6,F6          X**2 IN F6                                00006400<br>*                                                                       00006500<br>* COMPUTE ASIN(Z) HERE BY RATIONAL FUNCTION                             00006600<br>*                                                                       00006700<br>POLY     LE    F4,C2                                                    00006800<br>         AER   F4,F6                                                    00006900<br>         LE    F2,D2                                                    00007000<br>         DER   F2,F4          (C2+Z**2)/D2                              00007100<br>         AE    F2,C1                                                    00007200<br>         AER   F2,F6          C1+Z**2+(C2+Z**2)/D2                      00007300<br>         ME    F6,D1                                                    00007400<br>         DER   F6,F2                                                    00007500<br>         LE    F3,ROUND       ROUNDING NUMBER IN F3,                    00007600<br>         LER   F2,F0          AS LOW HALF OF 2Z.                        00007700<br>         MER   F0,F6                                                    00007800<br>         AEDR  F0,F2          ROUNDING OCCURS HERE                      00007900<br>*                                                                       00008000<br>*  REVERSE REDUCTIONS TO GIVE ACTUAL ANSWER                             00008100<br>*                                                                       00008200<br>TESTS    TRB    R4,X'A000'  IF ACOS ENTRY                               00008300<br>         BNM   TSTNEG         OR |X|&gt;1/2 BUT NOT BOTH,                  00008400<br>         LECR  F0,F0          SUBTRACT RESULT                           00008500<br>         AED   F0,PIOV2       FROM PI/2                                 00008600<br>*                                                                       00008700<br>TSTNEG   TRB    R4,X'4000'  COMPLEMENT                                  00008800<br>         BNO   EXIT           IF ARGUMENT WAS NEGATIVE.                 00008900<br>         LER   F0,F0          CHECK FOR ARG=0(HARDWARE BUG)             00009000<br>         BZ    NOLECR                                                   00009100<br>         LECR  F0,F0                                                    00009200<br>NOLECR   TRB   R4,X'C000'     AND ADD PI TO                             00009300<br>         BNO   EXIT           RESULT IF ACOS ENTRY                      00009400<br>         AE    F0,PI          AND ARGUMENT&lt;0.                           00009500<br>*                                                                       00009600<br>EXIT     LED   F6,SAVE6       RESTORE F6,F7                             00009700<br>         <font color="#ff0000">AEXIT</font>                AND EXIT                                  00009800<br>*                                                                       00009900<br>EXPRESS  BZ    TESTS          SKIP POLYNOMIAL IF |X|=1                  00010000<br>         <font color="#ff0000">AERROR</font> 10            |ARG|&gt;1                                   00010100<br>         LE    F0,PIOV2                                                 00010200<br>         TRB   R4,X'8000'     ASIN CALL?                                00010300<br>         BZ    TSTNEG         YES, CHECK SIGN                           00010400<br>         TRB   R4,X'4000'     X=-1?                                     00010500<br>         BZ    RET0           NO,RETURN 0                               00010501<br>         LE    F0,PI          YES, RETURN PI                            00010502<br>         B     EXIT                                                     00010503<br>RET0     SER   F0,F0                                                    00010504<br>         B     EXIT                                                     00010600<br>*                                                                       00010700<br>         DS    0F                                                       00010800<br>PI       DC    X'413243F7'    PI                                        00010900<br>PIOV2    DC    X'411921FB'    PI/2                                      00011000<br>ROUND    DC    X'5FFFFFFF'                                              00011100<br>UNFLO    DC    X'3E100000'     16**(-3)                                 00011200<br>ONE      DC    X'41100000'    1.0                                       00011300<br>HALF     DC    X'40800000'    0.5                                       00011400<br>D1       DC    X'C08143C7'    -0.5049404                                00011500<br>C1       DC    X'C13B446A'    -3.7042025                                00011600<br>D2       DC    X'C11406BF'    -1.2516474                                00011700<br>C2       DC    X'C11DB034'    -1.8555182                                00011800<br>         <font color="#ff0000">ACLOSE</font>                                                         00011900</font><br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    <p>Simple, right?&nbsp; Well ... perhaps not so much!&nbsp; In fact,
      it's more complex than it appears at first sight.&nbsp; You'll
      notice that strewn throughout the source code are various
      "instructions" that I've highlighted in <font color="#ff0000">red</font>
      to make them stand out.&nbsp; These are actually invocations of
      "macros" (more on this below), each of which may be expanded into
      multiple lines of source code at assembly-time.&nbsp; Or perhaps
      not:&nbsp; The <font color="#ff0000"><code>INPUT</code></font>
      macro, for example, in this example turns out to "expand" to
      nothing at all.&nbsp; In contrast, other of the macros may
      themselves invoke other macros, which may in turn invoke other
      macros, and so on.&nbsp; For example, the <font color="#ff0000"><code>ACLOSE</code></font>
      macro appearing at the bottom of the listing above invokes the
      macro <font color="#ff0000"><code>ERRPARMS</code></font>.&nbsp;
      The macros themselves (in this example) provide the machinery
      needed to interface assembly-language subroutines to HAL/S code
      calling those subroutines, but macros can serve many other
      purposes in other source-code files.<br>
    </p>
    <p>Not that we're in a position to understand it fully without a lot
      of study, here's what the source code for that very same macro <font
        color="#ff0000"><code>ACLOSE</code></font> looks like:<br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <td valign="top">
            <pre><font color="#ff0000">         MACRO                                                          00000100<br>         ACLOSE                                                         00000200<br>         GBLA  &amp;ENTCNT                                                  00000300<br>         GBLB  &amp;INPUT(20),&amp;OUTPUT(20)                                   00000400<br>         GBLC  &amp;NAMES(20)                                               00000500<br>         ERRPARMS                                                       00000600<br>&amp;I       SETA  1                                                        00000700<br>.LOOP    AIF   (&amp;INPUT(&amp;I)).INOK                                        00000800<br>         MNOTE 1,'INPUT NOT SPECIFIED FOR &amp;NAMES(&amp;I)'                   00000900<br>.INOK    AIF   (&amp;OUTPUT(&amp;I)).OUTOK                                      00001000<br>         MNOTE 1,'OUTPUT NOT SPECIFIED FOR &amp;NAMES(&amp;I)'                  00001100<br>.OUTOK   ANOP                                                           00001200<br>&amp;I       SETA  &amp;I+1                                                     00001300<br>         AIF   (&amp;I LE &amp;ENTCNT).LOOP                                     00001400<br>         END                                                            00001500<br>         MEND                                                           00001600</font><br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    <p>I've highlighted this entirely in <font color="#ff0000">red</font>
      because even though many macro definitions include actual AP-101S
      instructions and pseudo-ops, this particular macro definition
      consists entirely of statements in the macro language.&nbsp; About
      the only thing here that's immediately understandable — and only
      because I mentioned it earlier! — is that <font color="#ff0000"><code>ERRPARMS</code></font>
      is the invocation of another macro.<br>
    </p>
    <p>Now that we recognize that the assembly listing of ACOS may not
      look too much like the original source code, the following is an
      excerpt from the assembly report produced when <b>ASM101S</b>
      assembles ACOS.&nbsp; In the interest of saving a little space,
      I've removed such assembler-generated items as the symbol
      table.&nbsp; At the same time, I've&nbsp; highlighted the macro
      expansions in <font color="#ff0000">red</font>:<br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <td valign="top">
            <pre><font color="#663300">         ACOS -- SINGLE PRECISION INVERSE SINE-COSINE FUNCTION                                                 PAGE    2<br>  LOC  OBJECT CODE   ADR1 ADR2      SOURCE STATEMENT                                               ASM101S 0.00 10/20/24<br>                                  2 *                                                                               <br>                                  3 * WHEN DATA_REMOTE IS IN EFFECT, THE LDM INSTRUCTIONS ARE NEEDED                <br>                                  4 * AROUND THE CALL TO THIS RTL ROUTINE BECAUSE R1/R3 IS USED AS                  <br>                                  5 * A BASE REGISTER. (CR12620)                                                    <br>                                  6 *                                                                               <br>                                  7 *  ACOS:  INVERSE SINE-COSINE(SINGLE)                                   00000200<br>                                  8 *                                                                       00000300<br>                                  9 *        1. INPUT AND OUTPUT VIA F0.                                    00000400<br>                                 10 *        2. FOR 0&lt;=X&lt;=1/2, COMPUTE ASIN(X) BY A RATIONAL FUNCTION.      00000500<br>                                 11 *        3. FOR 1/2&lt;X&lt;=1, USE ASIN(X)=PI/2-2*ASIN(SQRT((1-X)/2)).       00000600<br>                                 12 *        4. FOR X&lt;0, USE ASIN(X)=-ASIN(-X).                             00000700<br>                                 13 *        5. ACOS(X)=PI/2-ASIN(X).                                       00000800<br>                                 14 *        6. ERROR GIVEN IF |X|&gt;1.                                       00000900<br>                                 15 *                                                                       00001000<br>                                 16 *IBM CR #SS8244- RETURN PI FOR ARCCOS ARGUMENT &lt; -1; 8/14/81   A.CLOSE  00001010<br>                                 17 * REGISTER R4 IS USED AS A SWITCH-                                      00001100<br>                                 18 *   BIT 0 IS USED TO SIGNAL WHETHER THIS PROCEDUER IS                   00001200<br>                                 19 *   CALLED AS ACOS(ON) OR ASIN(OFF). BIT 1 IS USED TO SIGNAL            00001300<br>                                 20 *   IF ARG. IS POS.(OFF) OR NEG.(ON).BIT 2 IS USED TO SIGNAL            00001400<br>                                 21 *   ABS. VALUE OF ARG.,IF GREATER THAN 1/2(ON) ELSE (OFF)               00001500<br>                                 22 *                                                                       00001600<br>                                 23          MACRO                                                          00001700<br>                                 24          WORKAREA                                                       00001800<br>                                 25 SAVE6    DS    D              TO SAVE REGISTERS F6,F7                   00001900<br>                                 26 SWITCH   DS    F              TO SAVE R4 ACROSS INTRINSIC CALL          00002000<br>                                 27          MEND                                                           00002100<br>                                 28 ACOS     AMAIN ACALL=YES                                                00002200<br><font color="#ff0000">                                 29+*********************************************************************** 01-AMAIN<br>                                 30+*                                                                       01-AMAIN<br>                                 31+*        PRIMARY ENTRY POINT                                            01-AMAIN<br>                                 32+*                                                                       01-AMAIN<br>                                 33+*********************************************************************** 01-AMAIN<br>00000                            34+ACOS     CSECT                                                          01-AMAIN<br>00000                            35+STACK    DSECT                                                          01-AMAIN<br>                                 36+*        DS    18H            STANDARD STACK AREA DEFINITION            01-AMAIN<br>00000                            37+         DS    F              PSW (LEFT HALF)                           01-AMAIN<br>00002                            38+         DS    2F             R0,R1                                     01-AMAIN<br>00006                            39+ARG2     DS    F              R2                                        01-AMAIN<br>00008                            40+         DS    F              R3                                        01-AMAIN<br>0000A                            41+ARG4     DS    F              R4                                        01-AMAIN<br>0000C                            42+ARG5     DS    F              R5                                        01-AMAIN<br>0000E                            43+ARG6     DS    F              R6                                        01-AMAIN<br>00010                            44+ARG7     DS    F              R7                                        01-AMAIN<br>                                 45+*        END OF STANDARD STACK AREA                                     01-AMAIN<br>00012                            46+SAVE6    DS    D              TO SAVE REGISTERS F6,F7                   02-WORKAREA<br>00016                            47+SWITCH   DS    F              TO SAVE R4 ACROSS INTRINSIC CALL          02-WORKAREA<br>00018                            48+STACKEND DS    0F             END OF COMBINED STACK AREA                01-AMAIN<br>00000                            49+ACOS     CSECT                                                          01-AMAIN<br>                                 50+         USING STACK,0        ADDRESS STACK AREA                        01-AMAIN<br>00000 E0FB 0018      0018        51+         IAL   0,STACKEND-STACK SET STACK SIZE                          01-AMAIN<br>00002 B624 0000      0009 0000   52+         NIST  9(0),0         CLEAR ON ERROR INFO (LCL DATA PTR)        01-AMAIN</font><br>                                 54 *COMPUTES ARC-COSINE(X) OF SINGLE PRECISION SCALAR                      00002300<br>                                 55          INPUT F0                                                       00002400<br><font color="#ff0000">                                 56+F0       EQU   0                                                        01-INPUT</font><br>                                 58          OUTPUT F0                                                      00002500<br>                                 60          WORK  R1,R2,R3,R4,R5,R6,R7,F1,F2,F3,F4,F6                      00002600<br><font color="#ff0000">                                 61+R1       EQU   1                                                        01-WORK<br>                                 62+R2       EQU   2                                                        01-WORK<br>                                 63+R3       EQU   3                                                        01-WORK<br>                                 64+R4       EQU   4                                                        01-WORK<br>                                 65+R5       EQU   5                                                        01-WORK<br>                                 66+R6       EQU   6                                                        01-WORK<br>                                 67+R7       EQU   7                                                        01-WORK<br>                                 68+F1       EQU   1                                                        01-WORK<br>                                 69+F2       EQU   2                                                        01-WORK<br>                                 70+F3       EQU   3                                                        01-WORK<br>                                 71+F4       EQU   4                                                        01-WORK<br>                                 72+****** WARNING: F6 MUST BE PRESERVED ACROSS CALLS                       01-WORK<br>                                 73+F6       EQU   6                                                        01-WORK</font><br>00004 0CE4                       75          SR    R4,R4          SIGNAL ACOS ENTRY                         00002700<br>00005 B2E4 8000           8000   76          OHI   R4,X'8000'                                               00002800<br>00007 DF14           000D 0005   77          B     MERGE                                                    00002900<br>                                 78 ASIN     AENTRY                                                         00003000<br><font color="#ff0000">                                 79+*********************************************************************** 01-AENTRY<br>                                 80+*                                                                       01-AENTRY<br>                                 81+*        SECONDARY ENTRY POINT                                          01-AENTRY</font><br>------------------------------------------------------------------------------------------------------------------------<br>         ACOS -- SINGLE PRECISION INVERSE SINE-COSINE FUNCTION                                                 PAGE    3<br>  LOC  OBJECT CODE   ADR1 ADR2      SOURCE STATEMENT                                               ASM101S 0.00 10/20/24<br><font color="#ff0000">                                 82+*                                                                       01-AENTRY<br>                                 83+*********************************************************************** 01-AENTRY<br>00008                            84+ASIN     DS    0H                                                       01-AENTRY<br>                                 85+         ENTRY ASIN                                                     01-AENTRY<br>00008 E0FB 0018      0018        86+         IAL   0,STACKEND-STACK SET STACK SIZE                          01-AENTRY<br>0000A B624 0000      0009 0000   87+         NIST  9(0),0         CLEAR ERROR VECTOR POINTER                01-AENTRY</font><br>                                 89 * COMPUTES ARC-SINE(X) OF SINGLE PRECISION SCALAR                       00003100<br>                                 90          INPUT F0                                                       00003200<br>                                 92          OUTPUT F0                                                      00003300<br>                                 94          WORK  R2,R3,R4,F2,F3,F4,F6                                     00003400<br><font color="#ff0000">                                 95+****** WARNING: F6 MUST BE PRESERVED ACROSS CALLS                       01-WORK</font><br>0000C 0CE4                       97          SR    R4,R4          SIGNAL ASIN ENTRY                         00003500<br>                                 98 *                                                                       00003600<br>0000D 3EF8 0012      0012        99 MERGE    STED  F6,SAVE6       SAVE REGISTERS F6,F7                      00003700<br>0000F 7EE0                      100          LER   F6,F0          GET ARGUMENT IN F6                        00003800<br>00010 DD0C           0014 0003  101          BNM   POS            AND TEST SIGN                             00003900<br>00011 B2E4 4000           4000  102          OHI   R4,X'4000'     SIGNAL NEG. ARG.                          00004000<br>00013 78E8                      103          LECR  F0,F0          GET |X|                                   00004100<br>                                104 *                                                                       00004200<br>00014 48FF 0054      006A 0054  105 POS      CE    F0,HALF        SKIP TO 'SMALL' IF                        00004300<br>00016 DE3C           0026 000F  106          BNH   SMALL          |X|&lt;=1/2                                  00004400<br>                                107 *                                                                       00004500<br>                                108 *  Z=SQRT((1-|X|)/2) IF |X|^&gt;|1/2                                       00004600<br>                                109 *                                                                       00004700<br>00017 B2E4 2000           2000  110          OHI   R4,X'2000'     SIGNAL |X|&gt;1/2                            00004800<br>00019 78E8                      111          LECR  F0,F0                                                    00004900<br>0001A 50F7 004C      0068 004C  112          AE    F0,ONE         1-|X| IN F0                               00005000<br>0001C DEC8           004F 0032  113          BNP   EXPRESS        BRANCH IF |X|&gt;=1                          00005100<br>                                114 *                                                                       00005200<br>0001D 7EE0                      115          LER   F6,F0                                                    00005300<br>0001E 66F7 004A      006A 004A  116          ME    F6,HALF        Z**2 IN F6                                00005400<br>00020 50E0                      117          AER   F0,F0          4*Z**2 IN F0                              00005500<br>                                118 *                                                                       00005600<br>00021 342C           0016       119          ST    R4,SWITCH      SAVE R4 ACROSS INTRINSIC CALL             00005700<br>                                120          ABAL  SQRT                                                     00005800<br><font color="#ff0000">                                121+         EXTRN #QSQRT                                                   01-ABAL<br>00022 E4F7                      122+         DC    X'E4F7'          CALL INTRINSIC INDIRECTLY               01-ABAL<br>00023 3800                      123+         DC    Y(#QSQRT+X'3800')  THROUGH QCON                          01-ABAL</font><br>00024 1C2C           0016       124          L     R4,SWITCH      RESTORE R4                                00005900<br>00025 DF10           002A 0004  125          B     POLY           SQRT, AND RETURN TO POLY                  00006000<br>                                126 *                                                                       00006100<br>00026 48FF 003E      0066 003E  127 SMALL    CE    F0,UNFLO                                                 00006200<br>00028 DE48           003B 0012  128          BNH   TESTS                                                    00006300<br>00029 66E6                      129          MER   F6,F6          X**2 IN F6                                00006400<br>                                130 *                                                                       00006500<br>                                131 * COMPUTE ASIN(Z) HERE BY RATIONAL FUNCTION                             00006600<br>                                132 *                                                                       00006700<br>0002A 7CF7 0046      0072 0046  133 POLY     LE    F4,C2                                                    00006800<br>0002C 54E6                      134          AER   F4,F6                                                    00006900<br>0002D 7AF7 0041      0070 0041  135          LE    F2,D2                                                    00007000<br>0002F 6AE4                      136          DER   F2,F4          (C2+Z**2)/D2                              00007100<br>00030 52F7 003C      006E 003C  137          AE    F2,C1                                                    00007200<br>00032 52E6                      138          AER   F2,F6          C1+Z**2+(C2+Z**2)/D2                      00007300<br>00033 66F7 0037      006C 0037  139          ME    F6,D1                                                    00007400<br>00035 6EE2                      140          DER   F6,F2                                                    00007500<br>00036 7BF7 002C      0064 002C  141          LE    F3,ROUND       ROUNDING NUMBER IN F3,                    00007600<br>00038 7AE0                      142          LER   F2,F0          AS LOW HALF OF 2Z.                        00007700<br>00039 60E6                      143          MER   F0,F6                                                    00007800<br>0003A 50EA                      144          AEDR  F0,F2          ROUNDING OCCURS HERE                      00007900<br>                                145 *                                                                       00008000<br>                                146 *  REVERSE REDUCTIONS TO GIVE ACTUAL ANSWER                             00008100<br>                                147 *                                                                       00008200<br>0003B B3E4 A000           A000  148 TESTS    TRB   R4,X'A000'  IF ACOS ENTRY                                00008300<br>0003D DD0C           0041 0003  149          BNM   TSTNEG         OR |X|&gt;1/2 BUT NOT BOTH,                  00008400<br>0003E 78E8                      150          LECR  F0,F0          SUBTRACT RESULT                           00008500<br>0003F 50FF 0021      0062 0021  151          AED   F0,PIOV2       FROM PI/2                                 00008600<br>                                152 *                                                                       00008700<br>00041 B3E4 4000           4000  153 TSTNEG   TRB   R4,X'4000'  COMPLEMENT                                   00008800<br>00043 DE20           004C 0008  154          BNO   EXIT           IF ARGUMENT WAS NEGATIVE.                 00008900<br>00044 78E0                      155          LER   F0,F0          CHECK FOR ARG=0(HARDWARE BUG)             00009000<br>00045 DC04           0047 0001  156          BZ    NOLECR                                                   00009100<br>00046 78E8                      157          LECR  F0,F0                                                    00009200<br>00047 B3E4 C000           C000  158 NOLECR   TRB   R4,X'C000'     AND ADD PI TO                             00009300<br>00049 DE08           004C 0002  159          BNO   EXIT           RESULT IF ACOS ENTRY                      00009400<br>0004A 50F7 0014      0060 0014  160          AE    F0,PI          AND ARGUMENT&lt;0.                           00009500<br>                                161 *                                                                       00009600<br>------------------------------------------------------------------------------------------------------------------------<br>         ACOS -- SINGLE PRECISION INVERSE SINE-COSINE FUNCTION                                                 PAGE    4<br>  LOC  OBJECT CODE   ADR1 ADR2      SOURCE STATEMENT                                               ASM101S 0.00 10/20/24<br>0004C 7EF8 0012      0012       162 EXIT     LED   F6,SAVE6       RESTORE F6,F7                             00009700<br>                                163          AEXIT AND                                                      00009800<br><font color="#ff0000">                                164+*********RETURN TO CALLER********************************************** 01-AEXIT<br>0004E                           165+         DS    0H                                                       01-AEXIT<br>0004E 97E8                      166+$RET1    SRET  7,0        RETURN TO CALLER                              01-AEXIT<br>                                167+*********************************************************************** 01-AEXIT</font><br>                                169 *                                                                       00009900<br>0004F DC56           003B 0015  170 EXPRESS  BZ    TESTS          SKIP POLYNOMIAL IF |X|=1                  00010000<br>                                171          AERROR 10                                                      00010100<br><font color="#ff0000">                                172+*********ISSUE SEND ERROR SVC****************************************** 01-AERROR<br>00050 C9FB 0074      0074       173+         SVC   AERROR1       ISSUE SEND ERROR SVC                       01-AERROR<br>                                174+*********SEND ERROR SVC RETURNS CONTROL FOR STANDARD FIXUP************* 01-AERROR</font><br>00052 78F7 000E      0062 000E  175          LE    F0,PIOV2                                                 00010200<br>00054 B3E4 8000           8000  176          TRB   R4,X'8000'     ASIN CALL?                                00010300<br>00056 DC5A           0041 0016  177          BZ    TSTNEG         YES, CHECK SIGN                           00010400<br>00057 B3E4 4000           4000  178          TRB   R4,X'4000'     X=-1?                                     00010500<br>00059 DC0C           005D 0003  179          BZ    RET0           NO,RETURN 0                               00010501<br>0005A 78F7 0004      0060 0004  180          LE    F0,PI          YES, RETURN PI                            00010502<br>0005C DF46           004C 0011  181          B     EXIT                                                     00010503<br>0005D 58E0                      182 RET0     SER   F0,F0                                                    00010504<br>0005E DF4E           004C 0013  183          B     EXIT                                                     00010600<br>                                184 *                                                                       00010700<br>00060                           185          DS    0F                                                       00010800<br>00060 413243F7                  186 PI       DC    X'413243F7'    PI                                        00010900<br>00062 411921FB                  187 PIOV2    DC    X'411921FB'    PI/2                                      00011000<br>00064 5FFFFFFF                  188 ROUND    DC    X'5FFFFFFF'                                              00011100<br>00066 3E100000                  189 UNFLO    DC    X'3E100000'     16**(-3)                                 00011200<br>00068 41100000                  190 ONE      DC    X'41100000'    1.0                                       00011300<br>0006A 40800000                  191 HALF     DC    X'40800000'    0.5                                       00011400<br>0006C C08143C7                  192 D1       DC    X'C08143C7'    -0.5049404                                00011500<br>0006E C13B446A                  193 C1       DC    X'C13B446A'    -3.7042025                                00011600<br>00070 C11406BF                  194 D2       DC    X'C11406BF'    -1.2516474                                00011700<br>00072 C11DB034                  195 C2       DC    X'C11DB034'    -1.8555182                                00011800<br>                                196          ACLOSE                                                         00011900<br><font color="#ff0000">                                197+         LTORG                                                          02-ERRPARMS<br>                                198+****************ERROR PARAMETER AREA*********************************** 02-ERRPARMS<br>00074                           199+#LACOS   CSECT                                                          02-ERRPARMS<br>                                200+****  ACOS SENDS THE FOLLOWING ERROR                                    02-ERRPARMS<br>                                202+****  ERROR NUMBER 10 IN GROUP 4                                        02-ERRPARMS<br>00074 0014                      204+AERROR1  DC    H'20'          SVC CODE FOR SEND ERROR                   02-ERRPARMS<br>00075 040A                      205+         DC    Y(4*256+10) 8 BIT GROUP AND NUMBER                       02-ERRPARMS<br>                                206+****************END OF ERROR PARAMETER AREA**************************** 02-ERRPARMS<br>                                207+         END                                                            01-ACLOSE</font></font><br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    <p>As I hinted earlier, one nice feature (for us!) of the HAL/S
      AP-101S runtime library is that we have contemporary
      assembly-listings created by the original assembler, which is of
      great help in verifying that <b>ASM101S</b> produces correct
      results.&nbsp; <b>ASM101S</b> tries to mimic the assembly
      listings produced by that original assembler, but not obsessively
      so.&nbsp; If you're interested — and if you have a really big
      display or multiple monitors! — clicking <a
href="https://raw.githubusercontent.com/virtualagc/virtualagc/refs/heads/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNLST/ACOS.txt"
        target="_blank" moz-do-not-send="true">this link</a> hopefully
      opens up the original assembly listing in a new window or tab
      (depending on your browser's configuration), so that you can
      visually compare the contemporary and new listings side by side.<br>
    </p>
    <h1><a name="macros"></a>Macro-Library Folders<br>
    </h1>
    AP-101 assembly language is a macro language.&nbsp; The Shuttle
    software developers made constant and frequent use of these macro
    capabilities, to the point where it's difficult even to find an
    AP-101 assembly-language file that is not dependent on macros.&nbsp;
    Thus, we have to understand various things about this macro
    capability from the very beginning, rather than concentrating merely
    on translation of AP-101 instructions into object code and leaving
    the topic of macros for future consideration.&nbsp; You can read
    about it for yourself in the IBM 360 assembler language manual, in
    which <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/59/mode/1up?view=theater">the





      discussion of macros fully occupies the entire 2nd half of that
      document</a>.&nbsp; Learning the syntax and other usage details of
    macros is as important for understanding the flight software, or
    perhaps even more important, and likely more difficult, than
    understanding the AP-101 instruction set.<br>
    <br>
    But I won't talk here about the technical details of macro
    definitions or expansions.&nbsp; Rather, here I merely need to talk
    about the organizational principles of the associated source-code
    files.<br>
    <p>When assembling an assembly-language file whose code depends on
      macros, there are three different ways in which the definitions of
      those macros may be made available to the code using them:<br>
    </p>
    <ol>
      <li>Macro definitions may explicitly appear within the
        assembly-language file in which they're used, in which case the
        scope of those macro definitions is that file alone.<br>
      </li>
      <li> Macro definitions may appear in a "macro library", and the
        macros defined in the library are accessible to any
        assembly-language file using that library.&nbsp; Speaking
        generally, the <a moz-do-not-send="true" href="HAL.html">HAL/S
          compiler</a>'s runtime library (which is written in AP-101
        assembly language) has a macro library known as RUNMAC, whereas
        the Shuttle flight software has a macro library known as
        MLIB80.&nbsp; But each release of the flight software has a
        version of MLIB80 specific to that release.</li>
      <li>Macro definitions may appear, along with non-macro code, in
        AP-101 assembly-language files "included" by other AP-101
        assembly-language files via an assembly-language pseudo-op
        called <font color="#663300"><code>COPY</code></font>.&nbsp; (<b>Note</b>:
        <a moz-do-not-send="true" href="#forbiddenCOPY"><font
            color="#663300"><code>COPY</code></font>'d files supposedly
          cannot contain macro definitions in System/360, but can do so
          in AP-101.</a>)<br>
      </li>
    </ol>
    <ul>
    </ul>
    In the current implementation of <b>ASM101S</b>, macro libraries
    are literally just folders of assembly-language files.&nbsp; Recall
    from the preceding section that <b>ASM101S</b> is invoked with one
    or more optional command-line arguments of the form <font
      color="#663300"><code>--library=<i>LIBRARY</i></code></font>.&nbsp;














    <font color="#663300"><code><i>LIBRARY</i></code></font> is just a
    path to a macro-library folder.&nbsp; Macro definitions in any
    libraries specified in this manner are loaded by the assembler along
    with the specific source-code file(s) being assembled, thus
    automatically making <i>all</i> of the macro definitions in that
    library available during the assembly process.<br>
    <br>
    Relative to where AP-101 assembly-language source code is stored in
    the source-code tree, <b>ASM101S</b> would typically be used with
    either the option <font color="#663300"><code>--library=../RUNMAC</code></font>
    or <font color="#663300"><code>--library=../MLIB80</code></font>,
    assuming the current working directory was the one storing the
    source-code files being assembled.<br>
    <br>
    There's a slight problem, though, in that for some reason, all of
    the assembly-language files included via <font color="#663300"><code>COPY</code></font>
    pseudo-ops are <i>also</i> located within the macro libraries,
    intermixed with the files intended to contain only macros.&nbsp; But
    we do not want any of the code from these <font color="#663300"><code>COPY</code></font>'able














    files (even if there are some macro definitions within them) to be
    automatically be made available during assembly.&nbsp; Rather, we
    want their code to be made available <i>only</i> when they're <font
      color="#663300"><code>COPY</code></font>'d!&nbsp; Or to put it
    differently, categories #2 and #3 of files containing macro
    definitions, as discussed above, must be mutually exclusive.<br>
    <br>
    It's unclear to my why the Shuttle developers chose to house these
    mutually-exclusive categories of files together in the same
    directory — or as they thought of it, the same "Partitioned Data
    Set" (PDS) —, nor how they handled this ambiguity in their
    assembler.&nbsp; As for <b>ASM101S</b>, though, it handles the
    ambiguity as follows:<br>
    <ul>
      <li>If a file in the macro library contains <i>only</i> macro
        definitions (and comments and blank lines), it is automatically
        loaded by the assembler (category #2).</li>
      <li>If a file in the macro library contains <i>anything other
          than</i> macro definitions (and comments), it is not
        automatically loaded, and can only be loaded via <font
          color="#663300"><code>COPY</code></font> (category #3).<br>
      </li>
    </ul>
    <p><b>ASM101S</b> does not attempt to determine these distinctions
      for itself.&nbsp; Rather, the files in the macro library (or
      libraries) must have been preprocessed in such a manner as to
      determine which of the two categories each file in the library
      falls into.&nbsp; Each macro library is assumed to contain a file
      called MACROFILES.txt containing this information, and <b>ASM101S</b>
      simply uses the categorization provided by MACROFILES.txt.&nbsp;
      The format of MACROFILES.txt is that it lists the names all of the
      macro-definition files, one per line.&nbsp; Full-line comments
      (having a semicolon in column 1) are also allowed.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; A utility program
          (makeMACROFILES.py)</font><font size="-1"><font size="-1"> is
            provided</font> to create MACROFILES.txt.&nbsp; Admittedly,
          insofar as legacy code related to Shuttle flight software is
          concerned, this is probably of little interest to you, the end
          user, since all such preprocessing is likely to have been
          performed prior to you seeing any of the assembly-language
          source-code files anyway.&nbsp; But if you do happen to
          acquire flight software or other AP-101 software from sources
          other than Virtual AGC — send it to me! — then I suppose you
          might need to do the preprocessing yourself.<br>
        </font></p>
    </blockquote>
    <h1><a name="Installation"></a>Installation of ASM101S</h1>
    <p>For Linux, Mac OS, or Windows.&nbsp; If the HAL/S compiler (<b>HALSFC</b>)
      has been installed <a moz-do-not-send="true"
        href="HAL.html#Installation">per the instructions</a>, then <b>ASM101S</b>
      will automatically be available as well.<br>
    </p>
    <p>If for some inexplicable reason you want to have <b>ASM101S</b>
      just for itself, without the HAL/S assembler (or any of the AP-101
      source-code files) provided by the normal installation, you could
      instead just download the file <a moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/master/ASM101S">ASM101S.py</a>.&nbsp;















      You simply need Python 3 to run it.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; If you choose the latter
          installation method, I can only assume that you already have
          some AP-101 source-code files that you want to assemble.&nbsp;
          You might consider sending them to me.</font><br>
      </p>
    </blockquote>
    <h1><a name="wildThings"></a>Where Are the AP-101 Assembly-Language
      Files?</h1>
    <ul>
      <li>HAL/S-FC runtime library:</li>
      <ul>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNASM">Source-code








            files</a><br>
        </li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNLST">"Assembly








            listings"</a> (see <a moz-do-not-send="true"
            href="#assemblyListings">here</a>)<br>
        </li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC">Macro








            library</a></li>
        <li><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/ZCONASM">Interface








            files</a><br>
        </li>
      </ul>
      <li>Shuttle FSW OI-30.17 (presently restricted, sorry!):</li>
      <ul>
        <li>Source-code files</li>
        <li>Assembly listings</li>
        <li>Macro library<br>
        </li>
      </ul>
      <li>Shuttle FSW OI-34.06 (presently restricted, sorry!):</li>
      <ul>
        <li>Source-code files</li>
        <li>Disassemblies<br>
        </li>
        <li>Macro library</li>
      </ul>
    </ul>
    <p>AP-101 assembly-language source-code files can also be obtained
      somewhat indirectly by the trick of compiling HAL/S source-code
      files, and then extracting assembly language from the reports
      produced by the HAL/S compiler's code-generation pass.&nbsp; <a
        moz-do-not-send="true" href="HAL.html#HALSFC">The page covering
        the HAL/S compiler</a> shows you some examples of how to run the
      HAL/S compiler, but to summarize it briefly, suppose you have a
      HAL/S source-code file called <i>SOURCE</i>.hal in the current
      working directory.&nbsp; To compile it, you might use the command<br>
    </p>
    <blockquote>
      <pre>HALSFC <i>SOURCE</i>.hal "" "LIST"</pre>
    </blockquote>
    <p>This operation creates a new folder containing the results of the
      compilation, as well as all of the intermediate files <b>HALSFC</b>
      creates during the compilation process.&nbsp; This folder will be
      the newest one with a name of the form "*.results", such as
      "HALSFC Wed Aug 21 07:14:36 AM CDT 2024.results".&nbsp; The file
      that's of interest to us in that folder will be the one called
      "pass2.rpt".<br>
    </p>
    <p>The pass2.rpt file cannot be directly assembled by <b>ASM101S</b>,
      because it contains a lot of stuff other than just
      assembly-language source code.&nbsp; But a script called
      "extractAP101S.py" has been provided that can extract just the
      AP-101S assembly language from pass2.rpt into a file that can
      indeed be directly assembled:<br>
    </p>
    <blockquote>
      <pre>extractAP101S.py &lt;pass2.rpt &gt;<i>SOURCE</i>.asm<br>ASM101S <i>SOURCE</i>.asm<br></pre>
    </blockquote>
    <p>It happens that pass2.rpt itself is structured much like the
      assembly listings produced by <b>ASM101S</b>, in that it includes
      (among other things) not only the source code but also the binary
      form of the object code and some tables.&nbsp; This similarity can
      be exploited as an additional validity test for <b>ASM101S</b>,
      if you're as inclined to doubt its validity as I<i> </i>am.<br>
    </p>
    <ul>
      <ul>
      </ul>
    </ul>
    <h1><a name="Differences"></a>Potential Differences from
      Expectations</h1>
    <p>Given that the connection between the AP-101 assembly language
      and the System/360 assembly language is undocumented (in <i>surviving</i>
      documentation) and is based only upon my own inferences, it's not
      surprising that there are some discrepancies between theory and
      practice, or between what I've implemented in <b>ASM101S</b> vs
      what's documented for IBM 360 assembly language.&nbsp; I'll
      explain those differences in the subsections below.<br>
    </p>
    <h2><a name="assemblyListings"></a>Assembly Listings</h2>
    <p>By an "assembly listing", I mean a printout from the assembler
      itself, typically showing how each line of source code has been
      transformed into binary codes, and providing useful extra
      information such as symbol tables and other cross
      references.&nbsp; You've seen an example (for the ACOS module)
      earlier.<br>
    </p>
    <p>Unfortunately, in spite of the claims to the contrary I've made
      in earlier sections, there are no surviving assembly listings
      produced by the AP-101S original assembler that I'm aware of, or
      even substantial fragments of such listings.&nbsp; (If you notice
      any, be sure to call my attention to them!)&nbsp; Therefore,
      without any of the original assembly listings to mimic, assembly
      listings as produced by <b>ASM101S</b> are unlikely to match
      those of the original assembler with exactitude .... though <i>of
        course</i> I expect the same binary codes to be produced at the
      same addresses, since if not, then the entire exercise of creating
      <b>ASM101S</b> in the first place would be pointless.&nbsp; But
      even if I had such original assembly listings, one wouldn't expect
      them to be any guide as to the wording or format of warning or
      error messages produced by the assembler, since any Space Shuttle
      flight software source code available for assembly presumably
      would be error-free, at least to the point that no warning or
      error messages are likely to appear in any assembly listings.<br>
    </p>
    <p>With that said, there is some assembly-listing-like material
      available, and <i>those</i> are what I have referred to in
      earlier sections.&nbsp; Among the files presently publicly
      visible, I refer to <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNLST">the








        folder called RUNLST in our source-code repository</a>, which
      naively appears to be assembly listings generated by assembling
      the files in <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNASM">the








        repository's RUNASM folder</a>.&nbsp; RUNASM contains the
      AP-101S assembly language source code, in conjunction with <a
        moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC">the








        macro library folder RUNMAC</a>, and assisted by <a
        moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/ZCONASM">the








        interface-file folder ZCONASM</a>, for the runtime library used
      with AP-101S object code created by the HAL/S compiler, <b>HAL/S-FC</b>.<br>
    </p>
    <p>Upon close inspection, however, the contents of RUNLST <i>cannot</i>
      actually have been produced directly by the original AP-101S
      assembler.&nbsp; And similarly for materials not presently
      publicly visible.&nbsp; I assume, rather, that listings produced
      by the original assembler were stored somehow, probably in a
      so-called partitioned data set (PDS), and that the listings in
      RUNLST were produced by running some kind of report generator on
      those stored listings.&nbsp; Here's a fragment of the listing
      RUNLST/ACOS that we've seen earlier:<br>
    </p>
    <pre><font color="#663300">						.<br>						.<br>						.<br>				&nbsp;28 ACOS     AMAIN ACALL=YES                                                00002200<br>                                 29+***********************************************************************<br>                                 30+*<br>                                 31+*        PRIMARY ENTRY POINT<br>                                 32+*<br>                                 33+***********************************************************************<br>00000                            34+ACOS     CSECT                                                          01-AMAIN<br>00000                            35+STACK    DSECT                                                          01-AMAIN<br>                                 36+*        DS    18H            STANDARD STACK AREA DEFINITION<br>00000                            37+         DS    F              PSW (LEFT HALF)                           01-AMAIN<br>00002                            38+         DS    2F             R0,R1                                     01-AMAIN<br>00006                            39+ARG2     DS    F              R2                                        01-AMAIN<br>00008                            40+         DS    F              R3                                        01-AMAIN<br>0000A                            41+ARG4     DS    F              R4                                        01-AMAIN<br>0000C                            42+ARG5     DS    F              R5                                        01-AMAIN<br>0000E                            43+ARG6     DS    F              R6                                        01-AMAIN<br>00010                            44+ARG7     DS    F              R7                                        01-AMAIN<br>                                 45+*        END OF STANDARD STACK AREA<br>00012                            46+SAVE6    DS    D              TO SAVE REGISTERS F6,F7                   02-00025<br>00016                            47+SWITCH   DS    F              TO SAVE R4 ACROSS INTRINSIC CALL          02-00026<br>00018                            48+STACKEND DS    0F             END OF COMBINED STACK AREA                01-AMAIN<br>00000                            49+ACOS     CSECT                                                          01-AMAIN<br>0000000                          50+         USING STACK,0        ADDRESS STACK AREA                        01-AMAIN<br>00000 E0FB 0018      0018        51+         IAL   0,STACKEND-STACK SET STACK SIZE                          01-AMAIN<br>00002 B624 0000      0009 0000   <font color="#ff0000">52</font>+         NIST  9(0),0         CLEAR ON ERROR INFO (LCL DATA PTR)        01-AMAIN<br>                                 <font color="#ff0000">54</font> *COMPUTES ARC-COSINE(X) OF SINGLE PRECISION SCALAR                      00002300<br>                                 55          INPUT F0             SCALAR SP                                 00002400<br>0000000                          <font color="#ff0000">56</font>+F0       EQU   0                                                        01-INPUT<br>                                 <font color="#ff0000">58</font>          OUTPUT F0            SCALAR SP RADIANS                         00002500<br>						.<br>						.<br>						.</font><br></pre>
    <p>To anybody who is familiar with assembly language, this certainly
      <i>looks</i> like an assembly listing produced by an assembler, so
      why do I say that it's not?&nbsp; The first clue is the line
      numbering:&nbsp; There's a line <font color="#ff0000">52</font>
      and a line <font color="#ff0000">54</font>, but no line 53.&nbsp;
      And there are lines <font color="#ff0000">56</font> and <font
        color="#ff0000">58</font>, but no line 57.&nbsp; Admittedly,
      it's not 100% certain why that is, but having tried to track it
      down, it appears to me that both of those gaps correspond to uses
      of the <font color="#663300"><code>SPACE</code></font> pseudo-op
      appearing in expansions of the <font color="#663300"><code>AMAIN</code></font>
      and <font color="#663300"><code>INPUT</code></font> macros
      respectively.&nbsp; <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/52/mode/1up?view=theater">According








        to the assembly-language manual</a>, "The SPACE instruction is
      used to insert one or more blank lines in the listing."&nbsp; And
      if so, where are the blank lines that should have been inserted?<br>
    </p>
    <p>Another clue, not apparent from the fragment above, is in the
      number of lines per page of the printout.&nbsp; Originally, an
      assembly listing would have been output to a line printer having
      (nominally) ~55 lines per page.&nbsp; Whereas the file in RUNLST
      have about 80 lines per page.&nbsp; Nor are there any embedded
      form-feed characters or other means to advance to the top of the
      next page before a page heading is printed.&nbsp; So I would again
      infer that these are not the original assembly listings.&nbsp; (On
      the other hand, I wasn't there, and I don't really know what
      printers were available to the developers, so arguing merely from
      the number of lines on the page isn't as conclusive as I might
      like.)<br>
    </p>
    <p>Regardless, the files of RUNLST are the best guide available as
      to the format of assembly listings, and hence <b>ASM101S</b>
      mimics that format to the extent feasible (i.e., to the extent not
      too pathetically obsessive), plus the addition of convenient
      indications of page breaks.<br>
    </p>
    <p>So when I refer throughout this webpage
      existing/surviving/legacy/contemporary "assembly listings", keep
      in mind that I'm referring to legacy reports such as those in
      RUNLST and not literally to assembly listings produced by the
      original assembler.<br>
    </p>
    <p> </p>
    <h2><a name="CharacterSet"></a>Character Set</h2>
    <p>The AP-101 character set does not match that of the System/360
      assembler.&nbsp; The latter is the EBCDIC character set, or rather
      the variation of EBCDIC listed in Appendix A of the System/360
      assembly-language manual.<br>
    </p>
    <p>On the other hand, as far as I can tell, the AP-101
      assembly-language character set is not defined anywhere, and can
      only be inferred indirectly. <br>
    </p>
    <p>Examining character strings appearing in object files output by
      the HAL/S compiler <b>HAL/S-FC</b>, I find that quoted strings in
      HAL/S are in fact encoded in the ASCII-like character set of the
      Space Shuttle's Display Electronics Unit (DEU).&nbsp; Whereas all
      other text in HAL/S source code, such as symbol names, is encoded
      in EBCDIC.&nbsp; There are no corresponding surviving object files
      produced by assembly (rather than compilation), but my tentative
      operating principle is that all text in object files produced by
      the assembler is encoded in EBCDIC.&nbsp; For more explanation, as
      well as a listing of the DEU character set and its encoding, see <a
        moz-do-not-send="true" href="HALLINK101S.html#characterCoding">the

        discussion of character encoding on the <b>HALLINK101S</b> page</a>.<br>
    </p>
    But wait, there's more!&nbsp; Any Space Shuttle flight-software
    source code available from Virtual AGC will have been "anonymized"
    by replacing personal names or initials with randomized identifiers
    beginning with either the ASCII carat (^) or backslash (\)
    characters, and thus either of these characters may appear in HAL/S
    or AP-101S source code even though they do not appear in the EBCDIC
    character set.<br>
    <br>
    Finally, for technical reasons, <b>ASM101S</b> wants to reserve
    some ASCII character absent from the EBCDIC character set to
    represent breaks between punch-cards and their continuation cards
    (if any).&nbsp; The ASCII brace characters { and } meet these
    criteria.&nbsp; Therefore, <b>ASM101S</b> reserves them for its own
    internal purposes, and they should not be used in any newly-written
    AP-101 assembly-language source code, if such a thing ever
    exists.&nbsp; They are not used in any extant AP-101
    assembly-language source code available to me.<br>
    <h2><a name="instructionAliases"></a>Instruction Aliases</h2>
    <p>In IBM 360 Basic Assembly Language (BAL), various aliases exist
      for the branch instructions <font color="#663300"><code>BCR</code></font>
      and <font color="#663300"><code>BC</code></font><code></code><font
        color="#663300"><code></code></font>.&nbsp; These are described
      in <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/33/mode/1up?view=theater">Figure















        4-1 of the assembler-language manual</a>.&nbsp; While it is
      tempting to say that Figure 4-1 should be accepted as-is for
      AP-101S assembly language, that's unfortunately impossible:&nbsp;
      Conditional-branch instructions encode a "mask" to be applied to
      the CPU's condition codes, but the mask is 4 bits wide for
      System/360 and only 3 bits wide for AP-101S.<br>
    </p>
    <p>Something has to give!&nbsp; But Figure 4-1 does serve as a
      starting point for reverse-engineering AP-101 aliases for
      conditional-branch instructions.&nbsp; Here's my own list of
      AP-101S mnemonics for these branch instructions, grouped by
      condition-code mask.&nbsp; Except where otherwise indicated,
      they're all aliased to the <font color="#663300"><code>BC</code></font>
      instruction; but where marked in parentheses, they're instead
      aliased to <font color="#663300"><code>BCR</code></font> or <font
        color="#663300"><code>BVC</code></font>.<br>
    </p>
    <ol start="0">
      <li><font color="#663300"><code>NOP</code></font>,<font
          color="#663300"><code>NOPR(BCR)</code></font> — No Operation.<br>
      </li>
      <li><font color="#663300"><code>BH</code></font>,<font
          color="#663300"><code>BO</code></font>,<font color="#663300"><code><font
              color="#663300"><code>BP</code></font> </code></font>—
        Branch on High, Branch Over, Branch on Plus</li>
      <li><font color="#663300"><code>BL</code></font>,<font
          color="#663300"><code>BM</code></font>,<font color="#663300"><code>BN</code></font>
        — Branch on Low, Branch on Minus, Branch on Negative</li>
      <li><font color="#663300"><code>BNE</code></font>,<font
          color="#663300"><code>BNZ</code></font> — Branch on Not Equal,
        Branch on Not Zero</li>
      <li><font color="#663300"><code>BE,BZ</code></font> — Branch on
        Equal, Branch on Zero<br>
      </li>
      <li><font color="#663300"><code>BNL,</code></font><font
          color="#663300"><code></code></font><font color="#663300"><code>BNM</code><code>,BHE,BNN</code></font>
        — Branch on Not Low, Branch on Not Less Than, Branch on Higher
        or Equal, Branch on Not Minus</li>
      <li><font color="#663300"><code>BNH</code></font>,<font
          color="#663300"><code>BNP</code></font>,<font color="#663300"><code>BLE</code></font>,<font
          color="#663300"><code>BNO,BNC</code><code>(BVC)</code></font>
        — Branch on Not High, Branch on Not Plus, Branch on
        Less-or-Equal, Branch Not Over, Branch on No Carry.<br>
      </li>
      <li><font color="#663300"><code>B</code></font>,<font
          color="#663300"><code>BR(BCR)</code></font> — Unconditional
        Branch<br>
      </li>
    </ol>
    <blockquote><font size="-1"><b>Note:</b>&nbsp; While the mnemonics
        and condition masks in the list above are accurate (I hope!),
        the textual descriptions are less certain and should be taken
        with a grain of salt.<br>
        <br>
        <b>Aside:</b>&nbsp; While I <i>call</i> this "aliasing to </font><font
        size="-1"><font size="-1"><font color="#663300"><code>BC</code></font></font>",








        in analogy to System/360, that's not exactly what's going on</font><font
        size="-1"> in AP-101S.&nbsp; </font><font size="-1">In fact, in
        AP-101S each of these branching instructions (except <font
          color="#663300"><code>NOPR</code></font> and <font
          color="#663300"><code>BR</code></font>) are encoded as one of
        three different instructions (<font color="#663300"><code>BC</code></font></font><font
        size="-1"><font color="#663300"><code><font size="-1"><font
                color="#663300"><code></code></font>,</font></code></font>
        <font color="#663300"><code>BCB</code></font>, or <font
          color="#663300"><code>BCF</code></font>), with the particular
        instruction chosen being dependent on the direction and distance
        of the branch being attempted.&nbsp; Similarly, a <font
          color="#663300"><code>BCT</code></font> instruction (branch on
        count) may instead generate the shorter machine code <font
          color="#663300"><code>BCTB</code></font> (branch on count
        backward) for short enough loops.</font><br>
    </blockquote>
    <ul>
    </ul>
    <p><font color="#663300"><code>LHI</code></font>:&nbsp; Besides the
      branch-instruction aliases, Shuttle flight-software code uses the
      operator <font color="#663300"><code>LHI</code></font>, but
      without any AP-101 instruction or any macro definition
      corresponding to it.&nbsp; There is such an instruction in IBM 360
      assembly language.&nbsp; <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=79">The














        AP-101S POO notes</a> in its discussion of the <font
        color="#663300"><code>LA</code></font> instruction that there is
      a particular configuration of operands for which <font
        color="#663300"><code>LA</code></font> will be "functionally
      equivalent to a LOAD HALFWORD IMMEDIATE instruction".&nbsp; My
      guess is that the original assembler therefore accepted the
      mnemonic <font color="#663300"><code>LHI</code></font> but
      silently transformed it in the appropriate <font color="#663300"><code>LA</code></font>
      instruction.&nbsp; <b>ASM101S</b> treats it in that manner as
      well.<br>
    </p>
    <p><font color="#663300"><code>SHI</code></font>:&nbsp; Similarly,
      flight software uses the non-existent <font color="#663300"><code>SHI</code></font>
      instruction.&nbsp; The program comments at those points clearly
      indicate that this is a kind of subtract-immediate instruction,
      presumably Subtract Halfword Immediate.&nbsp; Unlike the case of <font
        color="#663300"><code>LHI</code></font>, there is no
      corresponding <font color="#663300"><code>SHI</code></font>
      instruction for System 360.&nbsp; Nevertheless, we might suppose
      that the case is still similar, in that this could be an alias for
      (perhaps) a particular configuration of operands for some other
      AP-101 instruction.&nbsp; Fortunately, we have plenty of examples
      of assembly listings for code using <font color="#663300"><code>SHI</code></font>.&nbsp;














      Consider this example:<br>
    </p>
    <blockquote>
      <pre>B0E5  FFFE                   SHI    R5,2<br></pre>
    </blockquote>
    <p>The value 0xFFFE is a halfword with the value -2, which leaves us
      to suspect that this is actually an addition.&nbsp; There is
      indeed an <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=66">Add














        Halfword Immediate</a> instruction (<font color="#663300"><code>AHI</code></font>),














      and "<font color="#663300"><code>AHI R5,-2</code></font>" would
      indeed assemble as shown.<br>
    </p>
    <p><font color="#663300"><code>LACR</code></font>:&nbsp; There is no
      corresponding System/360 instruction to guide our thinking.&nbsp;
      However, there are lots of examples in AP-101 assembly listings,
      such as those for the CTOI.txt file of the HAL/S-FC runtime
      library.&nbsp; <font color="#663300"><code>LACR</code></font> is
      seen to be a register-to-register operation.&nbsp; For (say)
      general-registers <i>N</i> and <i>M</i>, it assembles to the bit
      pattern 11101<i>nnn</i> 11101<i>mmm</i>.&nbsp; This is the same
      pattern that the LOAD ARITHMETIC COMPLEMENT (<font color="#663300"><code>LCR</code></font>)
      instruction assembles to.&nbsp; Therefore, <font color="#663300"><code>LACR</code></font>
      is nothing more than a synonym for <font color="#663300"><code>LCR</code></font>.<br>
    </p>
    <p><font color="#663300"><code>PC</code></font>:&nbsp; Similarly,
      this undocumented instruction is found from available assembly
      listings to assembly as a synonym for <font color="#663300"><code>MVH</code></font>
      (move halfword).&nbsp; There's no rationale obvious to me for the
      specific mnemonic "PC" for this operation.<br>
    </p>
    <ul>
    </ul>
    <h2>Unused Pseudo-ops</h2>
    <p>Not all pseudo-ops described in the System/360 assembler manual
      appear in surviving AP-101 assembly-language source code.&nbsp;
      I've chosen to believe that rather than the omissions being
      coincidental, those pseudo-ops are instead specific to System/360
      and thus had been entirely omitted from AP-101
      assembly-language.&nbsp; Admittedly, that inference is probably
      wrong in the case of certain of the pseudo-ops.&nbsp;
      Nevertheless, they have not been implemented in <b>ASM101S</b>.&nbsp;















      <br>
    </p>
    <p>The omitted pseudo-ops are:<br>
    </p>
    <ul>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/49/mode/1up?view=theater">CCW</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/27/mode/1up?view=theater">COM</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/26/mode/1up?view=theater">CXD</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/26/mode/1up?view=theater">DXD</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/53/mode/1up?view=theater">ICTL</a></li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/54/mode/1up?view=theater">ISEQ</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/36/mode/1up?view=theater">OPSYN</a><br>
      </li>
      <li><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/n36/mode/1up?view=theater">WXTRN</a><br>
      </li>
    </ul>
    <ul>
    </ul>
    <ol start="4">
    </ol>
    <p> </p>
    <ul>
    </ul>
    <p> </p>
    Obviously, this list is subject to change, if legacy AP-101
    assembly-language source code using any of these pseudo-ops is
    discovered.<br>
    <h2>Mystery Pseudo-ops</h2>
    <p>The <font color="#663300"><code>SPOFF</code></font> and <font
        color="#663300"><code>SPON</code></font> pseudo-ops — if they <i>are</i>
      pseudo-ops — seem typically to be used in pairs:&nbsp; <font
        color="#663300"><code>SPOFF</code></font> is used to disable
      something unknown, then an instruction or two later, <font
        color="#663300"><code>SPON</code></font> is used to re-enable
      whatever it was that <font color="#663300"><code>SPOFF</code></font>
      disabled.&nbsp; They are not pseudo-ops in IBM 360 assembly
      language, and hence must be specific to AP-101S.<br>
    </p>
    <p>Fortunately, we have a few contemporary assembly listings in
      which these pseudo-ops appear in the source code, and thus their
      effect can be observed somewhat.&nbsp; They do not generate any
      binary, hence they are definitely not instructions of any
      kind.&nbsp; Furthermore, they do not affect whether or not the
      source code they enclose is assembled, nor whether that source
      code appears in the assembly listing.<br>
    </p>
    <p>I would tentatively conclude that at least for the moment they
      can simply be ignored, and that's what <b>ASM101S</b> does with
      them for now.<br>
    </p>
    <h2><a name="forbiddenCOPY"></a>Forbidden Pseudo-Ops in <font
        color="#663300"><code>COPY</code></font>'d Files</h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/57/mode/1up?view=theater">The














        System/360 assembler manual tells us</a> that assembly-language
      files included in other assembly-language files via the <font
        color="#663300"><code>COPY</code></font> pseudo-op cannot
      contain various other pseudo-ops, two of which are <font
        color="#663300"><code>MACRO</code></font> and <font
        color="#663300"><code>MEND</code></font>.&nbsp; That implies
      that a <font color="#663300"><code>COPY</code></font>'d file
      cannot contain any macro definitions.&nbsp; Nevertheless, Space
      Shuttle flight software has file inclusions that violate this
      restriction.&nbsp; Specifically, the files MLIB80/MACSMITH.asm and
      MLIB80/MACROS.asm do contain macro definitions, and yet are
      themselves <font color="#663300"><code>COPY</code></font>'d into
      other assembly-language files.&nbsp; Consequently, this
      restriction (at least insofar as <font color="#663300"><code>MACRO</code></font>
      and <font color="#663300"><code>MEND</code></font> are concerned)
      does not apply in AP-101 assembly-language.<br>
    </p>
    <h2>Macro-Definition Prototypes</h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/65/mode/1up?view=theater">The














        assembler manual tells us</a> that <br>
    </p>
    <blockquote>"The macro instruction prototype statement (hereafter
      called the prototype statement) specifies the mnemonic operation
      code and the format of all macro instructions that refer to the
      macro definition. It must be the second statement of every macro
      definition."<br>
    </blockquote>
    For example, in a macro definition such as<br>
    <blockquote>
      <pre><font color="#663300">         MACRO<br>         MYMACRO   &amp;ARG1,&amp;ARG2<br>         .<br>         .<br>         .<br>         MEND</font><br></pre>
    </blockquote>
    no other statements must appear between the first two lines shown
    here.&nbsp; <br>
    <br>
    In contradiction to the claim in the manual, though, there are
    instances in flight-software code in which there are comments
    between these lines, as in<br>
    <blockquote>
      <pre><font color="#663300">         MACRO<br>.* THIS IS A COMMENT<br>.* THIS IS ANOTHER COMMENT<br>         .<br>         .<br>         .<br>.* THERE WERE  A WHOLE LOT OF COMMENTS, SEE?<br>         MYMACRO   &amp;ARG1,&amp;ARG2<br>         .<br>         .<br>         .<br>         MEND</font><br></pre>
    </blockquote>
    I guess we'd infer from this, and very reasonably, that comments are
    not "statements", but more importantly, that the macro prototype is
    not necessarily the second line in a macro definition.<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;












        I don't know if anybody will read these words, ever, but my
        sixth sense tells me that some folks who do might be smugly
        saying to themselves right now that "<i>of course</i> full-line
        comments are not 'statements' in any language, so what's this
        fool on about?"&nbsp; As it happens, <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/69/mode/1up?view=theater">on












          p. 69 of the assembler manual</a>, we find a section actually
        entitled "Comments Statements", which proceeds to define the
        term <i>comments statement</i> as being precisely the thing
        we're discussing right now.&nbsp;
        <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo></mo></mrow><annotation
              encoding="TeX">&lt;img src="smiley.png"&gt;</annotation></semantics></math></font><br>
    </blockquote>
    <h2>Silly Suffixes</h2>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
          AP-101 CPU instructions fall into 5 categories, depending on
          the pattern of operands they accept.&nbsp; These 5 categories
          are designated RR, RS, SRS, SI, and RI.&nbsp; The differences
          between these relate to the number of operands and the means
          of addressing them, but the specifics aren't important for our
          discussion here.</font><br>
      </p>
    </blockquote>
    <p>All AP-101 CPU instructions of type RS can optionally have
      suffixes "@", "#", or "@#" added to their mnemonics.&nbsp; For
      example, just as there is an <font color="#663300"><code>SCAL</code></font>
      instruction of type RS, there are also <font color="#663300"><code>SCAL@</code></font>,
      <font color="#663300"><code>SCAL#</code></font>, and <font
        color="#663300"><code>SCAL@#</code></font> instructions of type
      RS.<br>
    </p>
    <p>To be picky about it, this usage is indeed documented, but it
      took me so long to figure out that I thought I should take
      explicit notice of it here anyway.<br>
    </p>
    <p><a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=63">The














        AP-101S POO tells us</a> that <br>
    </p>
    <blockquote>
      <p>"... [@] [#] indicates that the use of indirect addressing
        and/or autoindexing is optional.&nbsp; For example, [instruction
        mnemonic] <font color="#663300"><code>M</code></font> specifies
        direct addressing without autoindexing, while <font
          color="#663300"><code>M#</code></font> specifies direct
        addressing with autoindexing."<br>
      </p>
    </blockquote>
    And in case it's not obvious to you what the POO means by "indirect
    addressing" and/or "autoindexing", there is much greater detail in <a
      moz-do-not-send="true"
      href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=39">the
      POO's explanation of the general characteristics of RS-type
      instructions</a>, though you won't be any wiser about the origin
    or rationale of the term "autoindexing" after reading the
    explanation than you have beforehand.<br>
    <blockquote><font size="-1"><b>Aside:</b> As usual, I suppose, the
        implications of this are more complex than might be supposed at
        first glance.&nbsp; Not to mention probably being more than you
        want to know!&nbsp; Technically, if the <font color="#663300"><code>@</code></font>
        suffix is present, a bit-field known as "IA" in the encoded
        machine instruction is set to 1 (vs 0 in the absence of the
        suffix).&nbsp; Similarly, a bit-field known as "I" in the
        encoded instruction is set to 1 in the presence of the <font
          color="#663300"><code>#</code></font> suffix.&nbsp; The
        "more-complex" implication is that the "I" field may be set to 1
        sometimes even in the absence of the </font><font size="-1"><font
          size="-1"><font color="#663300"><code>#</code></font></font>
        suffix.&nbsp; This happens, for example, in a branch backward to
        an earlier address (vs a branch forward to a later
        address).&nbsp; In such a case, the assembler sets the "I" bit
        on its own, without the suffix <font color="#663300"><code>#</code></font>,
        because one of the special addressing modes I alluded to earlier
        is <a moz-do-not-send="true"
          href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=41">the




          case</a> where you have an RS-type instruction <br>
      </font>
      <blockquote>
        <pre><font size="-1"><font color="#663300"><i>OPCODE</i> R1,D2(X2,B2)</font><br></font></pre>
      </blockquote>
      <font size="-1">in which<br>
      </font>
      <ul>
        <li><font size="-1">The index register (<font color="#663300"><code>X2</code></font>)
            being used is general register 0 (or absent from the
            operand)<br>
          </font></li>
        <li><font size="-1">And the base register (<font color="#663300"><code>B2</code></font>)
            being used is general register 3 (of absent from the
            operand)<br>
          </font></li>
        <li><font size="-1">And the "IA" bit-field is 0 (i.e., <i><font
                color="#663300"><code>OPCODE</code></font></i> has no
            suffix <font color="#663300"><code>@</code></font>)<br>
          </font></li>
        <li><font size="-1">And the "I" bit-field is 1</font></li>
      </ul>
      <font size="-1">If so, then at execution time the displacement <font
          color="#663300"><code>D2</code></font> is subtracted rather
        than added to the updated instruction counter.&nbsp; In
        particular, it allows backward branches from the current
        location. <br>
      </font></blockquote>
    <h2>Mystery Instructions or Macros</h2>
    The following operators appear in flight software source code, and I
    am so far unable to determine if they are supposed to be
    instructions, macros, or pseudo-ops:<br>
    <ul>
      <li><font color="#663300"><code>LB</code></font> is used in the
        same manner as the instruction <font color="#663300"><code>LA</code></font>
        (load address), but it is a mystery what it signifies.&nbsp; I
        presently have no examples of assembly listings containing it
        from which I can deduce anything.&nbsp; One possibility is that
        it's simply an error&nbsp; never detected during Shuttle
        software development because the only known usage is in the
        definition of a macro (<font color="#663300"><code>LD</code></font>)
        which in fact is never invoked by any of the other source
        code.&nbsp; In other words, perhaps <b>ASM101S</b> shouldn't
        have been getting uppity by trying to parse that macro in the
        first place!</li>
      <li>AREAD</li>
      <li>BC$</li>
      <li>STH$<br>
      </li>
    </ul>
    <h2><a name="Implementation"></a>Syntax of Various Fields<br>
    </h2>
    Recall that the four fields potentially present in a line of
    assembly language (whether instructions, pseudo-ops, macro
    invocations, etc.) are the <i>name</i> field (beginning in column
    1), the <i>operation</i> field, the <i>operand</i> field, and the
    <i>comment</i> field.&nbsp; It turns out that parsing these fields
    is quite tricky, particularly the operand field.&nbsp; <br>
    <br>
    I won't bore you with the details as to why this is so, but simply
    say that except for the comment field, each of these fields has been
    given its own simple BNF-style grammar in <b>ASM101S</b>, and
    sometimes multiple separate grammars that are applied for different
    contexts.&nbsp; This is, of course, transparent to the user of <b>ASM101S</b>,
    and is only significant to someone wishing to maintain the
    assembler.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; "BNF", of course,
        stands for <a moz-do-not-send="true"
          href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur










          form</a>.&nbsp; Technically, the grammars are actually written
        in the modified EBNF (<a moz-do-not-send="true"
          href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended










          Backus-Naur form</a>) supported by <a moz-do-not-send="true"
          href="https://tatsu.readthedocs.io/en/stable/">the TatSu
          parser module for the Python language</a>.&nbsp; See the
        Python source-code file <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/ASM101S/fieldParser.py">fieldParser.py</a>
        for the grammars themselves.</font><br>
    </blockquote>
    Nevertheless, even having adding this level of complexity to the
    parser, it's not necessarily the case that the syntax parsed by <b>ASM101S</b>
    matches that parsed by the original assembler.&nbsp; For example,
    arithmetic expressions as specified by the System/360
    assembly-language manual are constrained in various ways — e.g.,
    cannot begin with '+' or '-', cannot have have more than 16 terms,
    cannot have more than 5 levels of parentheses —, but have not been
    endowed with the same constraints in <b>ASM101S</b>.&nbsp; On the
    other hand, I haven't necessarily bothered to implement
    theoretically-possible syntax that isn't present in actual flight
    software.&nbsp; Consequently, it's likely that <b>ASM101S</b>
    accepts a more-complex syntax in some contexts than did the original
    assembler, and vice-versa.&nbsp; Or course, <b>ASM101S</b> can be
    upgraded as needed to support such missing syntax, if it turns out
    to be desirable, whereas the original assembler cannot.<br>
    <h2>EQU and CPU Registers</h2>
    <p>The AP-101 CPU has 8 general registers, typically referred to
      symbolically in assembly language as <font color="#663300"><code>R0</code></font>
      through <font color="#663300"><code>R7</code></font>, as well as
      8 floating-point registers, typically referred to as <font
        color="#663300"><code>F0</code></font> through <font
        color="#663300"><code>F7</code></font>.&nbsp; This is the same
      situation as in System/360 assembly language, except that in
      System/360 there are more of each kind of register.&nbsp; For
      example, an assembly-language instruction that performs an integer
      addition from register <font color="#663300"><code>R7</code></font>
      to register <font color="#663300"><code>R3</code></font> would
      look like this in either of the two assembly languages:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">AR	R3,R7</font><br></pre>
    </blockquote>
    But there's a catch.&nbsp; The assembly-language manual <a
      moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/31">explains</a>
    that<br>
    <blockquote><font size="-1">"All symbols that specify register
        numbers ... must be assumed to be equated elsewhere to absolute
        values."</font><br>
    </blockquote>
    In other words, the register-name symbols <font color="#663300"><code>R3</code></font>
    and <font color="#663300"><code>R7</code></font> in this example
    are <i>not</i> tokens or syntactical elements of the assembly
    language, and the pure syntax for the instruction example shown
    above should actually be this:<br>
    <blockquote>
      <pre><font color="#663300">AR	3,7</font><br></pre>
    </blockquote>
    The only reason that the former instruction would be accepted by the
    assembler, the manual is explaining, is that the full example should
    have read something like this:<br>
    <blockquote>
      <pre><font color="#663300">R3      EQU     3<br>R7      EQU     7<br>	.<br>	.<br>	.<br>&nbsp;       AR      R3,R7</font></pre>
    </blockquote>
    In turn, this means that in <a moz-do-not-send="true"
      href="#macros">the macro libraries loaded by the assembler</a>, we
    should should find various <font color="#663300"><code>EQU</code></font>ates










    similar to the ones above, for the general registers and
    floating-point registers.&nbsp; And indeed, for the macro libraries
    used for the Space Shuttle primary flight software (PASS), and
    backup flight software (BFS), we find exactly such declarations in
    the PASS module MLIB80/MACSMITH or the BFS module MLIB80/EQU, along
    with numerous other <font color="#663300"><code>EQU</code></font>ates










    of a similar nature:<br>
    <blockquote>
      <pre><font color="#663300">         .<br>         .<br>         .<br>F0       EQU   0              FP 0 = FLOATING POINT REGISTER            <br>F1       EQU   1                 1                                      <br>F2       EQU   2                 2                                      <br>F3       EQU   3                 3                                      <br>F4       EQU   4                 4                                      <br>F5       EQU   5                 5                                      <br>F6       EQU   6                 6                                      <br>F7       EQU   7                 7                                      <br>G0       EQU   0   SET 1      GR 0 = GENERAL REGISTER                   <br>G1       EQU   1                 1                                      <br>G2       EQU   2                 2                                      <br>G3       EQU   3                 3                                      <br>G4       EQU   4                 4                                      <br>G5       EQU   5                 5                                      <br>G6       EQU   6                 6                                      <br>G7       EQU   7                 7                                      <br>R0       EQU   0   SET 2      GR 0 = GENERAL REGISTER                   <br>R1       EQU   1                 1                                      <br>R2       EQU   2                 2                                      <br>R3       EQU   3                 3                                      <br>R4       EQU   4                 4                                      <br>R5       EQU   5                 5                                      <br>R6       EQU   6                 6                                      <br>R7       EQU   7                 7                                      <br>         .<br>         .<br>         .</font>    <br></pre>
    </blockquote>
    Unfortunately, that's not the full story.&nbsp; Besides the flight
    software as such, AP-101 assembly-language files also exists in the
    runtime library provided by <b>HAL/S-FC</b>, the HAL/S
    compiler.&nbsp; Those assembly-language files reference the CPU
    general registers and floating-point registers just as any of the
    flight-software files do, except that <i>there are no </i><i><font
        color="#663300"><code>EQU</code></font></i><i>ates for those
      registers</i> in any of those source-code files, nor in the macro
    library used by those files.<br>
    <br>
    It is, of course, possible that the reason these <font
      color="#663300"><code>EQU</code></font>ates are missing is that
    our <b>HAL/S-FC</b> runtime-library source code is
    incomplete.&nbsp; Unfortunately, there is no way to know whether
    that is correct or not.&nbsp; Another possibility is that the
    System/360 assembly-language manual is incorrect, and that the
    assembler <i>does</i> by default recognize the general registers <font
      color="#663300"><code>R<i>n</i></code></font> and float-point
    registers <font color="#663300"><code>F</code><code><i>n</i></code></font>,
    and possibly other symbols, without explicit <font color="#663300"><code>EQU</code></font>ates.<br>
    <br>
    Lacking any palatable alternatives here, <b>ASM101S</b> assigns
    default values to the various register symbols, but allows those
    defaults to be overridden by explicit <font color="#663300"><code>EQU</code></font>ates,










    if such are encountered.<br>
    <h2>Type Attributes, <code>T'</code></h2>
    <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/77/mode/1up">The









      System/360 assembly-language manual</a> tells us prefixing a
    symbolic variable (such as <font color="#663300"><code>&amp;A</code></font>)
    with the notation <font color="#663300"><code>T'</code></font>
    returns an assembly-time string consisting of a single character
    that corresponds to the type of data the variable contains.&nbsp;
    For example, if <font color="#663300"><code>&amp;A</code></font>
    were a character-string variable as declared via the <font
      color="#663300"><code>GBLC</code></font> or <font color="#663300"><code>LCLC</code></font>
    pseudo-op, then the assembler's preprocessor would replace <font
      color="#663300"><code>T'&amp;A</code></font> by the single
    character <font color="#663300"><code>C</code></font> at
    assembly-time.<br>
    <br>
    The manual lists 27 such "types", corresponding to the "letters" A-Z
    and $.&nbsp; (In the worldview of the assembler, 29 characters are
    defined as being "letters":&nbsp; A through Z, #, $, and @.)&nbsp;
    But it isn't clear at the present time how many of these types will
    be supported in <b>ASM101S</b>, since only the following seem to
    appear in actual flight-software source code:<br>
    <ul>
      <li>C — character constant</li>
      <li>N — self-defining term<br>
      </li>
      <li>O — omitted operand<br>
      </li>
      <li># — (not mentioned in the manual)</li>
    </ul>
    <p>It isn't entirely clear to me what # indicates.&nbsp; My current
      <i>very tentative</i> interpretation is this:<br>
    </p>
    <ul>
      <li>If applied to the formal parameter of a macro, it means that
        the formal parameter is a position-dependent
        parameter.&nbsp;&nbsp; I.e., that it is not a named parameter.</li>
      <li>If applied to a character-string variable, the variable is
        assumed to contain the name of a formal parameter of a macro,
        and the formal parameter is position-dependent.</li>
    </ul>
    <h2><a name="definedAttribute"></a>The <code>D'</code> Attribute</h2>
    <p>AP-101S assembly-language source code uses an attribute operator
      <font color="#663300"><code>D'</code></font>, which is not defined
      in the assembly-language manual.&nbsp; From the way it is used, I
      infer when applied to an identifier, it returns "true" (1) if the
      identifier has been previously defined within the source-code
      being assembled and "false" (0) if not.&nbsp; A typical usage
      would be something like <br>
    </p>
    <blockquote>
      <pre>	<font color="#663300">AIF     (D'MYSYM).OKAY<br>	EXTRN	MYSYM<br>OKAY    ...</font><br></pre>
    </blockquote>
    <p>Thus if the identifier is not defined, it allows the code to
      detect that condition and to mark the identifier as being declared
      externally.<br>
    </p>
    <ul>
    </ul>
    <h2><code>AIF</code> and <code>AGO<br>
      </code><code></code></h2>
    The <font color="#663300"><code>AIF</code></font> and <font
      color="#663300"><code>AGO</code></font> pseudo-ops provide "goto"
    functionality (respectively conditionally or unconditionally) at
    assembly time (rather than at runtime).&nbsp; <a
      moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/88/mode/1up">The









      System/360 assembly-language manual</a> makes it clear that these
    "goto" operations can operate only with the same macro depth, and
    further, if within a macro, only within the <i>same</i>
    macro.&nbsp; For example, in the "pseudo-instruction" <br>
    <blockquote>
      <pre><font color="#663300"><code>AGO .MYSEQ</code></font> </pre>
    </blockquote>
    the locations of the pseudo-instruction itself and of the sequence
    symbol <font color="#663300"><code>.MYSEQ</code></font> could be
    both outside of any macro, or they could be within the same macro
    definition.&nbsp; But it could <i>not</i> be the case (say) that
    the pseudo-instruction was within a macro definition and the
    sequence symbol was within a macro invoked by that macro.<br>
    <br>
    One important case about which the assembly-language manual says
    nothing, I think, is the case in which a source-code file is being
    imported via a <font color="#663300"><code>COPY</code></font>
    pseudo-op.&nbsp;&nbsp; Is it possible for the <font color="#663300"><code>AGO</code></font>
    or <font color="#663300"><code>AIF</code></font> pseudo-instruction
    to be in a file containing a <font color="#663300"><code>COPY</code></font>
    pseudo-op while the target sequence symbol is in the file being <font
      color="#663300"><code>COPY</code></font>'d?&nbsp; Or vice-versa?<br>
    <br>
    <b>ASM101S</b> does <i>not</i> allow the case just mentioned.&nbsp;
    In other words in <b>ASM101S</b>, for any file being imported via <font
      color="#663300"><code>COPY</code></font>, any <font
      color="#663300"><code>AGO</code></font>/<font color="#663300"><code>AIF</code></font>
    pseudo-instruction and its target sequence symbol must reside within
    the same <font color="#663300"><code>COPY</code></font>'d file.<br>
    <br>
    I do not presently know if this usage occurs within Shuttle flight
    software or not.&nbsp; <br>
    <h2>Arithmetical Peculiarities and Evaluation of Expressions<br>
    </h2>
    <p>Certain arithmetical quirks are inherent in System/360 assembly
      language, and I must presume that these peculiarities carry over
      into AP-101S assembly language as well. Therefore, <b>ASM101S</b>
      retains these peculiarities rather than eliminating them.<br>
    </p>
    <p>The peculiarities I regard as worth noting are these:<br>
    </p>
    <ul>
      <li>As far as I can tell, there are no negative-number literals,
        nor are there any legal arithmetical expressions that are
        superficially equivalent to them.&nbsp; For example, you could
        not assign the symbolic variable <font color="#663300"><code>&amp;A</code></font>
        the value <font color="#663300"><code>-5</code></font> via a
        line of pseudo-code such as "<font color="#663300"><code>&amp;A
            SETA -5</code></font>", because "<font color="#663300"><code>-5</code></font>"
        is neither a legal literal nor a legal arithmetic
        expression.&nbsp; (Nor would <font color="#663300"><code>+5</code></font>
        be legal.)&nbsp; <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/16/mode/1up">The









          assembly-language manual</a> seems to advise using workarounds
        such as "<font color="#663300"><code>&amp;A SETA 0-5</code></font>".</li>
      <li>Division by 0 is allowed, and always results in 0.&nbsp; For
        example, 5/0 is equal to 0.</li>
      <li>Arithmetic expressions are always integer, so the "<font
          color="#663300"><code>/</code></font>" operator is integer
        division.&nbsp; For example, 5/2 evaluates to 2.&nbsp; The
        manual does not explain what the result of an operation like
        (0-5)/2 would be; either -3 or -2 is plausible.&nbsp; Until the
        correct behavior is somehow determined, <b>ASM101S</b> uses the
        Python convention (i.e., it uses the Python <font
          color="#663300"><code>//</code></font> operator), which would
        result in -3 in this case.</li>
      <li>Operator precedence:&nbsp; Consider an expression consisting
        of "terms" that are separated by the operators <font
          color="#663300"><code>+</code></font>, <font color="#663300"><code>-</code></font>,
        <font color="#663300"><code>*</code></font>, or <font
          color="#663300"><code>/</code></font>.&nbsp; ("Terms" is
        quoted here to distinguish the System/360 usage from the normal
        mathematical usage, in which <i>terms</i> are added or
        subtracted from to/from each other, while <i>factors</i> are
        multiplied or divided to/by each other.)&nbsp; These operations
        are performed in <i>left-to-right order</i>, except that
        multiplications or divisions are performed prior to additions or
        subtractions.&nbsp; In particular, in an expression like 3*5/2,
        division does not have a higher precedence than multiplication,
        so it is evaluated as (3*5)/2 rather than as 3*(5/2).<br>
      </li>
      <li>The final result of evaluation of any arithmetic expression is
        always truncated to 24 bits (2's complement), but intermediate
        results are 32 bits.<br>
      </li>
    </ul>
    <p>On the other hand, <b>ASM101S</b> does remove some of the
      constraints of System/360 assembly-language arithmetical
      restrictions, namely:<br>
    </p>
    <ul>
      <li>Expressions can contain any number of terms, rather than being
        limited to a maximum of 16.</li>
      <li>Expressions can have any depth of parentheses, rather than
        being limited to 5 levels.</li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b>&nbsp; Regarding peculiarities of
          my own making, as opposed to those of the language itself or
          the original assembler, I'm obliged to admit that I don't
          quite understand how to perfectly handle assembly-time
          evaluation of arithmetic expressions involving program labels:
          i.e., involving the addresses of symbols rather than the
          values of constants.&nbsp; <br>
        </font></p>
      <p><font size="-1">To do so, <b>ASM101S</b> instead uses an
          imperfect trick, making use of the facts that the address
          space of the AP-101S is limited to 24 bits and that the number
          of allowed control sections in a program (at least in
          System/360) is limited to 255.&nbsp; The addresses of program
          labels (prior to linking) is precisely an ordered pair of the
          form (control section, offset into control section), but
          performing arithmetical computations is easiest when these
          values can somehow be converted to single numbers rather than
          ordered pairs.&nbsp; The trick is to assign each control
          section a unique but randomized 64-bit value whose
          least-significant 24 bits are all 0, and to convert addresses
          of symbols to a sums of these 64-bit values plus 24-bit
          offsets into the control sections.&nbsp; (I don't mean that
          the codes for the symbols are actually random, but rather that
          they are selected in a way that makes it unlikely to produce
          their values by common types of calculations.)&nbsp; In this
          way, calculations like <font color="#663300"><code>SYMBOL+OFFSET</code></font>
          or <font color="#663300"><code>SYMBOL1-SYMBOL2</code></font>
          (for symbols in the same section) produce the expected
          results, and indeed, produces correct results for all <i>correct</i>
          expressions.&nbsp; Unfortunately it remains possible to
          combine symbols in an <i>incorrect</i> manner from two
          different control sections and get a result that appears to be
          in yet a third control section, which is incorrect.&nbsp; This
          potential is part of the reason for using 64-bit
          pseudo-addresses (and distributing the unique numerical codes
          for the control sections throughout a 40-bit space) rather
          than 32-bit pseudo-addresses (and distributing the unique
          numerical codes in an 8-bit space):&nbsp; It reduces</font><font
          size="-1"><font size="-1"> to a very low level</font> the
          probability of producing "fake" control sections in
          calculations.<br>
        </font></p>
      <p><font size="-1">According to the System/360 assembly-language
          manual, although </font><font size="-1"><font size="-1"><font
              color="#663300"><code>EXTRN</code></font> symbols can
            appear in expressions, they cannot be paired.&nbsp; This
            implies, I think, that they can be handled interoperably
            with the description in the preceding paragraph, by using </font></font><font
          size="-1"><font size="-1"><font size="-1">unique but
              randomized 64-bit values with the lower 24 bits all 0 in
              place of those symbols.<br>
            </font></font></font></p>
      <p><font size="-1">I thought at first that the same trick could be
          used to handle calculations other not-yet-defined
          symbols.&nbsp; Unfortunately, such an attempt would be
          guaranteed to produce incorrect results in calculations like <font
            color="#663300"><code>KNOWN-UNKNOWN</code></font>, even if <font
            color="#663300"><code>KNOWN</code></font> and <font
            color="#663300"><code>UNKNOWN</code></font> both turned out
          to be members of the same control section.&nbsp; Therefore,
          the addresses of all symbols in the current file must be
          ascertained in a separate pass before computations of
          expressions involving such symbols are performed.<br>
        </font></p>
    </blockquote>
    <ul>
    </ul>
    <h2>Relational Expressions Involving Strings</h2>
    <p>Among the types of expressions computed by the assembler at
      assembly-time for use with pseudo-ops such as <font
        color="#663300"><code>SETB</code></font> or <font
        color="#663300"><code>AIF</code></font> are the boolean
      expressions, of which one sub-type is relational expressions
      involving string values.<br>
    </p>
    <p>A relational expression is used to determine that two values
      (either two numbers or two strings) are equal (<font
        color="#663300"><code>EQ</code></font>), not-equal (<font
        color="#663300"><code>NE</code></font>), less-than (<font
        color="#663300"><code>LT</code></font>), less-than-or-equal (<font
        color="#663300"><code>LE</code></font>), greater-than (<font
        color="#663300"><code>GT</code></font>), or
      greater-than-or-equal-to (<font color="#663300"><code>GE</code></font>)
      each other.&nbsp; For example, the relational expression<br>
    </p>
    <blockquote>
      <pre><font color="#663300">3 LT 4</font><br></pre>
    </blockquote>
    returns the value "true" (which in System/360 assembly language is
    numerically equivalent to 1) since 3 is less than 4.<br>
    <br>
    <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/138/mode/1up">System/360





      assembly language</a> shares the obnoxious (in my opinion!)
    property of string comparisons in <a moz-do-not-send="true"
      href="XPL-I.html">the XPL language</a> that a shorter string is
    always "less than" a longer string.&nbsp; For example, <br>
    <blockquote>
      <pre><font color="#663300">'Z' LT 'AA'</font><br></pre>
    </blockquote>
    returns "true".<br>
    <br>
    Unfortunately, as far as I can tell, the System/360
    assembly-language manual does not explicitly state the collation
    sequence to be used for comparing strings of equal length, though it
    seems to me to be implied that it is based on the EBCDIC encoding of
    the characters.&nbsp; <br>
    <br>
    As for the AP-101 assembler, however, the conclusion is not so
    straightforward, and in fact is TBD.<br>
    <br>
    If we use the "cross reference" (symbol table) printed in legacy
    assembly listings printed by the original assembler — an approach of
    dubious validity —, we find relationships like this:<br>
    <br>
    <div align="center">digit &lt; alphabetic &lt; '$' &lt; '#' &lt; '='<br>
    </div>
    <br>
    This is consistent with neither an EBCDIC collation nor an DEU/ASCII
    collation:<br>
    <br>
    <div align="center">(EBCDIC)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      '$' &lt; '#' &lt; '=' &lt; alphabetic &lt; digit<br>
      (DEU/ASCII)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; '#' &lt; '$' &lt;
      digit &lt; '=' &lt; alphabetic<br>
    </div>
    <p>Thus in the end we really don't know what collation sequence is
      appropriate.&nbsp; <b>ASM101S</b> temporarily pretends that the
      collation sequence is ASCII since that's the easiest to implement.<br>
    </p>
    <h2>Character Expressions</h2>
    <p>Character expressions consist of text delimited by single-quotes,
      as for example <font color="#663300"><code>'HELLO'</code></font>,
      plus various additional flourishes that you can read about in the
      System/360 assembly-language manual but which I won't bother to
      rehash here.<br>
    </p>
    One flourish which must be mentioned is <a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/84/mode/1up">the









      so-called substring notation</a>, which can be used to extract a
    substring from a string, as in:<br>
    <blockquote>
      <pre><font color="#663300">'HELLO'(<i>start</i>,<i>length</i>)</font><br></pre>
    </blockquote>
    This means that the substring to be extracted begins at <i><font
        color="#663300"><code>index</code></font></i> start and is <font
      color="#663300"><code><i>length</i></code></font> characters in
    width.<br>
    <br>
    One trivial detail which the manual doesn't seem to think worth
    explicitly mentioning, as far as I have been able to ascertain so
    far, is whether the indexing of the string characters is 0-based or
    whether it is 1-based.&nbsp; As curious as it seems, sticklers for
    detail might think this information could be valuable from time to
    time.&nbsp; If you read far enough into the manual, there are
    eventually a couple of examples which indirectly demonstrate that
    indexing of the string is 1-based.<br>
    <h2><a name="declarationSET"></a>Declaration of "SET Symbols"</h2>
    <p>Before describing the specific AP-101S versus System/360 issue
      associated with the items known as "SET symbols", let me summarize
      some of what the System/360 assembly-language manual has to say
      about them.<br>
    </p>
    <p>In System/360 assembly language there is the concept of symbols
      relevant only to the assembler in a preprocessing pass, in
      distinction to symbols representing addresses in the runtime
      memory of the assembled program.&nbsp; These symbols are
      distinguished in that their names are prefixed by the character
      '&amp;'.&nbsp; Thus <font color="#663300"><code>MYVAR</code></font>
      might be a variable representing a memory location, whose contents
      can be modified by the assembly-language program when it is run,
      while <font color="#663300"><code>&amp;MYVAR</code></font> might
      represent an assembly-time variable, assigned a value that can be
      manipulated during the assembly process, but that is not known or
      modifiable by the assembled program.<br>
    </p>
    These assembler-only variables can be classified in a number of
    ways, one of which is that they can be of one of three
    mutually-exclusive types:<br>
    <ol>
      <li>"Symbolic parameters" are the formal parameters found in macro
        definitions.&nbsp; They are assigned values at the time of the
        invocation of the macro, but cannot otherwise be changed.</li>
      <li>"System variables" are assigned values by the assembler
        itself, conceivably different on each use of the variable, and
        cannot be changed by software.&nbsp; They're distinguished by
        the fact that they always begin not just with "&amp;" but with
        the 4-character string "&amp;SYS".</li>
      <li>"SET symbols" can be explicitly created, assigned values, and
        reassigned values by software at will.</li>
    </ol>
    <p>Here, we're concerned only by the latter category, namely the SET
      symbols.<br>
    </p>
    <p>SET symbols can be categorized another way, namely by their
      datatypes, which cannot be changed once established.&nbsp; The
      three types are:<br>
    </p>
    <ol type="A">
      <li>Integer</li>
      <li>Boolean</li>
      <li>Character string</li>
    </ol>
    <p>Yet a third way that they can be characterized is as:<br>
    </p>
    <ul>
      <li>GBL: "global" variables accessible identically in all
        software, whether inside or outside of macro definitions and
        invocations.<br>
      </li>
      <li>LCL: "local" variables accessible only within a single
        invocation of the macro definition in which they are
        defined.&nbsp; (Or else if declared outside of all macro
        definitions, accessible only outside of all macro definitions or
        invocations.)<br>
      </li>
    </ul>
    Prior to the first use of any SET symbol, it must be declared via of
    the macro-language instructions <font color="#663300"><code>GBLA</code></font>,
    <font color="#663300"><code>GBLB</code></font>, <font
      color="#663300"><code>GBLC</code></font>, <font color="#663300"><code>LCLA</code></font>,
    <font color="#663300"><code>LCLB</code></font>, or <font
      color="#663300"><code>LCLC</code></font>.&nbsp; Any of these
    instructions also assigns an initial value the symbol, either 0,
    False (0), or '' (empty string), depending on the datatype. &nbsp;
    For example, the instruction "<font color="#663300"><code>LCLB
        &amp;BOO</code></font>" declares a local boolean SET symbol
    called <font color="#663300"><code>&amp;BOO</code></font> and
    assigns it the default value False (numerically, 0).<br>
    <br>
    After declaration, the value of a SET symbol may be changed (within
    its global or local scope, as appropriate) via one of the
    macro-language instructions <font color="#663300"><code>SETA</code></font>,
    <font color="#663300"><code>SETB</code></font>, or <font
      color="#663300"><code>SETC</code></font>.<br>
    <br>
    Okay, that was the background, but here's the AP-101S specific
    issue:&nbsp; In actual AP-101S assembly-language source code, there
    are SET symbols modified by <font color="#663300"><code>SETA</code></font>,
    <font color="#663300"><code>SETB</code></font>, or <font
      color="#663300"><code>SETC</code></font> (or used in other
    manners) without any declaration via <font color="#663300"><code>GBLA</code></font>,
    <font color="#663300"><code>GBLB</code></font>, <font
      color="#663300"><code>GBLC</code></font>, <font color="#663300"><code>LCLA</code></font>,
    <font color="#663300"><code>LCLB</code></font>, or <font
      color="#663300"><code>LCLC</code></font> whatsoever (prior or
    otherwise), which is a possibility denied by the System/360
    assembly-language manual.<br>
    <br>
    For example, consider <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC/INPUT.asm">the









      INPUT macro</a>, provided as part of the AP-101S runtime library
    by the original source code of the HAL/S compiler HAL/S-FC.&nbsp; It
    has four SET symbols that are used without declarations, highlighted
    in <font color="#33cc00">green</font> in the listing below:<br>
    <blockquote>
      <pre>         MACRO                                                          00000100<br>         INPUT &amp;X                                                       00000200<br>         GBLA  &amp;ENTCNT                                                  00000300<br>         GBLB  &amp;INPUT(20),&amp;LIB                                          00000400<br>         AIF   (N'&amp;SYSLIST EQ 0).EMPTY                                  00000500<br>&amp;INPUT(&amp;ENTCNT) SETB 1                                                  00000600<br>         AIF   ('&amp;X' EQ 'NONE').SPACE                                   00000700<br><font color="#33cc00">&amp;I</font>       SETA  1                                                        00000800<br><font color="#33cc00">&amp;LAST</font>    SETA  N'&amp;SYSLIST                                               00000900<br>.LOOP    AIF   (K'&amp;SYSLIST(<font color="#33cc00">&amp;I</font>) NE 2).BADREG                             00001000<br><font color="#33cc00">&amp;R</font>       SETC  '&amp;SYSLIST(<font color="#33cc00">&amp;I</font>)'                                           00001100<br>         AIF   ('<font color="#33cc00">&amp;R</font>'(1,1) NE 'F' AND '<font color="#33cc00">&amp;R</font>'(1,1) NE 'R').BADREG           00001200<br>         AIF   ('<font color="#33cc00">&amp;R</font>' EQ 'R0').BADREG                                    00001300<br>         AIF   (&amp;LIB AND ('<font color="#33cc00">&amp;R</font>' EQ 'R1' OR '<font color="#33cc00">&amp;R</font>' EQ 'R3')).INVREG1        00001400<br>         AIF   (NOT &amp;LIB AND '<font color="#33cc00">&amp;R</font>' EQ 'R4').INVREG2                      00001500<br>         AIF   (D'<font color="#33cc00">&amp;R</font>).NEXT                                              00001600<br><font color="#33cc00">&amp;N</font>       SETC  '<font color="#33cc00">&amp;R</font>'(2,1)                                                00001700<br><font color="#33cc00">&amp;R</font>       EQU   <font color="#33cc00">&amp;N</font>                                                       00001800<br>.NEXT    ANOP                                                           00001900<br><font color="#33cc00">&amp;I</font>       SETA  <font color="#33cc00">&amp;I</font>+1                                                     00002000<br>         AIF   (<font color="#33cc00">&amp;I</font> LE <font color="#33cc00">&amp;LAST</font>).LOOP                                       00002100<br>.SPACE   SPACE                                                          00002110<br>         MEXIT                                                          00002200<br>.BADREG  MNOTE 4,' ILLEGAL REGISTER SPECIFICATION - &amp;SYSLIST(<font color="#33cc00">&amp;I</font>)'       00002300<br>         AGO   .NEXT                                                    00002400<br>.INVREG1 MNOTE 4,'<font color="#33cc00">&amp;R</font> INVALID INPUT FOR PROCEDURE ROUTINE'               00002500<br>         AGO   .NEXT                                                    00002600<br>.INVREG2 MNOTE 4,'R4 INVALID INPUT FOR INTRINSIC'                       00002700<br>         AGO   .NEXT                                                    00002800<br>.EMPTY   MNOTE 4,'OPERAND REQUIRED'                                     00002900<br>         MEND                                                           00003000<br></pre>
    </blockquote>
    What are we to make of this?<br>
    <br>
    Upon considerable reflection, my inference is that the AP-101S has a
    built-in convenience feature, either not present or not documented
    in the System/360 assembler, namely this:&nbsp; <br>
    <blockquote><i>When</i><i> a variable that has not previ</i><i>ously
        been expli</i><i>citly declared (b</i><i>y <font
          color="#663300"><code>GBLx</code></font><font size="-1"> or </font><font
          color="#663300"><code>LCLx</code></font></i><font size="-1"><u><i><font
              color="#663300"><code></code></font></i></u></font><i>) is
        the target of a <font color="#663300"><code>SETx</code></font>
      </i><u><i><font color="#663300"><code></code></font></i></u><i>instruction,









        it is declared automatically by the assembler as if via </i><i><font
          color="#663300"><code></code></font></i><i><font
          color="#663300"><code>LCLx</code></font></i><i>.</i><br>
    </blockquote>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;









        If this inference is correct, it might seem naively that there's
        no need for the instructions </font><font size="-1"><font
          color="#663300"><code>LCLA</code></font>, <font
          color="#663300"><code>LCLB</code></font>, or <font
          color="#663300"><code>LCLC</code></font> at all, since a </font><font
        size="-1"><font color="#663300"><code>SETA</code></font>, <font
          color="#663300"><code>SETB</code></font>, or <font
          color="#663300"><code>SETC</code></font> could always be used
        instead.&nbsp; Upon closer inspection that's not true, since </font><font
        size="-1"><font color="#663300"><code>LCLx</code><font
            color="#000000"> (like </font></font></font><font size="-1"><font
          color="#663300"><font color="#000000"><font color="#663300"><code>GBLx</code></font>)
            can additionally be used to declare SET symbols as arrays,
            which a </font></font></font><font size="-1"><font
          color="#663300"><font color="#000000"><font color="#663300"><code>SETx</code></font>
            instruction with this convenience feature could not.&nbsp;
            And even in the non-arrayed case, there are certainly
            instances in existing code in which </font></font></font><font
        size="-1"><font color="#663300"><font color="#000000"><font
              size="-1"><font color="#663300"><code>LCLx</code></font></font>
            is indeed used explicitly even though the described
            convenience feature would not require it.&nbsp; For example,
            consider <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/RUNMAC/AERROR.asm">this









              macro from the AP-101S runtime-library source code</a>,
            which unlike the problematic macro listed above corresponds
            exactly to the System/360 assembly-language manual's
            pronouncements:<br>
          </font></font></font>
      <blockquote>
        <pre><font size="-2">         MACRO                                                          00000100<br>&amp;NAME    AERROR &amp;NUM,&amp;GROUP=4                                           00000200<br>         GBLA  &amp;ERRCNT,&amp;ERRNUMS(10),&amp;ERRGRPS(10)                        00000300<br>         <font color="#009900">LCLA  &amp;I</font>                                                       00000400<br>         AIF   (&amp;NUM GT 62).BADNUM                                      00000500<br><font color="#009900">&amp;I</font>       SETA  &amp;ERRCNT                                                  00000600<br>.DUPLOOP AIF   (<font color="#009900">&amp;I</font> LE 0).NEWERR                                         00000700<br>         AIF   (&amp;NUM EQ &amp;ERRNUMS(<font color="#009900">&amp;I</font>) AND &amp;GROUP EQ &amp;ERRGRPS(<font color="#009900">&amp;I</font>)).DUP    00000800<br><font color="#009900">&amp;I</font>       SETA  <font color="#009900">&amp;I</font>-1                                                     00000900<br>         AGO   .DUPLOOP                                                 00001000<br>.NEWERR  ANOP                                                           00001100<br>&amp;ERRCNT  SETA  &amp;ERRCNT+1                                                00001200<br><font color="#009900">&amp;I</font>       SETA  &amp;ERRCNT                                                  00001300<br>&amp;ERRNUMS(<font color="#009900">&amp;I</font>) SETA &amp;NUM                                                  00001400<br>&amp;ERRGRPS(<font color="#009900">&amp;I</font>) SETA &amp;GROUP                                                00001500<br>.DUP     ANOP                                                           00001600<br>*********ISSUE SEND ERROR SVC****************************************** 00001700<br>&amp;NAME    SVC   AERROR<font color="#009900">&amp;I</font>       ISSUE SEND ERROR SVC                      00001800<br>*********SEND ERROR SVC RETURNS CONTROL FOR STANDARD FIXUP************* 00001900<br>         MEXIT                                                          00002000<br>.BADNUM  MNOTE 12,'ERROR NUMBER GREATER THAN 62'                        00002100<br>         MEND                                                           00002200</font><br></pre>
      </blockquote>
      <font size="-1"> As for the origin of such a convenience feature
        in the first place, I'd note that in addition to being
        "convenient", the complexity of some AP-101S macros could make
        some of those macros very difficult or impossible to implement
        otherwise.&nbsp; According to System/360 rules, all <font
          color="#663300"><code>GBLx</code></font> and <font
          color="#663300"><code>LCLx</code></font> instructions must
        appear not merely before <font color="#663300"><code>SETx</code></font>
        instructions involving the SET symbols they declare, but indeed
        prior to everything else.&nbsp; For example, </font><font
        size="-1"><font size="-1"><font color="#663300"><code>GBLx</code></font></font>
        instructions must appear immediately after the prototype line of
        a macro definition, with nothing intervening except comments,
        while </font><font size="-1"><font size="-1"><font
            color="#663300"><code>LCLx</code></font></font> instructions
        in turn must appear immediately after that.&nbsp; Thus if a
        macro definition depends on the flexibility of allowing a SET
        symbol to be declared in alternate ways under different
        circumstances, such as arrayed vs non-arrayed or integer vs
        character, the rules of the System/360 assembler likely would
        not allow it because alternate declarations could appear in the
        prescribed location.&nbsp; Whereas the rules of implicit
        declaration via <font color="#663300"><code>SETx</code></font>
        instructions basically allow non-arrayed local declarations to
        appear anywhere.&nbsp; So the convenience feature of implicit
        declaration, if it truly exists, could have arisen from
        necessity rather than from a desire for mere convenience.&nbsp;
        Not that "mere" convenience is to be sneered at.&nbsp; But
        that's just speculation on my part, with the answer lost in the
        mists of time past.</font><br>
    </blockquote>
    <h2><code><a name="literals"></a>DC</code> and <code>DS</code>
      Pseudo-Op Formats, and "Literals"<br>
    </h2>
    <p><a moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/36/mode/1up?view=theater">The








        System/360 assembly-language manual</a> describes a
      quite-complex format for the operands of the <font
        color="#663300"><code>DS</code></font> and <font
        color="#663300"><code>DC</code></font> pseudo-ops used for
      allocating or initializing data memory.&nbsp; (The description
      takes about 11 pages, which is over 6% of the manual.)&nbsp;
      However, I see no point in implementing those features of this
      format which are not actually used in Space Shuttle
      flight-software source code.&nbsp; At present, I believe that the
      following features of the <font color="#663300"><code>DC</code></font>/<font
        color="#663300"><code>DS</code></font> format do <i>not</i>
      need to be supported in <b>ASM101S</b>:<br>
    </p>
    <ul>
      <li>Type codes L, P, Z, S, V, Q<br>
      </li>
      <li>Scale modifier</li>
      <li>Exponent modifier</li>
    </ul>
    <p>The System/360 manual uses the term <i>literal</i> to refer to
      an operand (for instructions) in a manner differently than I have
      been doing (and differently from what I think is current common
      usage).&nbsp; I have been using the term to describe strings of
      characters such as <font color="#663300"><code>1234</code></font>
      or <font color="#663300"><code>'HELLO WORLD'</code></font>, or
      perhaps <font color="#663300"><code>X'3F7C'</code></font>.&nbsp;
      System/360 (and presumably AP-101S) assembly language don't
      consider these to be "literals".&nbsp; Rather, the following would
      be considered "literals":&nbsp; <font color="#663300"><code>=F'1234'</code></font>,
      <font color="#663300"><code>=C'HELLO WORLD'</code></font>, or <font
        color="#663300"><code>=</code></font><font color="#663300"><code>X'3F7C'</code></font>.&nbsp;




      The distinction, aside from prefixed equals sign and other
      syntactic elements, is that the former are used directly by <font
        color="#663300"><code>DC</code></font> pseudo-ops or in some
      cases coded into instructions, whereas the latter are instead
      assembled into special areas of memory known as "literal pools"
      and only their addresses are coded into instructions.<br>
    </p>
    The reason this is relevant here is that <b>ASM101S</b> doesn't
    support the full range of literals accepted by the System/360
    assembler, and instead limits itself just to those forms of literals
    appearing in Space Shuttle flight software, plus any others I just
    feel like implementing.&nbsp; (The latter being a tiny number
    indeed!)&nbsp; Those supported forms of literals are:<br>
    <blockquote>
      <pre><font color="#663300">=B'...'<font color="#000000">		Binary</font><br>=C'...'<font color="#000000">		Character</font><br>=D'...'<font color="#000000">		Double-precision floating point</font><br>=E'...'<font color="#000000">		Single-precision floating point</font><br>=F'...'<font color="#000000">		Fullword fixed-point</font><br>=H'...'<font color="#000000">		Halfword fixed-point</font><br>=X'...'<font color="#000000">		Hexadecimal</font><br>=Y(...)<font color="#000000">		Nearby address</font><br>=Z(...)<font color="#000000">		Remote address</font></font><br></pre>
    </blockquote>
    Regarding the <font color="#663300"><code>=F'...'</code></font> and
    <font color="#663300"><code>=H'...'</code></font> datatypes, <a
      moz-do-not-send="true" href="ASM101S.html#fixedPoint">see here</a>
    to understand the significant differences between how the AP-101S
    and System/360 assemblers treat them.&nbsp; <br>
    <br>
    In addition to these bare forms, the System/360 assembly-language
    manual also describes a "length modifier" for them, in which the
    initial letter specifying the datatype is optionally followed by "<font
      color="#663300"><code>L<i>n</i></code></font>", where <font
      color="#663300"><code><i>n</i></code></font> is a decimal number
    indicating the number of bytes of memory
    allocated.&nbsp;&nbsp;&nbsp; Similarly, for fixed-point datatypes
    (i.e., <font color="#663300"><code>=F</code></font> and <font
      color="#663300"><code>=H</code></font>) the "scale modifier" ("<font
      color="#663300"><code>S<i>n</i></code></font>") is
    supported.&nbsp; If both are present, the scale modifier must follow
    the length modifier.&nbsp; <br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; The System/360
        manual also describes variations on the allowed modifiers, such
        as "<font color="#663300"><code>L(<i>e</i>)</code></font>"
        (where </font><font size="-1"><font size="-1"><font
            color="#663300"><code><i>e</i></code></font></font> is an
        arithmetic expression), scale modifiers for floating-point
        datatypes (<font color="#663300"><code>=E</code></font> and <font
          color="#663300"><code>=D</code></font>), an "exponent
        modifier" for fixed-point and floating-point datatypes, and so
        on.&nbsp; <b>ASM101S</b> doesn't support any of these
        variations since they don't appear in Shuttle flight software
        source code.</font><br>
    </blockquote>
    While <b>ASM101S</b> supports these length and scale modifiers, the
    length modifier in AP-101S assembly language does not appear to be
    used as described in System/360.&nbsp; Consider this AP-101S
    instruction, which appears in the MSTR module of the HAL/S-FC
    runtime-library:<br>
    <pre><font color="#663300">00013 27F7 0011      0026 0011   57          N     R7,=XL2'F'                                               00002200<br>					     .<br>					     .<br>					     .<br>00024                            75+         LTORG                                                          02-ERRPA<br>00024 FFFF000F                   76                =X'FFFF000F'<br>00026 0000000F                   77                =XL2'F'<br>00028 FFFFFFF0                   78                =X'FFFFFFF0'<br></font></pre>
    The length modifier "<font color="#663300"><code>L2</code></font>"
    in the literal <font color="#663300"><code>=XL2'F'</code></font>
    clearly indicates that even though the provided constant value (<font
      color="#663300"><code>F</code></font>) is only one hexadecimal
    digit, it must assemble to 2 bytes, i.e. to hexadecimal 000F.&nbsp;
    And yet, in reality, we find that it has assembled to 4 bytes, as
    hex 0000000F.&nbsp; In point of fact, since an <font
      color="#663300"><code>=X</code></font> literal by default
    assembles to an even number of bytes (according to the System/360
    manual), the length modifier should not even have been necessary in
    the first place, since it would merely be explicitly expressing the
    default.<br>
    <br>
    What are we to make of this?&nbsp; Unfortunately — or perhaps <i>fortunately</i>,
    depending on your point of view! — there are not enough length
    modifiers appearing in surviving AP-101S assembly-listing reports
    for us to form much of an opinion on the matter just by examining
    those reports.&nbsp; In point of fact, the length modifier I've
    given in the example above is the <i>only</i> length modifier I've
    found in surviving assembly listings.&nbsp; Perhaps in AP-101S,
    length modifiers express the number of halfwords in the assembled
    value rather than the number of bytes?&nbsp; That's the way ASM101S
    treats them at present.<br>
    <br>
    As a less-unruly example, scale modifiers appear to operate on an
    easier-to-understand basis than length operators.&nbsp; Thus, the
    literal <font color="#663300"><code>=FS32'60E6'</code></font>
    superficially appears to assemble to 60000000 (decimal, i.e.
    0x03938700), but because of the scale modifier it is actually
    shifted rightward by 32 bit-positions, i.e. divided by 2<sup>32</sup>.&nbsp;




    So the value it assembles to is instead approximately
    0.013969839.&nbsp; But that still doesn't mean that everything is
    exactly as in System/360.&nbsp; In AP-101S, the fixed-point literals
    have the interesting property (see the link given above about <font
      color="#663300"><code>=F</code></font> and <font color="#663300"><code>=H</code></font>
    datatype differences from System/360) that if they appear to be
    integers, then they assemble into 2's-complement integers, while if
    they appear to be fractional values with absolute value less than
    1.0 they instead assemble into an alternate format maximizing the
    significance in that numerical range.&nbsp; That's what happens in
    this example.&nbsp; The literal assembles to 0x01C9C380, which
    amusingly, is just 60000000/2.<br>
    <br>
    The <font color="#663300"><code>=Z(...)</code></font> format in
    AP-101S is unrelated to the <font color="#663300"><code>=Z'...'</code></font>
    ("zoned decimal format") of System/360, which is not supported by <b>ASM101S</b>
    and is best forgotten entirely.&nbsp; The <font color="#663300"><code>=Z(...)</code></font>
    of AP-101S has three parameters, thusly:<br>
    <blockquote>
      <pre><font color="#663300">=Z(<i>ARG1</i>,<i>ARG2</i>,<i>ARG3</i>)</font><br></pre>
    </blockquote>
    Naturally, as you may expect, <font color="#663300"><code>=Z(...)</code></font>
    is entirely undocumented.&nbsp; It is used in precisely one place,
    namely in the FCMNNIT module of each available version of Shuttle
    flight software.&nbsp; In flight software OI-30.17, that usage looks
    like so in the assembly listing produced by the original assembler:<br>
    <pre><font color="#663300">                                 434          EXTRN <font color="#ff0000">FPMXQETB</font>,FPMXQELE,FCMALLFS                               026120BQ<br>					      .<br>					      .<br>					      .<br> 000DE EAF3 <font color="#ff0000">0000</font>      0000       438          LA    R2,<font color="#ff0000">FPMXQETB</font>         DESTINATION - START OF XQE TABLE     026140BQ<br> 000E0 E2FB 001E      001E       439          IAL   R2,FPMXQECT*2       30 HWS TO INIT - (15 ENTRIES)        026145BQ<br> 000E2 1BF7 00EE      01D2 00EE  440          L     R3,<font color="#ff0000">=Z(,FPMXQETB+2,0)</font>  SOURCE ZCON ADDRESS                026150BQ<br>					      .<br>					      .<br>					      .<br> 001D2                           734          LTORG                                                          050300BG<br> 001D2 <font color="#ff0000">00020000</font>                  735                <font color="#ff0000">=Z(,FPMXQETB+2,0)</font>                                                <br><br></font></pre>
    Since the symbol <font color="#663300"><code>FPMXQETB</code></font>
    is declared as an <font color="#663300"><code>EXTRN</code></font>,
    its address and other characteristics are unknown at assembly time,
    though in fact <font color="#663300"><code>FPMXQETB</code></font>
    is the start of something called the "XQE table", aligned at a
    fullword address, a fact presumably known to the human programmer if
    not to the assembler program.<br>
    <br>
    I think that <font color="#663300"><code>=Z(...)</code></font> is
    used to form "ZCON" addresses.&nbsp; The ZCON compiler option for
    the HAL/S compiler (<b>HAL/S-FC</b>), in the words of the "<a
      moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/Shuttle/HAL_S-FC%20User's%20Manual%20Nov%202005.pdf#page=68">HAL/S-FC





      User's Manual</a>", has the effect of "[causing] calls to
    out-of-line routines (external references) to be performed via long
    indirect address constants".&nbsp; It appears to me that the term
    "ZCON" probably stands for "Z constant", as a contrast to "YCON" for
    constants formed via <font color="#663300"><code>=Y(...)</code></font>,
    which are just 16-bit displacements. &nbsp; The distinction is that
    LOCAL data (in the HAL/S sense) can be accessed by efficient YCON
    addressing, whereas REMOTE data (again in the HAL/S sense) is
    accessed via less-efficient ZCON addressing.<br>
    <br>
    It further appears to me (<a moz-do-not-send="true"
      href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=43">see
      Figure 2-14 of the AP-101S POO</a>) that a 16-bit base address
    fills the top halfword of such an indirect address constant, while
    an 11-bit displacement (padded with 0's to 16 bits) fills the bottom
    halfword.&nbsp; My best guess is that <font color="#663300"><code>=Z(<i>ARG1</i>,<i>ARG2</i>,<i>ARG3</i>)</code></font>
    is perhaps better represented as <font color="#663300"><code>=Z(TBD,<i>BASE</i>,<i>DISPLACEMENT</i>)</code></font>.<br>
    <br>
    Thus in the assembly-listing excerpts shown above,<font
      color="#663300"><code> FPMXQETB+2</code></font> is the <font
      color="#663300"><code><i>BASE</i></code></font> address, though
    the external symbol is simply assembled as having address 0, since
    its address is unknown to the assembler (later to be fixed up by the
    linker) causing <font color="#663300"><code>FPMXQETB+2</code></font>
    to assembled as just 2.&nbsp; Similarly, the <font color="#663300"><code><i>DISPLACEMENT</i></code></font>
    is 0.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; I don't claim that
        all of the mysteries of <font color="#663300"><code>=Z(...)</code></font>
        have been solved by the meandering inferences above&nbsp; They
        do explain, more or less, how the assembler should turn <font
          color="#ff0000"><code>=Z(,FPMXQETB+2,0)</code></font> into <font
          color="#ff0000"><code>0002 0000</code></font>.&nbsp; But what
        happens after the object code leaves the assembler and is
        processed by the linker?&nbsp; By process of elimination, the
        assembly-listing excerpts above came from flight software
        version OI-30.17, because those are the only contemporary
        assembly listings available to me.&nbsp; But the associated
        source code is identical in flight software version OI-34.06,
        for which I have no contemporary assembly listing, but for which
        I do have a contemporary disassembly of the <i>linked</i>
        object code, thus giving us some clues about how the linker
        treats these <font color="#663300"><code>=Z(...)</code></font>
        literals.&nbsp; What we find in the linked OI-34.06 is that <font
          color="#ff0000"><code>FPMXQETB</code></font> ends up at
        address 008B6A, and that the </font><font size="-1"><font
          size="-1"><font color="#ff0000"><code>=Z(,FPMXQETB+2,0)</code></font>
        </font>constant itself becomes 8B6C 0001.&nbsp; The upper
        halfword is precisely what we would have expected!&nbsp; But
        what about the lower halfword?&nbsp; Why has the linker turned
        0000 into 0001?&nbsp; That's a mystery to me.&nbsp; In case
        you're interested, here's what the relevant portions of that
        contemporary disassembly of the FCMNINIT module in OI-34.06 look
        like:</font><br>
      <pre><font size="-1"> 008B6A         FCMCBLKS+0A50                           <font color="#ff0000">FPMXQETB</font> DS     0F<br>				    .<br>				    .<br>				    .<br> 018A52-018A53  FCMNINIT+00DE       EAF3  <font color="#ff0000">8B6A</font>  008B6A           LA     R2,<font color="#ff0000">X'8B6A'</font>             FPMXQETB<br> 018A54-018A55  FCMNINIT+00E0       E2FB  001E                   IAL    R2,X'001E'<br> 018A56-018A57  FCMNINIT+00E2       1BF7  00F6  018B4E           L      R3,<font color="#ff0000">X'00F6'</font>             =Z''<br>				    .<br>				    .<br>				    . <br>&nbsp;018B4E-018B4F  FCMNINIT+01DA       <font color="#ff0000">8B6C  0001</font>                   DC     <font color="#ff0000">Z</font></font><br></pre>
    </blockquote>
    The "<font color="#663300"><code>=E</code></font>" (single-precision
    floating-point) and "<font color="#663300"><code>=D</code></font>"
    (double-precision floating-point) datatypes also require a few
    additional words of explanation.&nbsp; While literals (or constants)
    of these types are provided in AP-101S assembly-language source-code
    in the usual decimal notation, they are encoded into object code by
    the assembler in "IBM hexadecimal floating-point" format ("IBM
    hex").&nbsp; Regarding this conversion of decimal to IBM Hex, <a
      moz-do-not-send="true"
href="https://archive.org/details/bitsavers_ibm360asmGLanguageRel21197201_10219231/page/44/mode/1up?view=theater">the



      System/360 assembly-language manual</a> has this to say on the
    subject (emphasis mine):<br>
    <blockquote>"The number is converted to a binary number, and scaling
      is performed if specified. The binary number is then rounded and
      assembled into the proper field, according to the specified or
      implied length.&nbsp; <i>The resulting number will not differ
        from the exact value by more than one in the last place</i>."<br>
    </blockquote>
    In other words, the conversion algorithm used by the original
    assembler was not necessarily exact to the apparent full
    precision.&nbsp; Consequently, object code containing floating-point
    constants as produced by <b>ASM101S</b> cannot be guaranteed to
    byte-for-byte match the floating-point constants generated by the
    original assembler.&nbsp; This potential for inexact conversions is
    exacerbated by the fact that the native floating-point precision in
    the Python 3 language in which <b>ASM101S</b> is written does not
    precisely match the native floating-point precision of System/360;
    Python 3 is more accurate than System/360 in some cases, and less
    accurate in others, I believe.&nbsp; <b>ASM101S</b> works around
    this latter problem by performing the floating-point operations for
    such conversions at a higher precision than normal Python
    floating-point operations, namely 20 significant digits rather than
    16.&nbsp; Empirically, the conversions by <b>ASM101S</b> match the
    conversions provided by the original assembler in all <i>known</i>
    cases, but there's no guarantee for presently-unknown cases.&nbsp;
    Nor is the range of the two floating-point formats (in terms of
    powers-of-ten exponentiation) identical; <b>ASM101S</b> makes no
    attempt to work around this range mismatch, because there are no
    offending examples in existing legacy source code.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Expressed in
        different terms, <b>ASM101S</b> (presumably!) does not use
        exactly the same algorithm as the original assembler to perform
        the conversion from decimal strings to IBM hex.&nbsp; That's
        because I don't presently know what that original algorithm
        was.&nbsp; Thus <b>ASM101S</b> simply uses a conversion
        algorithm of my own concoction.&nbsp; Perhaps at some point the
        original algorithm may be deduced or recovered somehow.&nbsp; If
        that happens, then it can be incorporated into <b>ASM101S</b>,
        in which case none of the concerns I've been describing will
        obtain.<br>
        <br>
        I'd also note that while we do not have the source code of the
        original AP-101S assembler, the System/360 assembler presumably
        used the same conversion algorithm, and probably even the same
        source code to implement the conversion algorithm.&nbsp; I'm
        told that the source code for one version of the System/360
        assembler is online, though I don't provide it in the Virtual
        AGC library due (in what's probably an excess of paranoia) to
        copyright concerns.&nbsp; Someone sufficiently immersed in
        System/360 assembly language might be able to abstract the
        conversion algorithm from examination of that source code.&nbsp;
        I looked at the System/360 source code myself and concluded,
        alas, that I am not such a person.&nbsp; If you want to try it
        yourself and give me the algorithm in easily-understood
        pseudo-code (or better yet, in Python 3), the System/360
        assembler's source code is the file AS037F1.TXT, <a
          moz-do-not-send="true"
          href="https://www.ibiblio.org/jmaynard/">supposedly present
          somewhere in the archive at this hyperlink</a>, though I've
        been unable to find it there myself.&nbsp; Good luck!<br>
      </font></blockquote>
    We might be tempted to disregard some potential precision error in
    the 32nd or 64th bit as being far too small to matter.&nbsp; The
    reason it matters is because it affects validation of the assembler
    in the following way:&nbsp; <b>ASM101S</b> has the capability of
    performing byte-for-byte comparisons of new assemblies vs legacy
    assemblies (where available), and thus discrepancies in even the
    least-significant bit could be flagged as errors.&nbsp; Our (or at
    least <i>my</i>) criterion for accepting <b>ASM101S</b> as valid
    is that these automatic comparisons detect no error. &nbsp; Even if
    we are prepared to accept such discrepancies as being all right,
    they nevertheless defeat automated validation.<br>
    <br>
    By the way, regarding the just-mentioned automated comparison of
    generated code, it should also be noted that the assembly listings
    only display the first 16 hexadecimal digits of binary data
    generated by <font color="#663300"><code>DC</code></font>
    pseudo-ops, whereas (of course!) the entire value is available to <b>ASM101S</b>.&nbsp;



    Consequently, even if the compiler reports a 100%-successful
    automated comparison, generated data not printed in the assembly
    listings has not been checked and may not match.<br>
    <br>
    <ul>
    </ul>
    <h2><a name="SRS"></a>SRS-Type Instructions Versus RS-Type
      Instructions</h2>
    <p>AP-101S instructions are of 5 basic types, designated (by IBM) as
      RR, RS, SRS, RI, and SI, based on the syntax patterns of their
      operands and on the ways they are encoded as machine
      instructions.&nbsp; Some of these are System/360 patterns, and
      some are not.&nbsp; I won't bore you with the details, as you can
      read about them in <a moz-do-not-send="true"
        href="Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=34">the








        AP-101S Principles of Operation</a>.&nbsp; However, there is a
      certain difficulty with SRS- and RS-type instructions — as well as
      ambiguities between two different flavors of RS-type instructions,
      namely "extended" (AM=0) vs "indexed" (AM=1) instructions — that
      could <i>in principle</i> cause a mismatch between object code
      generated by <b>ASM101S</b> vs the original AP-101S assembler,
      though hopefully not any behavioral difference at runtime other
      than slight timing discrepancies.&nbsp; This group of instructions
      includes, among other things, all <a moz-do-not-send="true"
        href="#instructionAliases">conditional-branch instructions and
        their aliases</a>.<br>
    </p>
    <p>The greatest difficulty relates to the fact that certain
      instruction mnemonics are used <i>both</i> for SRS-type
      instructions and RS-type instructions.&nbsp; Moreover, while some
      of the operand patterns for them are accepted for SRS instructions
      and not RS instructions, thus allowing the assembler to
      distinguish between them, <i>some</i> of the operand patterns
      nevertheless overlap.&nbsp; In case of overlap, there is no
      syntactic way for the assembler to distinguish between the SRS
      instruction and the RS instruction.&nbsp; Overlap occurs for the
      following syntactical patterns (where <font color="#663300"><code>R1</code></font>,
      <font color="#663300"><code>D2</code></font>, and <font
        color="#663300"><code>B2</code></font> refer to the names of
      fields in the encoded machine instruction):<br>
    </p>
    <blockquote>
      <pre><font color="#663300"><i>OPCODE</i>	R1,D2<br><i>OPCODE</i>	R1,D2(B2)</font><br></pre>
    </blockquote>
    <p>The vulnerable opcode mnemonics are:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">A AE AH BC C CH D DE IAL L LA LE LH M ME MH N O S SE SH SHW ST STH TD TH X ZH</font><br></pre>
    </blockquote>
    While the SRS-type and RS-type instructions are (almost)
    behaviorally identical, they are encoded differently as machine
    instructions, and in particular require different amounts of memory
    to do so.&nbsp; SRS-type instructions are encoded as half-words (2
    bytes), while RS-type instructions are encoded as full words (4
    bytes).&nbsp; For example, there is no syntactical way to know
    whether to encode the load-instruction "<font color="#663300"><code>L
        4,SWITCH</code></font>" as 2 bytes or as 4 bytes.&nbsp; So if <b>ASM101S</b>
    were to encode an instruction as SRS while the original assembler
    were to encode it as RS, or vice-versa, then not only would the
    binary forms of those particular instructions differ, but all of the
    code following that instruction in the same control section would be
    aligned differently.<br>
    <blockquote><font size="-1"><b>Aside</b>:&nbsp; I say that the
        SRS-types instruction and RS-type instructions are "almost"
        behaviorally identical.&nbsp; <a moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=33">Figure








          2-2 of the AP-101S Principles of Operation</a> tells us about
        one difference.&nbsp; When an SRS-type instruction specifies a
        base register (<font color="#663300"><code>B2</code></font>)
        equal to 3, it means to <i>really</i> use general-register 3,
        as one would expect.&nbsp; Whereas when an RS-type instruction
        specifies base register 3, it means instead to use "no" base
        register.<br>
        <br>
        What does it mean to use "no" base register?&nbsp; <a
          moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/Shuttle/Shuttle%20GPC%20Software%20Model%20AP-101S.pdf#page=40">Several








          pages later</a>, we're told that "When B2 equals 11, base
        addressing is not performed. In this case, the displacement is
        instead used directly as the effective address."&nbsp; In other
        words, the displacement is the number of halfwords, within the
        same CSECT, from the instruction following the RS instruction to
        the target location.</font><br>
    </blockquote>
    <p>As I said, there is no syntactic way for the assembler to
      distinguish between these cases, but there is a non-syntactic way
      based on the size of the <font color="#663300"><code>D2</code></font>
      sub-operand.&nbsp; If <font color="#663300"><code>D2</code></font>
      is in the numerical range 0-55, then the SRS instruction could
      potentially be used, while if <font color="#663300"><code>D2</code></font>
      is 56 or greater, the RS instruction must be used.&nbsp;
      Unfortunately, determining these displacements between two
      locations is quite tricky, because there might be some of these
      SRS/RS instructions with ambiguous sizes in between.&nbsp; In
      fact, for forward references, there is guaranteed to be at least
      one such intervening instruction.&nbsp; In other words, we don't
      know the sizes of the displacements until we know the sizes of the
      intervening instructions, and we don't know the sizes of the
      intervening instructions until we know the sizes of all of the
      displacements.<br>
    </p>
    <p>In so far as the ambiguity between RS-type "extended"
      instructions vs "indexed" instructions, this is a lesser problem
      than the SRS-vs-RS problem, because both extended and indexed
      varieties of the instruction assemble to a fullword, and thus the
      use of the wrong variation of the instruction results only in a
      mismatch at that exact memory location rather than a general
      displacement of all the succeeding memory locations.&nbsp; As with
      the SRS-vs-RS instructions, there are cases in which the variation
      in syntax does allow distinguishing the two cases.&nbsp; Roughly
      speaking, the syntax of extended vs indexed RS-type instructions
      is<br>
    </p>
    <blockquote>
      <pre><font color="#663300"><i>OPCODE</i>		R1,D2(B2)</font><br><font color="#663300"><i>OPCODE</i>[@][#]	R1,D2(X2,B2)</font></pre>
    </blockquote>
    <p>but since the <font color="#663300"><code>@</code></font>, <font
        color="#663300"><code>#</code></font>, and <font
        color="#663300"><code>X2</code></font> are all optional
      syntactically, in their absence there's no way to distinguish
      between extended vs indexed instructions other than the numerical
      range allowed for the displacement <font color="#663300"><code>D2</code></font>.&nbsp;




      As well, the latter (indexed) of the two cases allows the syntax</p>
    <blockquote>
      <pre><font color="#663300"><i>OPCODE</i>	</font><font color="#663300">	R1,D2(X2)</font></pre>
    </blockquote>
    <p> </p>
    for an even greater potential for confusion.&nbsp; Yay!&nbsp;
    Fortunately, allowed base registers (<font color="#663300"><code>B2</code></font>)
    for AP-101S are only the CPU general registers 0-3, so if general
    register 4-7 appear in such an instruction, it's clear that index
    register <font color="#663300"><code>X2</code></font> is meant
    rather than base register <font color="#663300"><code>B2</code></font>.<br>
    <br>
    In lieu of any foolproof algorithm for resolving these ambiguities,
    as well as lacking knowledge of whatever algorithm the original
    AP-101S assembler used, <b>ASM101S</b> cannot be guaranteed to
    produce the same choices of SRS instructions versus RS instructions
    made by the original assembler.&nbsp; All I can say is that I've
    tried to craft <b>ASM101S</b> in such a way as to match when
    assembling existing Shuttle flight software.<br>
    <br>
    For a clearer explanation, perhaps it's best to refer to the rules
    of <a moz-do-not-send="true" href="https://youtu.be/_DeIExLcURQ">the




      card game known as Fizzbin</a> which was developed at roughly the
    same time.<br>
    <h2>Uninitialized Memory</h2>
    <p>Although unstated in the original documentation, I believe that
      the original AP-101S assembler filled uninitialized memory with
      the halfword pattern 0xC9FB.&nbsp; This happens to be the first
      halfword of the AP-101S instruction <font color="#663300"><code>SVC</code></font>,
      which as the AP-101S POO explains (p. 9-16), "causes an
      interruption and a program status word switch".&nbsp; (The second
      halfword is the operand for <font color="#663300"><code>SVC</code></font>.)&nbsp;







      Whether the consistent use of this particular value is significant
      or merely a coincidence, I can't say; perhaps the intention was to
      use this to trap unintentional execution from uninitialized
      memory.<br>
    </p>
    <p>The reason I suspect that this is the case is that in surviving
      legacy assembly reports, 0xC9FB is inevitably at locations where
      there's a gap due to forcing alignment of data to particular
      boundaries, such as aligning fullword constants to fullword
      addresses.&nbsp; For example, consider this excerpt from the
      assembly report for the ACOS module:<br>
    </p>
    <pre>					     .<br>					     .<br>					     .<br>0005D 58E0                      182 RET0     SER   F0,F0                                                    00010504<br>0005E DF4E           004C 0013  183          B     EXIT                                                     00010600<br>                                184 *                                                                       00010700<br>0005F <font color="#ff0000">C9FB</font><br>00060                           185          DS    0F                                                       00010800<br>00060 413243F7                  186 PI       DC    X'413243F7'    PI                                        00010900<br>00062 411921FB                  187 PIOV2    DC    X'411921FB'    PI/2                                      00011000<br>					     .<br>					     .<br>					     .<br></pre>
    <p>Here, the instruction <code>B EXIT</code> at halfword address
      0x0005F is immediately followed by the pseudo-op <code>DS</code>,
      whose purpose is to align to the next fullword address boundary
      (i.e., the next <i>even</i> halfword).&nbsp; In the absence of
      realignment, though, the next halfword address after the branch
      instruction would have been 0x0005F (which is an odd halfword
      address).&nbsp; Therefore, the assembler inserts a halfword at
      0x0005F, so that DS can appear instead at 0x00060 (which is now an
      even address address).&nbsp; The value of that halfword is 0x<font
        color="#ff0000">C9FB</font>.<br>
    </p>
    <h2>@# Syntax for Second Operands</h2>
    <p>AP-101S instructions of type RS (such as <font color="#663300"><code>LH</code></font>,
      <font color="#663300"><code>STH</code></font>, etc.) accept an
      operand syntax of which the most-general form is:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">OPCODE	R1,D2(X2,B2)</font><br></pre>
    </blockquote>
    <p>where <font color="#663300"><code>R1</code></font> represents a
      general-purpose register designated as "operand #1", <font
        color="#663300"><code>D2</code></font> represents a
      "displacement" (which may take the form of a number or a program
      label), <font color="#663300"><code>X2</code></font> represents a
      general-purpose register (designated as the "index register"), and
      <font color="#663300"><code>B2</code></font> represents yet
      another general-purpose register (designated as the "base
      register").<br>
    </p>
    <p>That said, there is a bewildering number of exceptions,
      restrictions, and rules for interpreting these different
      elements.&nbsp; Additionally, each RS-type instruction can be
      assembled into two separate forms of machine instructions, namely
      the so-called "extended" and "indexed" forms, as well as sometimes
      into a third form, <a moz-do-not-send="true" href="#SRS">the
        so-called SRS form discussed a couple of sections ago</a>.&nbsp;
      It's not my intention to explain all of these details — I don't
      understand quite a few of them myself, anyway! —, and most of them
      are explained in the AP-101S POO anyway.<br>
    </p>
    <p>But by saying that <i>most</i> of syntactical variations are
      explained by the POO, at least in spirit, I'm also implying that
      some of them are <i>not</i> ... and I'd like to supply those
      missing explanations that pertain to the operation of the
      assembler.&nbsp; In particular, most of the four syntactical
      elements mentioned above may be omitted under various
      circumstances.&nbsp; <br>
    </p>
    <p>Before getting to that, another thing you need to know is that
      many of these RS-type instructions have related instructions in
      which the characters "@", "#", or "@#" are suffixed to the
      mnemonic.&nbsp; For example, I mentioned above that <font
        color="#663300"><code>LH</code></font> and <font
        color="#663300"><code>STH</code></font> are RS-type
      instructions, but so too are <font color="#663300"><code>LH@</code></font>,
      <font color="#663300"><code>LH#</code></font>, <font
        color="#663300"><code>LH@#</code></font>, <font color="#663300"><code>STH@</code></font>,
      <font color="#663300"><code>STH#</code></font>, and <font
        color="#663300"><code>STH@#</code></font>.&nbsp; The AP-101S POO
      explains these variations as follows:<br>
    </p>
    <ul>
      <li><font color="#663300"><code>OPCODE</code></font> (without @ or
        #) specifies "direct addressing without autoindexing".</li>
      <li><font color="#663300"><code>OPCODE@</code></font> specifies
        "indirect addressing".</li>
      <li><font color="#663300"><code>OPCODE#</code></font> specifies
        direct addressing with autoindexing.</li>
      <li><font color="#663300"><code>OPCODE@#</code></font> specifies
        indirect addressing with autoindexing.<br>
      </li>
    </ul>
    <p>The omissions of syntactical elements which I'm concerned about
      here are those of the <font color="#663300"><code>X2</code></font>
      or <font color="#663300"><code>B2</code></font> elements,
      resulting in operands like<br>
    </p>
    <blockquote>
      <pre><font color="#663300"><code>OPCODE 	R1,D2(B2)</code><code><br></code><code>OPCODE@	R1,D2(X2)</code></font><br></pre>
    </blockquote>
    <p>Insofar as assembly is concerned, the question that arises is
      this:&nbsp; If you have an operand syntax like <font
        color="#663300"><code>R1,D2(<i>register</i>)</code></font>, is <i><font
          color="#663300"><code>register</code></font></i> supposed to
      be an index register, or is it supposed to be a base
      register?&nbsp; My inference is that it is supposed to be a base
      register if there is no @ or # suffix on the mnemonic, but it is
      supposed to be an index register for the @/#/@# forms of the
      mnemonic.&nbsp; In the case where <i><font color="#663300"><code>register</code></font></i>
      is a base register and no index register is specified, the
      "extended" form of machine instruction is generated (and it
      requires no index register); whereas in the case where <i><font
          color="#663300"><code>register</code></font></i> is an index
      register and no base register is specified, the "indexed" form of
      machine instruction is generated and the base register defaults to
      general-purpose register 0.<br>
    </p>
    <h2><a name="fixedPoint"></a>Fixed-Point Data</h2>
    <p>By "fixed-point" data, I'm referring to data specified in
      operands of DC pseudo-ops, <i>à la</i><br>
    </p>
    <blockquote>
      <pre><font color="#663300">DC    F'12.345'		(fullword fixed-point)<br>DC    H'-6.12'		(halfword fixed-point)</font><br></pre>
    </blockquote>
    <p>Here we have a case in which the usage in AP-101S assembly
      language, per the AP-101S POO, is entirely at odds with the usage
      in System/360 BAL, per the System/360 assembly-language
      manual.&nbsp; In System/360, the non-integer portions of these
      specifications are discarded (although optional "exponent factors"
      and "scale factors" can be used to apply binary or decimal shifts
      to the data before doing so, thus preserving as much significance
      in the fractional part as may be desired).<br>
    </p>
    <p>For AP-101S, on the other hand, there are two very different
      cases.&nbsp; First, if the data does not contain a decimal point
      or exponent, then what is generated for it in memory is simply the
      4-byte or 2-byte 2's-complement representation of the integer
      value.<br>
    </p>
    <p>Second, if the data does contain a decimal point or exponent,
      then the full value is entirely fractional:&nbsp; i.e., &gt;-1.0
      and &lt;1.0.&nbsp; The constant is assembled to a binary value
      basically by multiplying by 2<sup>31</sup> (in the case of <font
        color="#663300"><code>F'...'</code></font>) or by 2<sup>15</sup>
      (in the case of <font color="#663300"><code>H'...'</code></font>),






      discarding the fractional portion, and representing the remaining
      integer in 2's-complement form.<br>
    </p>
    <p>For example,<br>
    </p>
    <blockquote>
      <pre><font color="#663300">DC	H'0.625'</font><br></pre>
    </blockquote>
    <p>generates 0.625×2<sup>15</sup> = 20480 = 0x5000.<br>
    </p>
    <p>It's TBD what should happen if there is a non-zero integer
      portion, but <b>ASM101S</b> simply caps the generated value to
      the boundaries of the representable range, which essentially means
      that any integer portion is transparently dropped. <br>
    </p>
    <h2>"Linking" By the Assembler Itself</h2>
    <p>The AP-101S assembler performed a kind of partial linking of the
      object code, prior to any linking of separately-compiled modules
      by the AP-101 link editor.&nbsp; <a moz-do-not-send="true"
        href="HALLINK101S.html#partial">See the discussion on the <b>HALLINK101S</b>
        page</a>.</p>
    <h1><a name="structureASM101S"></a>Structure of ASM101S, for
      Maintainers</h1>
    <p>This section won't be of interest to anybody who merely wishes to
      <i>use</i> <b>ASM101S</b>.&nbsp; But given that I haven't
      necessarily been able so far to provide support in <b>ASM101S</b>
      for every feature of AP-101 assembly language that might be
      discovered if additional legacy code becomes available in the
      future, <b>ASM101S</b> may need to be maintained in the
      future.&nbsp; So it may be worthwhile to provide at least a few
      notes on how <b>ASM101S</b> is structured internally, in order to
      facilitate that possible maintenance.<br>
    </p>
    <p>The Python 3 source code for <b>ASM101S</b> is kept in <a
        moz-do-not-send="true"
        href="https://github.com/virtualagc/virtualagc/tree/master/ASM101S">the


        ASM101S/ folder of the Virtual AGC software tree</a>, and the
      top-level source-code file is itself called ASM101S.py.&nbsp;
      There are also a number of additional Python files in that folder
      which are imported as modules into ASM101S.py or into each
      other.&nbsp; I should note that there are other Python files in
      that folder that I find useful, but that are not used as modules
      in <b>ASM101S</b>.<br>
    </p>
    <p>Assembly proceeds in a sequence of "passes", some of which are
      designated as passes in the source code, and some of which are
      not.&nbsp; Here's a brief runthrough of the passes:<br>
    </p>
    <ul>
      <li>"Acquisition pass":&nbsp; In this pass, all AP-101
        assembly-language source code for the selected input files is
        read from files into a Python list called <code>source</code>;
        there is an entry in <code>source</code> for each line of code
        or macro definition encountered; those entries are Python
        dictionaries containing various information about the lines,
        though some information is added to those dictionaries in later
        passes.&nbsp; The acquisition pass includes reading the entire
        macro library, handling all file-inclusions (i.e., all <code>COPY</code>
        pseudo-ops), and resolving all assembly-language macro
        operations.&nbsp; For example, all macro invocations are
        expanded, all conditional assembly is no longer conditional, and
        so on.&nbsp; This means that at the end of the acquisition pass,
        no more symbols of the form <code>&amp;<i>SOMETHING</i></code>
        remain, nor any "sequence symbols" (i.e., labels of the form <code>.<i>SOMETHING</i></code>).&nbsp;


        In AP-101S (or System/360) assembly language, it is a difficult
        technical feat to deal with lists of macro parameters (both for
        macro definitions and macro invocations) that are split across
        continuation cards; the acquisition pass handles this task using
        TatSu (see "PASS 0" below), joining all continuations in the <code>"operand"</code>
        field (see below), so that later passes basically ignore all
        continuation cards.&nbsp; The acquisition pass is integrated
        into the way ASM101S.py parses command-line options, and occurs
        whenever an option like <code>--library=<i>SOMETHING</i></code>
        or the name of a source-code file is encountered on the
        command-line.&nbsp; It is not marked in any way as being a
        "pass".&nbsp; Some of the important fields in the <code>source</code>
        entries created in this pass for use by later passes are:</li>
      <ul>
        <li><code>"text"</code> — the unmodified text of the original
          line.</li>
        <li><code>"name"</code> — the label field of the line.</li>
        <li><code>"operator"</code> — the operator field of the line.</li>
        <li><code>"operand"</code> — the operand+comment fields of the
          line.</li>
        <li><code>"file"</code> — the name of the source-code file
          containing the line.</li>
        <li><code>"lineNumber"</code> — the line number (starting at 1)
          the line within its source-code file.</li>
        <li><code>"n"</code> — the index within <code>source</code>.</li>
        <li><code>"empty"</code> — boolean for completely-blank lines</li>
        <li><code>"fullComment"</code> — boolean for full-line comments
          ("*" in column 1)</li>
        <li><code>"dotComment"</code> — boolean for dot-comments (".*"
          in columns 1,2)</li>
        <li><code>"macro"</code> — name of the including macro
          definition, if any</li>
        <li><code>"continues"</code> — boolean for a non-blank
          continuation field (column 71)</li>
        <li><code>"identification"</code> — contents of the "ident"
          field (columns 72-80)</li>
        <li><code>"errors"</code> — array of assembler-generated
          error/warning messages for the line.</li>
        <li><code>"inMacroDefinition"</code> — boolean for the line
          being part of a macro definition.</li>
        <li><code>"copy"</code> — boolean for the line being present due
          to a <code>COPY</code> pseudo-op</li>
        <li><code>"printable"</code> — boolean for whether to include
          the line in the output assembly report.</li>
        <li><code>"depth"</code> — depth of the line within nested macro
          expansions.&nbsp; (0 means outside of any expansion.)<br>
        </li>
      </ul>
      <li>"PASS 0":&nbsp; (<b>Note:</b>&nbsp; PASS 0, and <i>all</i>
        remaining passes unless stated otherwise, are implemented within
        the AP-101 code generator, of which the top-level file is the
        Python module model101.py.)&nbsp; Lines of assembly-language
        code are nominally divided into 4 fields: label, operator,
        operand, comment.&nbsp; It is difficult to separate the comment
        field from the operand field in an easy, systematic way, so both
        are kept together in the <code>"operand"</code> field in the <code>source</code>
        array.&nbsp; Operand fields can be quite complex, to the point
        where it is easiest to parse them by defining Backus-Naur Form
        (BNF) rules for allowable operand formats, with different rules
        applying for different types of operator fields.&nbsp; PASS 0
        has the task of using these BNF rules, on an
        operator-by-operator basis, for parsing the operand fields and
        removing any add-on comments.&nbsp; The parsed operands are
        stored in the <code>source</code>&nbsp; entry in a new field,
        called <code>"ast"</code>.&nbsp; There is thus no need for any
        later passes to perform additional parsing on the operand
        fields.&nbsp; The custom BNF rules are provided in the Python
        module fieldParser.py.&nbsp; These custom rules are compiled and
        made usable by <a moz-do-not-send="true"
          href="https://github.com/neogeny/TatSu">the
          generally-available Python module called TatSu</a>, which must
        be installed for <b>ASM101S</b> to function.</li>
      <li>"PASS 1":&nbsp; AP-101 assembly language contains an
        unfortunate ambiguity, in that a number of instruction mnemonics
        are used in common for several distinct underlying machine
        instructions.&nbsp; Some of these underlying machine
        instructions (of type "SRS") are a halfword in length and some
        (of type "RS") are a fullword in length.&nbsp; Thus it is often
        not possible to tell merely from the instruction mnemonic how
        many halfwords an instruction occupies, which in turn makes it
        impossible in a single pass to reliably determine the addresses
        or values of all symbols.&nbsp; The purpose of PASS 1 is to make
        a preliminary determination of all symbol addresses, using the
        assumption that all ambiguous instructions occupy a fullword.</li>
      <li>Optimization pass:&nbsp; This pass resolves the ambiguities in
        instruction sizes left behind by PASS 1.&nbsp; I.e., in some
        cases it can determines that an instruction tentatively assigned
        a fullword length in PASS 1 can be replaced by instead by a
        halfword instruction.&nbsp; This process does not necessarily
        catch all possible reductions; its intent is to behave
        identically to the original assembler rather than to produce
        optimally-small code.&nbsp; Since the algorithm used by the
        original assembler is unknown, there is no guarantee that the
        algorithm of the optimization pass is 100% correct.&nbsp; To a
        certain extent, the optimization pass also corrects affected
        symbol addresses as it makes these reductions; however, it
        should not be assumed that all symbols are correct after the
        pass, particularly some symbol values that are expressions
        containing symbols which themselves have been corrected.</li>
      <li>"PASS 2", "PASS 3", ...:&nbsp; These passes have the
        responsibilty of making the final determination of all symbol
        values.&nbsp; They are all identical algorithmically, and are
        iterated until no symbol value changes, though PASS 3 is always
        performed even if there are no symbol changes found in PASS
        2.&nbsp; For PASS 3 and beyond, AP-101 object code is generated,
        or <i>re</i>generated as the case may be.</li>
      <li>Print pass:&nbsp; This pass produces an assembly-listing and
        object-code file.&nbsp; It is implemented in ASM101S.py.</li>
    </ul>
    <p>Some relevant Python modules of interest:<br>
    </p>
    <ul>
      <li>fieldParser.py:&nbsp; As was already mentioned, contains BNF
        rules for parsing assembly-language operands.&nbsp; As was <i>not</i>
        mentioned, it also provides various functions for actually using
        those rules and performing the parsing.&nbsp; In particular:</li>
      <ul>
        <li><code>parserASM()</code>:&nbsp; Given an operand field as a
          string and the name of a BNF rule, parses the operand.&nbsp;
          See also <a moz-do-not-send="true"
            href="https://tatsu.readthedocs.io/en/stable/">the TatSu
            documentation</a>.<br>
        </li>
        <li><code>joinOperand()</code>:&nbsp; Joins operand fields that
          are split across continuation cards.<br>
        </li>
      </ul>
      <li>model101tables.py:&nbsp; As the name indicates, contains
        numerical tables used by model101.py during AP-101S code
        generation.</li>
      <li>expressions.py:&nbsp; Evaluates expressions.&nbsp; The
        principal functions provided are:</li>
      <ul>
        <li><code>error()</code>:&nbsp; Given a <code>source</code>
          entry and an error message, appends the error message to the
          list of error messages of the source-code line.&nbsp; (This
          function really has nothing to do with expressions <i>per se</i>,
          but it's ubiquitous throughout the assembler.)<br>
        </li>
        <li><code>evalArithmeticExpression()</code>:&nbsp; Evaluates
          arithmetic expressions involving symbols (either
          macro-language symbols or symbols like program labels in the
          symbol table) and arithmetical operations (like +, -, *,
          /).&nbsp; Can account for symbols that are in different CSECT
          or which are EXTRN.</li>
        <li><code>evalBooleanExpression()</code></li>
        <li><code>evalCharacterExpression()</code><br>
        </li>
      </ul>
      <li>asciiToEbcdic.py:&nbsp; Contains tables for converting ASCII
        to EBCDIC and vice-versa.<br>
      </li>
      <li>ibmHex.py:&nbsp; Convert Python numbers to/from IBM
        hexadecimal floating-point format.</li>
      <li>readListing.py:&nbsp; Reads a legacy assembly listing, for the
        purpose of extracting its assembled halfwords and allowing
        comparison to a new assembly from the same source code.<br>
      </li>
    </ul>
    <p> </p>
    <h1><a name="HLASM"></a>Afterthought:&nbsp; HLASM</h1>
    Belatedly, someone pointed out <a moz-do-not-send="true"
      href="https://share.confex.com/share/115/webprogram/Session7445.html">a
      presentation from 2010</a> called "Assembler Language as a Higher
    Level Language: Conditional Assembly and Macro Techniques" by John
    R. Ehrman of IBM as a possible resource for deciphering conundrums
    about gaps in the System/360 assembly-language manual vs
    AP-101S.&nbsp;&nbsp; Admittedly, John's presentation concerns the
    so-called "High Level Assembler for z/OS, z/VM, and z/VSE",
    apparently still being sold for IBM mainframes under the name
    "HLASM".&nbsp; Not being steeped in IBM lore myself, I can only make
    assumptions as to how how relevant HLASM may be to the AP-101S
    assembler.&nbsp; There's a <i>lot</i> of HLASM stuff that's
    definitely not available (or at least never used if it is available)
    in AP-101S source code, though it's unclear how much of it is flatly
    inconsistent with AP-101S.&nbsp; IBM itself provides <a
      moz-do-not-send="true"
      href="https://www.ibm.com/docs/en/SSLTBW_2.2.0/pdf/asmr1022.pdf">a
      manual for HLASM that's you can find online</a>.<br>
    <br>
    In brief, I'll say only that this presentation supports some
    reverse-engineering assertions I've made earlier on this page, while
    contradicting some facts about AP-101S code.&nbsp; Thus you may or
    may not find information from HLASM helpful.<br>
    <blockquote> </blockquote>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-11-29<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300"
              height="100"></a><br>
        </font></i></center>
    <br>
  </body>
</html>
