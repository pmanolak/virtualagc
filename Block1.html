<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Virtual AGC Assembly-Language Manual</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body style="background-image: url(gray3.jpg);">
    <h2>Contents</h2>
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","The Block I AGC").replace("@SUBTITLE@","in all its Aspects"))
</script>
    <ul>
      <li><a href="#Blocks_for_All_Occasions">Introduction</a></li>
      <li><a href="#Available_Documentation">Available Documentation</a></li>
      <li><a href="#Block_1_Computer_System">Block I Computer System</a></li>
      <ul>
        <li><a href="#Computer">Computer</a></li>
        <li><a href="#DSKY">DSKY</a></li>
        <li><a href="#Uplink">Uplink</a></li>
        <li><a href="#Downlink">Downlink</a><br>
        </li>
        <li><a href="#Other_Peripherals">Other Peripherals</a><br>
        </li>
      </ul>
      <li><a href="#Hardware_Architecture">Computer Hardware
          Architecture</a></li>
      <ul>
        <li><a href="#Memory_Map">Memory Map</a></li>
        <li><a href="#CPU_Architecture_Registers">Registers</a></li>
        <li><a href="#Overflow">15 Bits, 16 Bits, Parity, 1's-Complement
            and Overflow</a><br>
        </li>
        <li><a href="Block1.html#io_channels">I/O Channels</a></li>
        <li><a href="#Counters_and_Timers">Counters and Timers</a></li>
        <li><a href="#Interrupt_Processing">Interrupt Processing</a></li>
      </ul>
      <li><a href="#Software">Software</a><br>
      </li>
      <ul>
        <li><a href="#The_Interpreter_vs._the_CPU">The Interpreter vs.
            the CPU's Basic Instruction Set</a><br>
        </li>
        <li><a href="#Formatting">Source-Code Formatting Information</a></li>
        <li><a href="#Data_Representation">Data Representation</a></li>
        <li><a href="#Instruction_Representation">Basic Instruction
            Representation</a></li>
        <li><a href="#AGC4_Instruction_Set">Basic Instruction Set</a></li>
        <li><a href="#Pseudo-Operations">Pseudo-Operations</a></li>
        <li><a href="#Interpreter_Instruction_Set">Interpreter
            Instruction Set</a></li>
      </ul>
      <li><a href="#Available_Block_1_AGC_Software">Available Block I
          AGC Software</a></li>
      <li><a href="#Available_Supporting_Software">Available Supporting
          Software</a></li>
      <ul>
        <li><a href="#Virtual_AGCs_Assembler_yaYUL">Virtual AGC's
            Assembler (yaYUL)</a></li>
        <li><a href="#CPU_Simulators">CPU Simulators</a></li>
        <ul>
          <li><a href="#Comparison">Comparison</a><br>
          </li>
        </ul>
        <ul>
          <li><a href="#John_Pultoraks_Assembler_and_Simulator">John
              Pultorak's Assembler and Simulator</a><br>
          </li>
          <li><a href="#Virtual_AGCs_CPU_Simulator_yaAGCb1">Virtual
              AGC's CPU Simulator (yaAGCb1)</a></li>
          <li><a href="#Status_of_yaAGCb1">Status of yaAGCb1</a><br>
          </li>
        </ul>
        <li><a href="#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">Virtual
            AGC's DSKY Simulator (yaDSKYb1)</a></li>
        <li><a href="#yaUplinkBlock1">Virtual AGC's Digital Uplink
            Simulator (yaUplinkBlock1)</a><br>
        </li>
      </ul>
      <li><a href="#Taking_Solarium_for_a_Spin">Taking Solarium for a
          Spin</a></li>
    </ul>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Blocks_for_All_Occasions" id="Blocks_for_All_Occasions"></a>Introduction</h2>
    <p>The design of the AGC went through several stages, which for the
      sake of this discussion we'll call "blocks".&nbsp; However, the
      different block designs, while similar in many ways, were quite
      different in others.&nbsp; Rather than try to cover all of them on
      this one page, the different blocks are covered in separate pages:<br>
    </p>
    <ul>
      <li><a href="NARA-SW/E-1077.pdf">"Block 0"</a> — Earliest
        preliminary design of the AGC for which I have any
        documentation, not used in any missions, and with no known
        existing code.&nbsp; There's a single document (that I know of)
        describing it, so the link is simply to that document, rather
        than to a separate page.</li>
      <li>"Block I" — Used for the earlier designs of the Command
        Module, which were also referred to a Block I spacecraft.&nbsp;
        Used for the unmanned AS-202 ("Apollo 3"), Apollo 4 and Apollo 6
        unmanned missions, and <i>would</i> have been used for the
        Apollo 1 and Apollo 2 manned missions, if the Apollo 1 tragedy
        had not precluded those missions.&nbsp; No missions were ever
        flown with Block I LM AGCs.<br>
      </li>
      <li><a href="assembly_language_manual.html">"Block II"</a> — Used
        for the later designs of the Command Module, which were also
        referred to a Block II spacecraft.&nbsp; Used for the (unmanned)
        Apollo 5 mission's Lunar Module, and for all manned missions,
        both with an without Lunar Modules.</li>
      <li><a href="BlockIII.html">"Block 3"</a> — There was no such
        thing in the Apollo program, but Hugh Blair-Smith has given us
        some ideas about what it might have looked like if there were.</li>
    </ul>
    <p>However, <i>this</i> page confines itself just to the Block I
      design.<br>
    </p>
    <p>It would be very easy, I think, particularly if you only looked
      at it very superficially, to dismiss the Block I AGC as a computer
      that was merely a rebranded but otherwise almost-identical version
      of the Block II.&nbsp; But in fact, I think it would be fairer to
      say that in spite of family resemblances, these are
      quite-different machines for which somebody went to a lot of
      difficulty to make the development experiences seem very
      similar.&nbsp; Having dealt with both of them at some level of
      detail, I'll say that using what you know about the one with the
      other is a quick path to frustration.</p>
    <p>Here is a nice little 30-minute documentary in which the Block I
      AGC and DSKY are demonstrated and various interesting details of
      their internal construction and manufacture are discussed, by
      people such as Eldon Hall, Albert Hopkins, and Ramón Alonso, whose
      names you will see mentioned elsewhere on this page and this site:</p>
    <center><iframe src="https://www.youtube.com/embed/YIBhPsyYCiM"
        allowfullscreen="" height="480" frameborder="0" width="854">&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;lt;br&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;






      </iframe></center>
    <p><br>
    </p>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Available_Documentation" id="Available_Documentation"></a>Available






      Documentation<br>
    </h2>
    Descriptive material about the Block I AGC is not quite as abundant
    as for the Block II, but it has become distinctly less shabby over
    time.&nbsp; Here's what I think of as being the principal sources of
    information:<br>
    <ol>
      <li><a href="hrst/archive/1009.pdf">R-410:&nbsp; General Design
          Characteristics of the Apollo Guidance Computer</a>, by Eldon
        C. Hall, May 1963.</li>
      <li><a
          href="ElectroMechanical.html#Browse_the_Available_Engineering">Lots






          and lots of the official MIT/IL electrical-schematic and
          mechanical drawings</a>.&nbsp; I would be lying if I said our
        engineering-drawing collection is 100% complete, but we have a
        stunning level of detail on eight different models of the Block
        I AGC, assuming I haven't miscounted, and on a similar array of
        Block I DSKYs.&nbsp; If you could get the components that the
        engineering drawings use, you could build a working Block I AGC
        and DSKY from them. <br>
      </li>
      <li>AC Electronics document ND-1021041 (<a
          href="Documents/apollocommandmodacel.pdf">volume 1</a> and <a
          href="Documents/apollocommandmodacel_0.pdf">volume 2</a>).&nbsp;






        This is essentially a theory-of-operation document for the Block
        I AGC and DSKY, and indeed even contains its own set of
        electrical schematics which often seem to be slightly later
        revisions than the official MIT/IL drawings mentioned above.<br>
      </li>
      <li><a href="klabs/history/history_docs/r-393.pdf" title="Click to
          view document" target="_blank">R-393:&nbsp; Logical
          Description for the Apollo Guidance Computer (AGC 4)</a>, by
        Albert Hopkins, Ramon Alonso, and Hugh Blair-Smith, July 1966.</li>
      <li><a moz-do-not-send="true"
href="http://www.ibiblio.org/apollo/Documents/agcis_2_machine_instructions.pdf">FR-2-102A,


          "Apollo Guidance Computer Information Series, Issue 2: Machine
          Instructions"</a>, 03/10/1963, by Raytheon.</li>
      <li><a moz-do-not-send="true"
          href="http://www.ibiblio.org/apollo/Documents/agcis_6_interpreter.pdf">FR-2-106A,


          "Apollo Guidance Computer Information Series, Issue 6:
          Interpreter and Interpretive Instructions"</a>, 09/25/1963, by
        Raytheon.</li>
      <li><a moz-do-not-send="true"
          href="http://www.ibiblio.org/apollo/Documents/agcis_6b_interpreter.pdf">FR-2-106B,


          "Apollo Guidance Computer Information Series, Issue 6B:
          Interpreter and Interpretive Instructions"</a>, 05/29/1964, by
        Raytheon.</li>
      <li><a moz-do-not-send="true"
          href="http://www.ibiblio.org/apollo/links2.html#ProgrammerManuals">...


          and other of the Apollo Guidance Computer Information Series.</a><br>
      </li>
      <li><a href="hrst/archive/1721.pdf" title="Click to view document"
          target="_blank">R-467:&nbsp; The Compleat Sunrise being a
          description of Program Sunrise (Sunrise 33 - NASA DWG#
          1021102)</a>, by R. Battin, R. Crisp, A. Green, T. J. Lawton,
        C. A. Muntz, J. Rocchio, and E. Smally, September 1964.</li>
      <li><a href="Documents/E-1574.pdf">E-1574: Keyboard and Display
          System Program for AGC (Program SUNRISE), by Alan I. Green and
          Joseph J. Rocchio</a>, August 1964.<br>
      </li>
      <li>John Pultorak's <a
          href="Pultorak.html#AssemblerSimulatorSourceCode">Block I
          simulator source code</a>.</li>
      <li>Solarium 055 (Apollo 6 unmanned mission) <a
          href="ScansForConversion/Solarium055/0001-P1130108.jpg">
          assembly</a> listing, December 4, 1966.</li>
      <li>Personal communications by Hugh Blair-Smith.</li>
      <li>Hugh Blair-Smith's book, <i>Left Brains for the Right Stuff</i>,
        or as he refers to it, <i>LB4TRS</i>.</li>
    </ol>
    <p>Of these, MIT/IL document R-393 is the principle documentation of
      the Block I computer system — or at least it was prior to
      obtaining engineering drawings and ND-1021041 as mentioned above —
      but it is important to recognize that its descriptions are not
      entirely accurate.&nbsp; By this I mean not merely that it
      contains mistakes — as, indeed, any documentation of a
      sufficiently-complex system will — but that the design of the
      system was extended after document R-393 was written, so that some
      of the later-superceded information in it is blatantly wrong to
      the point of making anything based on it non-functional. The
      most-glaring discrepancy is the memory map, which R-393 describes
      as being 1024 words of read/write memory and 12 1024-word banks of
      read-only memory, whereas there were in fact 24 banks of read-only
      memory by the time of the Solarium (Apollo 6 unmanned mission)
      software mentioned above.&nbsp;&nbsp; In other words, Solarium
      wouldn't have fit into the amount of memory R-393 describes.&nbsp;
      <br>
    </p>
    <p>Finally, it's worth noting that people often seem to believe that
      the electrical schematics of the Block I AGC are contained in <a
        href="Pultorak.html#John_Pultoraks_Block_I_AGC">the original
        PDFs which John Pultorak published of his Block I AGC simulation</a>.&nbsp;
While






      those are fine schematics, and worked well for John's purposes,
      they are not transcriptions of the original Block I schematics,
      but are rather schematics John designed from scratch, based on the
      textual descriptions he found in R-393.&nbsp; In the first of his
      PDFs, there is a detailed diary of what he did, and everything in
      it refers back to R-393, but not to the original schematic
      diagrams of the Block I, which were not available to him.&nbsp;
      Thus, while John's work on reverse engineering the Block I AGC
      essentially from R-393 alone is a stunning <i>tour de force</i> —
      after all, his gadget ended up <i>working</i>! — his schematics
      may or may not be valuable resources for you, depending on your
      purposes.<br>
      <br>
    </p>
    <hr size="2">
    <h2><a name="Block_1_Computer_System" id="Block_1_Computer_System"></a>Block






      I Computer System</h2>
    <h3><a name="Computer" id="Computer"></a>Computer</h3>
    <p>The Block I AGC was provided in two different configurations, one
      for the Command Module (then referenced as the C/M), and one for
      the Lunar Module (at that time still called the LEM, or Lunar
      Excursion Module).&nbsp; Even though personally still bummed out
      (fifty years later) over the change from LEM to LM, for
      consistency I'll refer to the spacecraft here as the CM and LM and
      forego the temptation to instead talk about the LEM.<br>
    </p>
    <p>The physical configurations of these were different in terms of
      form factor, weight, and memory capacity — and of course, software
      — and here are the highlights:<br>
    </p>
    <ul>
      <li>CM Block I AGC:</li>
      <ul>
        <li><img alt="" src="block1-rope.jpg" height="100" align="right"
            width="308">about 2 cubic feet</li>
        <li>about 110 pounds</li>
        <li>24,576 words of "fixed" memory (i.e., read-only memory).</li>
        <li>Controls two <a href="#DSKY">DSKY</a>s, one for the main
          control panel, and one for the navigational bay.<br>
        </li>
      </ul>
      <li>LM Block I AGC:</li>
      <ul>
        <li>about 0.9 cubic feet</li>
        <li>about 50 pounds</li>
        <li>12,288 words of "fixed" memory (i.e., read-only memory).</li>
        <li>Controls one <a href="#DSKY">DSKY</a>.<br>
        </li>
      </ul>
      <li><img alt="" src="block1-erasable.jpg" height="150"
          align="right" width="243">Common:</li>
      <ul>
        <li>Power:&nbsp; 180 watts active, 10 watts idle.<br>
        </li>
        <li>Fixed memory comprised 16-bit "words", each consisting of 15
          bits available for data, and 1 parity bit, all consisting of
          cores, made of the magnetic alloy called Permalloy, and sewn
          together into a "rope".<br>
        </li>
        <li>1024 words of "erasable" memory (i.e., read-write memory),
          based on ferrite cores.</li>
        <li>1's-complement arithmetic, plus overflow.</li>
        <li>Memory cycle time (MCT): 11.7 μs.</li>
      </ul>
    </ul>
    <p>Of course, that's merely the summary.&nbsp; If you really wanted
      full details of what the Block I AGC was like, then you'd have to
      narrow your focus to just the specific mission you were interested
      in and consult the engineering drawings themselves.&nbsp; In fact,
      here are some links to those engineering drawings for the Block I
      (unmanned) missions flown:<br>
    </p>
    <ul>
      <li><a href="1003565-011.html">AS-202 ("Apollo 3") CM AGC</a><br>
      </li>
      <li><a href="1003700-051.html">Apollo 4 CM AGC</a> </li>
      <li><a href="1003700-071.html">Apollo 6 CM AGC</a><br>
      </li>
    </ul>
    <ul>
      <ul>
      </ul>
    </ul>
    <p>That's not to say that those were the <i>only</i> versions of
      the Block I AGC, and there were plenty more that never went on a
      flown mission!&nbsp; On the other hand, also not intended to imply
      that all of these models were <i>very</i> different.&nbsp; They
      were, after all, completely compatible in terms of the software
      they could run.<br>
    </p>
    <p>No Block I LM missions ever flown, and I'm not aware of any Block
      I LM software, so I can't comment on whether the LM Block I AGC
      requirements listed above are accurate.<br>
    </p>
    <table summary="" align="center" cellspacing="2" cellpadding="24">
      <tbody>
        <tr>
          <td valign="top"><a href="agc-block1-open.jpg"><img alt=""
                src="small-agc-block1-open.jpg" height="300" border="2"
                width="375"></a><br>
          </td>
          <td align="center" valign="top"><a
              href="agc-block1-closed.jpg"><img alt=""
                src="small-agc-block1-closed.jpg" height="300"
                border="2" width="375"></a><br>
          </td>
          <td align="center" valign="top"><a href="AGC-block1-LM.jpg"><img
                alt="" src="thm-AGC-block1-LM.jpg" height="300"
                border="2" width="331"></a><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    The first two pictures above depict the CM Block I AGC (which I've
    poorly reproduced from Eldon C. Hall's book, <span
      style="font-style: italic;">Journey to the Moon: The History of
      the Apollo Guidance Computer</span>, which you should buy), while
    the final one depicts the LM version (sorry there's no better
    picture), taken from document R-410, by ... wait for it ... Eldon C.
    Hall.<br>
    <br>
    Incidentally, a fellow named Francois Rautenbach has recently (at
    least, it was recent at the time I'm writing this) been engaged in
    extracting the contents of the core memory from the Block I AGC used
    for unmanned AS-202 mission, sometimes known as "Apollo 3".&nbsp; As
    a part of that effort, or vice-versa (I'm not sure which), he has
    also been making <a
      href="https://www.youtube.com/channel/UC1KeUTUd-fDv553C3UNr7xQ">a
      series of YouTube videos</a> in which there's a lot of info and
    there are nice visuals about the Block I AGC (and the Block II as
    well), beyond what the poor photographic reproductions above can
    reveal.&nbsp; Well worth viewing!<br>
    <h3><a name="DSKY" id="DSKY"></a>DSKY</h3>
    As in Block II, the DSKY was the display/keyboard unit with which an
    astronaut could have entered data into the computer and gotten
    feedback from it.&nbsp; Block I DSKYs differed from Block II DSKYs,
    and even from each other.&nbsp; Recall that the Command Module had
    two DSKYs (even though it had only one AGC), one on the main control
    panel and one on the navigation side-panel.&nbsp; The second DSKY
    was used for entering star or other landmark location
    sightings.&nbsp; In a Block II CM, the main and nav DSKYs are
    identical.&nbsp; In a Block I CM, on the other hand, the main and
    nav DSKYs were different.<br>
    <br>
    <div style="text-align: center;"> <a href="DSKY-BlockI-NASM.jpg"><img
          alt="Block 1 DSKY, nav bay" src="DSKY-BlockI-NASM-small.jpg"
          height="400" border="2" width="141"></a>&nbsp;&nbsp;&nbsp; <a
        href="Block1ControlPanelDSKY.jpg"><img alt=""
          src="small-Block1ControlPanelDSKY.jpg" height="400" border="2"
          width="398"></a><br>
    </div>
    <br>
    <img alt="" src="EldonHallWithBlock1DSKY.jpg" height="300"
      align="right" width="201">The left-hand picture above is a nav-bay
    DSKY.&nbsp; On the right is a photo of a main control-panel DSKY<a
      href="http://www.rrauction.com"></a>.<br>
    <br>
    And just how big were they?&nbsp; Well, in the picture to the right,
    you see Eldon Hall standing next to one of the control-panel DSKYs,
    so the answer is, <i>they were very, very big</i>!&nbsp; A nav-bay
    DSKY has the same push-button sizes as the control-panel DSKY and
    would have reached nearly to Eldon's shoulder, if sitting on the
    same table.<br>
    <br>
    We have many of the engineering drawings as well, so you could
    certainly consult those if you were a connoisseur or glutton for
    technical detail:<br>
    <ul>
      <li>AS-202 ("Apollo 3") CM:</li>
      <ul>
        <li><a href="1003564-021.html">Main DSKY</a></li>
        <li><a href="1003570-011.html">Nav DSKY</a></li>
      </ul>
      <li>Apollo 4 and Apollo 6<br>
      </li>
      <ul>
        <li><a href="1003563-051.html">Main DSKY</a></li>
        <li>Nav DSKY ... we don't actually have the specific top-level
          drawing for this one, but here's <a href="1003706-031.html">the



            closest match</a> in our drawing collection.<br>
        </li>
      </ul>
    </ul>
    Below are some drawings from a set of <a
      href="Documents/ApolloTrainingGuidanceAndNavigation_07-65.pdf">
      Apollo Guidance and Navigation System training slides</a>, which
    are perhaps of greater value if your interest is casual.&nbsp; If
    you click the drawing of the nav-panel DSKY (on the left), you can
    get a larger view in which the text is actually legible.<br>
    <br>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="text-align: center;"><a
              href="Block1DSKY-drawing2.png"><img alt=""
                src="Block1DSKY-drawing2-small.png" style="border: 2px
                solid ; width: 237px; height: 839px;" height="839"
                border="0" width="237"></a></td>
          <td style="text-align: center;"><img style="width: 587px;
              height: 572px;" alt="" src="Block1DSKY-drawing.png"
              height="572" width="587"><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    From our (or perhaps my) standpoint, the most-important
    characteristic of the DSKY is that it is a very dumb device, in the
    sense that it is close to being just a set of lights and
    push-buttons connected directly to electrical outputs and input of
    the AGC.&nbsp; This is not <i>entirely</i> true, since there would
    simply be too many such signals if each were provided with it's own
    dedicated wire, so some of the signals are multiplexed together,
    latched into internal relays provided by the DSKY.<br>
    <br>
    Outputs from the DSKY to the AGC are the states of the pushbuttons
    on the keypad.&nbsp; These simply directly control 6 bits on the
    CPU's <tt>IN0</tt> register.&nbsp; Refer to bits <tt>B1-B6</tt> of
    the <tt>IN0</tt> register in the <a href="#io_channels">"I/O
      Channels" section below</a>.<br>
    <br>
    Outputs from the AGC's <tt>OUT0</tt> and <tt>OUT1</tt> registers
    control the DSKY's indicator lamps, octal/decimal displays, and the
    special "flashing" feature which can cause the illumination of the
    VERB and NOUN labels to flash on and off.&nbsp; The octal/decimal
    (7-segment displays plus signs) are controlled by the multiplexing
    feature mentioned earlier.&nbsp; Each 15-bit word placed into the <tt>OUT0</tt>
    register consists of 4 bits (a "relay word") that specify a
    particular set of 11 relays in the DSKY, while the other 11 bits
    specify the data that's supposed to be latched into those
    relays.&nbsp; In theory, up to 16*11=176 separate relays could be
    present, and thus 176 signals could be multiplexed by this scheme;
    in reality, only 11 of the possible 16-bit relay words are used, and
    not all of <i>their</i> bits are used, so only 113 of the possible
    176 bits are actually used.<br>
    <br>
    Uncertainties:<br>
    <ul>
      <li>Solarium 055 also seems to use the relay word 014, which isn't
        known to correspond to anything in this scheme.<br>
      </li>
    </ul>
    <h3><a name="Uplink" id="Uplink"></a>Uplink</h3>
    <p>The digital uplink was simply a way to have a remote keypad on
      the ground, which could transmit keystrokes via radio to the AGC
      aboard the spacecraft as if it were a DSKY.&nbsp; In other words,
      the only data the uplink could transmit corresponded to DSKY
      keypad codes.&nbsp; The keycodes were identical to the 5-bit DSKY
      keycodes as described in the preceding section, but if (say) a
      5-bit keycode of bits <tt>B5 B4 B3 B2 B1</tt> were to be
      transmitted, they were supposed to be packaged into the following
      16-bit format for the uplink:<br>
    </p>
    <blockquote>
      <p><tt>1 B5 B4 B3 B2 B1</tt> <tt><span style="text-decoration:
            overline;">B5 B4 B3 B2 B1</span></tt> <tt>B5 B4 B3 B2 B1<br>
        </tt></p>
    </blockquote>
    where the overbar implies the logical-complement of the bits: 0 is
    replaced by 1 and vice-versa.&nbsp; The uplink was, of course,
    serial: the leading 1 was transmitted first, and the
    least-significant <tt>B1</tt> last.&nbsp; As each bit was received,
    it was shifted into the least-significant bit of the CPU's <tt>UPLINK</tt>
    register at address 041, which was initially all zero, and the other
    bits in the register were shifted upward by one position.&nbsp; When
    bit 16 of the register eventually became 1, an <tt>UPRUPT</tt>
    interrupt was triggered, and the AGC's <tt>UPRUPT</tt>
    interrupt-service routine could read the register, zero it, and
    process the data it had received.&nbsp; Of course, the way the data
    was packaged within the transmitted word, it was triply redundant
    and could thus be checked for corruption and discarded if it was
    found to be corrupted.&nbsp;<br>
    <br>
    After the uplink was detected, the UPTL activity lamp on the DSKY
    illuminated to inform the astronauts that an uplink was in progress,
    and it remained illuminated in most cases until the uplink sent a
    KEY RLSE keycode to "release" the uplinked keypad.<br>
    <br>
    There was a toggle switch on the DSKY that could be used either to
    allow uplinked data, or else to block it and allow the spacecraft
    and/or astronauts to retain complete control of the keypad
    input.&nbsp; If the uplink was allowed, then the uplinked keycodes
    were treated indistinguishably (at least superficially) to keypad
    input, and the results of the input could be seen on the DSKY.&nbsp;
    For example, an uplinked V36E would be seen visibly on the DSKY as
    the VERB area first blanking out, then a 3 appearing, a 6 appearing,
    and finally, a fresh start being performed, since "fresh start" is
    the purpose of a V36E.&nbsp; Naturally, the DSKY could not be seen
    physically on the ground, and the digital-uplink itself did not
    provide any feedback to the ground as to the effect the remote
    keystrokes were having aboard the spacecraft.&nbsp; That feedback,
    among other things, was the responsibility of the digital downlink
    as covered in the next section.<br>
    <h3><a name="Downlink" id="Downlink"></a>Downlink</h3>
    <p>TBD<br>
    </p>
    <h3><a name="Other_Peripherals" id="Other_Peripherals"></a>Other
      Peripherals</h3>
    <p>What the MIT Instrumentation Laboratory designed and provided for
      the Block I Command Module included not merely the AGC and its
      DSKYs, but rather than entire Guidance &amp; Navigation (G&amp;N)
      systems for the Command Module.&nbsp; The G&amp;N system consisted
      of quite a few additional components, of which some of the more
      important were:<br>
    </p>
    <ul>
      <li>The Inertial Measurement Unit (IMU)</li>
      <li> The Scanning Telescope (SCT)</li>
      <li>The Sextant (SXT)</li>
      <li>The Coupling Display Units (CDU)</li>
      <li>etc.</li>
    </ul>
    <p>In some sense, the IMU is the most important of all, more so than
      the AGC and DSKY, since (I believe) the IMU was what Doc Draper
      originally developed and attempted to hawk to the military, and
      was the Instrumentation Lab's entrée into Apollo in the first
      place.&nbsp; The IMU existed long before the AGC was even a gleam
      any any designer's eye.&nbsp; The AGC and DSKY, from that point of
      view, were just a way of interacting with the IMU, and without the
      IMU there really wasn't much of an excuse for MIT/IL to be
      involved in Apollo at all.&nbsp; But since our focus here is
      really just the AGC and DSKY, I won't really be covering these
      other very-important "peripheral" components at all. <br>
    </p>
    <p>Nevertheless, if you want to know about them we do still have
      quite a collection of <a href="links2.html#Block1">documents</a>
      and engineering drawings covering the entire G&amp;N system.&nbsp;
      Here's a portal into electrical and mechanical engineering
      drawings for the flown versions of the Block I G&amp;N system:<br>
    </p>
    <ul>
      <li><a href="1014999-051.html">AS-202 ("Apollo 3") G&amp;N system</a></li>
      <li><a href="1014999-111.html">Apollo 4 G&amp;N system</a></li>
      <li><a href="1014999-121.html">Apollo 6 G&amp;N system</a><br>
      </li>
    </ul>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Hardware_Architecture" id="Hardware_Architecture"></a>Computer
Hardware






      Architecture</h2>
    <h3><a name="Memory_Map" id="Memory_Map"></a>Memory Map<br>
    </h3>
    The Block I AGC memory map is far simpler than that of the Block II
    AGC.<br>
    <br>
    Memory is divided into 02000 (octal) mostly 15-bit words of
    "erasable" memory — i.e., memory which can both be read from and
    written to — and 24 banks, each with 02000 words, of read-only or
    "fixed" memory.<br>
    <br>
    Conventionally, AGC programming uses octal notation, as opposed to
    decimal or hexadecimal notation, for most purposes, and I'll do that
    below, but I'll try to remember to prefix an extra 0 to the front of
    an octal number to make it easy to recognize as being octal.&nbsp;
    For example, if you see 15, you'll know that it's 15 decimal because
    there's no leading zero, whereas of you see 015, you'll know that
    it's octal (=13 decimal).&nbsp; That's only a convention on this
    page; in program listings or conversations with AGC developers
    (assuming you find yourself in a position to engage in such an
    activity), expect to see everything in octal with no leading zeroes,
    and don't expect anybody to mention hexadecimal, and only
    occasionally to encounter decimal numbers.<br>
    <br>
    Memory is laid out as follows:<br>
    <ul>
      <li>Addresses 00000-01777 — erasable memory.</li>
      <li>Addresses 02000-03777 (or theoretically, 01,06000-01,07777) —
        Bank 1 of fixed memory.</li>
      <li>Addresses 04000-05777 (or theoretically, 02,06000-02,07777) —
        Bank 2 of fixed memory.</li>
      <li>Addresses 03,06000-03,07777 — Bank 3 of fixed memory.</li>
      <li>...</li>
      <li>Addresses 14,06000-14,07777 — Bank 14 of fixed memory.</li>
      <li><i>Though logically present as far as software is concerned,
          banks 15, 16, 17, and 20 are not physically present in the
          hardware.</i><br>
      </li>
      <li>Addresses 21,06000-21,07777 —Bank 20 of fixed memory.</li>
      <li>...<br>
      </li>
      <li>Addresses 034,06000-034,07777 — Bank 34 of fixed memory.<br>
      </li>
    </ul>
    Thus, fixed memory locations can always be referred to as<br>
    <blockquote> <i>BB,AAAA</i><br>
    </blockquote>
    where <i>BB</i> is an octal bank number from 01 to 034, and AAAA is
    an octal offset into that bank from 06000 to 07777.&nbsp; Only banks
    01 and 02 have the special short addresses 02000 through 05777, and
    they are invariably referred to in that way rather than in the <i>BB,AAAA</i>
    form.<br>
    <br>
    Various erasable-memory locations in the address range 0-057 have
    special purposes, such as being dedicated CPU registers,
    input/output ports, or counters (such as system timers).<br>
    <h3><a name="Overflow" id="Overflow"></a>15 Bits, 16 Bits, Parity,
      1's-Complement, and Overflow</h3>
    <p>The information in this section should not differ from equivalent
      information for Block II, so if you are confident you understand
      that, then there's no reason to read it.&nbsp; However, it is not
      merely cut-and-pasted from corresponding Block II descriptive
      material, and so may (or may not) be useful in itself.<br>
    </p>
    <p>Almost all AGC memory words consist of 16 bits, of which 15 bits
      is "data", and a 16th bit is a parity bit that the AGC hardware
      can access for the purpose of testing for corruption.&nbsp; If you
      were to build an AGC or to create a hardware simulation of an AGC,
      that parity bit would be an important thing to understand and
      account for, since parity violations are detectable by hardware,
      cause alarm indicators to trigger, and so on.<br>
    </p>
    <p>On the other hand, my own preoccupation in this site, in so far
      as Block I is concerned, is making Solarium and other Block I
      programs available within a software simulation of the AGC.&nbsp;
      Parity is completely irrelevant to that usage, because such an
      environment is not an embedded one, and parity is just a confusing
      distraction ... so I don't care about parity, my software
      simulation doesn't care about parity, and I won't mention parity
      again.&nbsp; As one of the original AGC developers commented to
      me, "parity schmarity", and I think that about sums it up.&nbsp;
      Consequently when I talk about AGC memory, it will almost always
      be in terms of <i>15</i>-bit words.<br>
    </p>
    <p>But there are some exceptions.&nbsp; Certain reserved memory
      locations, which aren't always (strictly speaking) contained in
      erasable memory even though addressed as such, consist of 16 bits,
      but&nbsp; the 16th bit is not parity; rather, it is an indication
      of "overflow".&nbsp; The principal example of such a privileged
      location is the "accumulator register", <tt>A</tt>, discussed in
      the next section.&nbsp; That's because all results of most kinds
      of arithmetical operations are deposited directly into the
      accumulator, and if an operation such addition has overflowed,
      that will first be manifested in the accumulator.&nbsp; Various
      subsequent operations on that data will behave differently
      depending on whether or not (or how) overflow is manifested within
      the accumulator.&nbsp; There are also hidden registers, not
      addressable by software, and overflow within those registers may
      have significant implications just like overflow in the
      accumulator does.<br>
    </p>
    <p>I have been chided for liking to think of "overflow" is if it
      were a condition that has occurred, such as "the accumulator has
      wrapped around from positive to negative" and thus overflowed, or
      "the accumulator has wrapped around from negative to
      positive".&nbsp; That's a poor way to think about overflow in this
      architecture, for a couple of reasons:<br>
    </p>
    <ol>
      <li>Arithmetical overflow <i>does not</i> "wrap around", in the
        sense of changing sign, because the AGC employs 1's-complement
        arithmetic rather than 2's-complement arithmetic.&nbsp;
        Wrap-around with sign-change is a characteristic of
        2's-complement arithmetic.&nbsp; However, with 1's complement,
        overflow does not work that way.&nbsp; If, say, you add 1 to the
        largest possible positive number, it will indeed wrap around,
        but it will wrap around to +0 and not to a negative value.</li>
      <li>Overflow is not an instantaneous condition that disappears,
        but rather is encoded within the 16-bit value, and continues to
        be manifested there until some operation occurs which converts
        the value back to a 15-bit one incapable of retaining the
        overflow information.</li>
    </ol>
    <p>Before getting to the exact encoding of overflow information,
      though, let's briefly talk about the 1's-complement representation
      of numbers.&nbsp; Consider a 15-bit number with bits <tt>B15 B14
        ... B1</tt>.&nbsp; This representation can store 2<sup>14</sup>-1=16383
distinct






      positive numbers (1 through 16383), and 2<sup>14</sup>-1=16383
      distinct negative numbers (-1 through -16383).&nbsp; Zero actually
      has two distinct representations, +0 and -0, which act the same
      for some purposes and <i>differently</i> for others.&nbsp; In
      other words, +0 and -0 are not completely interchangeable with
      each other.&nbsp; The positive numbers are encoded the same way
      they would be in 2's-complement:<br>
    </p>
    <blockquote>
      <p>0 (decimal) = 000 000 000 000 000 (binary)<br>
        1 (decimal) = 000 000 000 000 001 (binary)<br>
        2 (decimal) = 000 000 000 000 010 (binary)<br>
        3 (decimal) = 000 000 000 000 011 (binary)<br>
        4 (decimal) = 000 000 000 000 100 (binary)<br>
        ...<br>
        16383 (decimal) = 111 111 111 111 111 (binary)<br>
      </p>
    </blockquote>
    Negative numbers, in the other hand are not encoded the same way,
    but are simply the logical complements of the corresponding positive
    numbers.&nbsp; For example,<br>
    <blockquote> 12345 (decimal) = 011 000 000 111 001 (binary)<br>
    </blockquote>
    <p>so<br>
    </p>
    <blockquote> -12345 = <span style="text-decoration: overline;">011
        000 000 111 001</span> = 100 111 111 000 110<br>
    </blockquote>
    <p>Now, in 1's-complement there is no "sign bit" as such.&nbsp; In
      other words you can't turn (say) 3 into -3 or vice-versa by just
      flipping one bit.&nbsp; Nevertheless, in the examples above, the
      most-significant bit, bit 15, does indicate the sign, and
      therefore you can tell whether a number is positive or negative by
      testing bit 15.&nbsp; For that reason, bit 15 is sometimes called
      the "sign bit" and is sometimes designated by the special symbol<br>
    </p>
    <blockquote> <tt>SG</tt> = bit 15 = "sign bit"<br>
    </blockquote>
    <p>For those special 16-bit memory locations, like the accumulator,
      a regular, non-overflowed number will have its 16th bit identical
      to its 15th bit.&nbsp; It also has a special designation:<br>
    </p>
    <blockquote> <tt>UC</tt> = bit 16 = "uncorrected sign bit".<br>
    </blockquote>
    <p>In other words, for numbers without overflow, <tt>SG</tt> = <tt>UC</tt>
      (=0 if positive or =1 if negative).&nbsp; For numbers <i>with</i>
      overflow, though, this is not the case.&nbsp; There are two
      possibilities for numbers with overflow:<br>
    </p>
    <ul>
      <li>"Positive overflow":&nbsp; <tt>UC</tt> = 0 and <tt>SG</tt> =
        1.</li>
      <li>"Negative overflow": <tt>UC</tt> = 1 and <tt>SG</tt> = 0.</li>
    </ul>
    <p>The tricky aspect here is that when overflow exists, it is <tt>UC</tt>
      that is regarded as the "real" sign of the number, and not <tt>UC</tt>.&nbsp;
When






      the 16-bit form of a number (say, in the accumulator) needs to be
      converted to a normal 15-bit number (say, to be stored at a
      location in erasable memory), what happens is that the <tt>UC</tt>
      bit steps in and kicks the <tt>SG</tt> bit out of the way:<br>
    </p>
    <blockquote>
      <p><tt>UC SG B14 ... B1</tt> (16 bits)&nbsp; →&nbsp; <tt>UC B14
          ... B1</tt> (15 bits)<br>
      </p>
    </blockquote>
    <p>Let's consider an example of this in action.&nbsp; Imagine we
      want to increment the largest possible positive number, 037777, by
      1.&nbsp; Start by just using the same old binary arithmetic you're
      familiar with, without worrying about "1's-complement" vs
      "2's-complement" or overflow:<br>
    </p>
    <blockquote> 0 011 111 111 111 111 + 0 000 000 000 000 001&nbsp;
      →&nbsp; 0 100 000 000 000 000<br>
    </blockquote>
    <p>Having done that, though, we now have overflow, and specifically
      "positive overflow", since <tt>UC</tt> = 0 and <tt>SG</tt> = 1
      do not agree with each other.&nbsp; And if we were to save this as
      a 15-bit number, <tt>UC</tt> = 0 would shift down to overwrite
      the <tt>SG</tt> = 1, and we'd simply have 000 000 000 000 000, or
      just 0.<br>
    </p>
    <h3><a name="CPU_Architecture_Registers"
        id="CPU_Architecture_Registers"></a>Registers</h3>
    Incidentally, note that while I (and everybody else) refer to the
    registers I'm going to discuss by their names rather than their
    addresses, the assembler is in fact not aware of those names; they
    are not reserved words or predefined.&nbsp;&nbsp;&nbsp; Therefore, a
    program like Solarium will contain pseudo-ops that define these
    names as having the numerical values of the registers' addresses.<br>
    <br>
    There are 4 16-bit registers addressable directly by software and
    partaking of the 16-bit glory of overflow, <tt>UC</tt>, and <tt>SG</tt>
    discussed in the preceding section.<br>
    <ul>
      <li><tt>A</tt> (address 0000) — the "accumulator", at address 0 in
        erasable, though normally accessed by it's name, "A". This
        register is the primary source or destination for most
        operations, and in particular, is where the results of most
        arithmetical operations are deposited.</li>
      <li><tt>Q</tt> (address 0001) — primarily used to hold the return
        addresses for subroutines. It is automatically written to by the
        <tt>TC</tt> command when a jump is made to a different memory
        location. There is no hardware stack, so the subroutine has the
        responsibility of saving the contents of <tt>Q</tt> and
        restoring it before returning to the calling program, if
        appropriate.</li>
      <li><tt>Z</tt> (address 0002) — pointer to the <i>next</i>
        instruction to be executed in the normal flow (i.e., barring a
        jump instruction like <tt>TC</tt> or <tt>CCS</tt> or an
        interrupt) after the current instruction is completed. The <tt>Z</tt>
        register is already set up with this value by the
        previously-executed instruction, before the current program
        counter is reached. (Note, though, that when using the yaAGCb1
        CPU simulator program in their debugging mode, the value
        displayed is always for the <i>current</i> instruction rather
        than for the next one, since I find it more instructive that
        way.) Though the register is 16 bits, in theory, this pointer is
        just 12 bits (0000-7777), and the full address, if in banked
        memory, is formed by adding in the value stored in the <tt>Bank</tt>
        register.</li>
      <li><tt>LP</tt> (address 0003) — principally for holding results
        of <tt>MP</tt> or <tt>DV</tt> operations, but do <i>not</i>
        make the mistake of equating it with the Block II's L
        register.&nbsp; It's not very useful for much else (a point on
        which I'm open to correction) because it's an example of
        something called an "editing register", of which the other
        examples (described below) are <tt>CYR</tt>, <tt>SR</tt>, <tt>CYL</tt>,
        and <tt>SL</tt>.&nbsp; What that means is that when you try to
        store a value in this register, using an assembly-language
        instruction such as <tt>TS</tt>, it is not stored as-is, but is
        instead "edited" in a particular way.&nbsp; Furthermore, various
        assembly-language instructions which seemingly only read this
        register, will in fact rewrite the register, causing the editing
        operation to be re-performed in-place.&nbsp; There is a table
        (3-2) in R-393 that defines the various editing operations that
        are performed on this select cadre of registers, but it's
        perhaps a bit hard to figure out for the uninitiated.&nbsp; The
        specific editing operation performed by <tt>LP</tt> is as
        follows:&nbsp; If you try to write a set of bits like <tt>B15
          B14 B13 ... B2 B1 to LP</tt>, it will in fact be written as <tt>B1
0






          B14 B13 ... B1</tt>.&nbsp; Thus, the most-significant original
        bit <tt>B15</tt> is discarded, and then what's left over is
        shifted downward, wrapping the old least-significant bit into
        the new most-significant position.</li>
    </ul>
    <p>There's also a variety of 15-bit registers:<br>
    </p>
    <ul>
      <li><tt>Bank</tt> (address 015): When fixed memory having
        addresses of the form <tt>BB,OOOO</tt> (i.e., bank,offset),
        only the offset (<tt>OOOO</tt>) is supplied by the instruction
        operands.&nbsp; (Yes, those are all upper-case letters Oh and
        not zeroes.)&nbsp; The bank (<tt>BB</tt>) comes instead from the
        <tt>Bank</tt> register.&nbsp; Only bits <tt>B15 B14 B13 B12 B11</tt>
        of this register are used, and so all of the lower-order bits of
        the register are zero.&nbsp; Perhaps confusingly, when the
        contents of this register are discussed, they are usually
        discussed as if they were the same as <tt>BB</tt>: i.e., that
        the register contains values in the range 0-037; in reality, it
        contains that range of values, but shifted upward by 12 binary
        places.&nbsp; Consequently, there are tricks that have to be
        used to effectively store a bank number in the Bank register,
        and those tricks are discussed later when the instruction set is
        covered.</li>
      <li><tt>CYR</tt> (address 020), <tt>SR</tt> (address 021), <tt>CYL</tt>
        (address 022), <tt>SL</tt> (address 023):&nbsp; These are
        "editing registers", like <tt>LP</tt> as discussed earlier,
        which automatically modify values explicitly stored to them, or
        implicitly rewritten to them as side-effects of various
        instructions.&nbsp; Table 3-2 of R-393 covers the editing
        operation with is performed for each of these, but frankly it is
        very confusing.&nbsp; It is best to think of it as follows:</li>
      <ul>
        <li><tt>CYR</tt>:&nbsp; "Rotates" the value to the right.&nbsp;
          I.e., shifts the (15-bit) value downward by one bit position,
          and cycles the least-significant bit back upward into the
          most-significant position.<br>
        </li>
        <li><tt>SR</tt>:&nbsp; Shifts the 15-bit value downward,
          duplicating the most-significant bit.&nbsp; In other words, it
          is a signed divide-by-two operation.<br>
        </li>
        <li><tt>CYL</tt>:&nbsp; "Rotates" the value to the left.&nbsp;
          I.e., shifts the (15-bit) value upward&nbsp; by one bit
          position, and cycles the most-significant bit back
          downward&nbsp; into the least-significant position.</li>
        <li><tt>SL</tt>:&nbsp; Shifts the 15-bit value upward.&nbsp; In
          other words, it is a multiply-by-two.</li>
      </ul>
      <li><tt>QRUPT</tt> (address 027), <tt>ZRUPT</tt> (address 024), <tt>BRUPT</tt>
        (address 025):&nbsp; When an <a
          href="Block1.html#Interrupt_Processing">interrupt is processed</a>,
        the existing values of the <tt>Q</tt>, <tt>Z</tt>, and <tt>B</tt>
        registers are automatically copied into these registers.&nbsp; <tt>B</tt>
        is a hidden register, not addressable by software, and hence was
        not discussed with the registers already mentioned, however, it
        has the important role of holding the numerical value (as
        opposed to the address) of the next instruction to be executed
        after resumption from the interrupt-processing.<br>
      </li>
      <li><tt>ARUPT</tt> (address 026), <tt>BANKRUPT</tt> (address
        030), <tt>OVRUPT</tt> (address 031), <tt>LPRUPT</tt> (address
        032), <tt>DSRUPTSW</tt> (address 033):&nbsp; These registers
        are <i>available</i> for storing the values of other registers
        during <a href="#Interrupt_Processing">interrupt processing</a>.&nbsp;
However,






        that storage isn't done automatically, and (if desired) has to
        be done explicitly by the interrupt-service routine
        itself.&nbsp; In short, these are just regular erasable-memory
        locations like any other, that just happen to have names that
        hint at an appropriate use for them.<br>
      </li>
    </ul>
    You might suppose that since the various <tt>RUPT</tt> registers
    mentioned above are 15-bit, but the values which are supposed to be
    stored in them are 16-bit, that this could cause a problem.&nbsp; In
    fact, though interrupts are inhibited when <tt>A</tt> or <tt>B</tt>
    contain overflow, so they cannot cause a problem.&nbsp; As far as <tt>Q</tt>,
    <tt>Z</tt>, and <tt>LP</tt> are concerned, while they may
    theoretically have 16 bits, there is seldom any useful way to use
    the 16th bit, and for those cases one could use the <tt>INHINT</tt>
    instruction (discussed later) to inhibit interrupts during a short
    stretch of code where it might be a problem.<br>
    <br>
    In the list above, I've left out a number of registers related to
    i/o or used as timer/counters, and those are covered in the
    succeeding sections.<br>
    <h3><a name="io_channels" id="io_channels"></a>I/O Channels</h3>
    Unlike the Block II system, there is no separate i/o-channel
    address-space, and the i/o channels are simply memory mapped.&nbsp;
    Even so, we'll discuss them separately from the other registers.
    There are&nbsp; 4 15-bit input channels and 5 15-bit output
    channels. These are not all fully (or correctly) documented in the
    R-393 or "Compleat Sunrise" documents, and haven't yet been entirely
    vetted by me or my colleagues, so you have to take some of them with
    a grain of salt; that's particularly true when you see a terse
    description like "1600 pps" as opposed to a more drawn-out
    description with my signature verbosity.<br>
    <br>
    The least-significant bit of these registers is referred to below as
    B1, and the most-significant as B15:
    <ul>
      <li><tt>IN0</tt> (address 0004): This register is used principally
        to receive keyboard input from the DSKY, with the following bit
        assignments:</li>
      <ul>
        <li>B1-B5 contains a keycode, if a keypad key is pressed, as
          follows.&nbsp; Note that not all codes are used:</li>
        <ul>
          <li>00 (octal) for "no key pressed".</li>
          <li>20 (octal) for the digit 0.</li>
          <li>01-11 (octal) for the digits 0-9.</li>
          <li>21 for the VERB key.</li>
          <li>22 for the ERROR RESET key.</li>
          <li>31 for the KEY RLSE key.</li>
          <li>32 for the + key.</li>
          <li>33 for the - key.</li>
          <li>34 for the ENTER key.</li>
          <li>36 for the CLEAR key.</li>
          <li>37 for the NOUN key.</li>
        </ul>
        <li>B6 is set when any of the B1-B5 <i>or</i> B15 is active,
          and is what triggers a "KEYRUPT" (keypad interrupt).&nbsp; It
          is perhaps worth noting that the KEYRUPT <i>software</i>
          expects for the entire lower 6 bits, B6-B1 (and not just B6)
          to return to zero after the pushbutton is released, and will
          refuse to process additional keystrokes until this occurs.<br>
        </li>
        <li>B7-B13 are not used.</li>
        <li>B14 is active when the AGC can be put into
          partially-powered-down "standby mode", and is, I believe,
          connected to a control-panel switch that's not on the DSKY.</li>
        <li>B15 is active when the MARK key, not on the DSKY itself, is
          pressed, and activates B6 just like the DSKY-keypad keys do.
          It is used to cause the AGC to "mark" the current IMU data ...
          i.e., to snapshot it in memory.</li>
      </ul>
      <li><tt>IN1</tt> (address 0005):<br>
      </li>
      <ul>
        <li>B1: 1600 pps</li>
        <li>B2: 800 pps</li>
        <li>B3: 400 pps</li>
        <li>B4: 200 pps</li>
        <li>B5: OR C1, 2, 3, 4, 10 (IMU relay drivers)<br>
        </li>
        <li>B6: OR C5, 6, 7, 8, 9 (S/C alarm lights)</li>
        <li>B7: OR C11, 12 (OP relay drivers)</li>
        <li>B8-10: not used</li>
        <li>B11: PARITY alarm.&nbsp; Any of bits B11-B15 (i.e., their
          logical OR) generate an error interrupt (ERUPT).<br>
        </li>
        <li>B12: CROSSPOINT FAIL alarm</li>
        <li>B13: SR INACTIVE (GO) alarm</li>
        <li>B14: RUPTLOCK (GO) alarm</li>
        <li>B15: TCA Trap (GO) alarm<br>
        </li>
      </ul>
      <li><tt>IN2</tt> (address 0006):</li>
      <ul>
        <li>B1: OR CDU <span style="text-decoration: overline;">Zero</span></li>
      </ul>
      <ul>
        <li>B2: OR SXT <span style="text-decoration: overline;">Zero</span></li>
        <li>B3: OR TRACKER <span style="text-decoration: overline;">Zero</span></li>
        <li>B4: Photocell -</li>
        <li>B5: Photocell +</li>
        <li>B6-7: Not used</li>
        <li>B8: Tracker Fail (RUPT)</li>
        <li>B9: OPTICS Fail (RUPT2)</li>
        <li>B10: CDU Fail (RUPT2)</li>
        <li>B11: ACCEL Fail (RUPT2)</li>
        <li>B12: IMU Fail (RUPT2)</li>
        <li>B13: ABORT (RUPT2)</li>
        <li>B14: BAD BOOST (RUPT2)</li>
        <li>B15: AGC Power Fail (RUPT2)</li>
      </ul>
      <li><tt>IN3</tt> (address 0007):<br>
      </li>
      <ul>
        <li>B1: K1 Zero CDU SW</li>
        <li>B2: K2</li>
        <li>B3: K3</li>
        <li>B4: K4</li>
        <li>B5: ATTSW</li>
        <li>B6: TRNSW</li>
        <li>B7: ZERO OPT</li>
        <li>B8: MODE SELECT OPT</li>
        <li>B9: MODE SELECT OPT</li>
        <li>B10: MODE SELECT OPT</li>
        <li>B11-12: Not used.</li>
        <li>B13: MODE SELECT S/C</li>
        <li>B14: MODE SELECT S/C</li>
        <li>B15: Lift-off<br>
        </li>
      </ul>
      <li><tt>OUT0</tt> (address 0010):&nbsp; These are outputs from the
        AGC to the DSKY.&nbsp; Each 15-bit word is of the following
        format, as a bit-pattern (with the B15 to the left and B1 to the
        right):&nbsp; <tt>WWWWSAAAAABBBBB</tt>.&nbsp; The field <tt>WWWW</tt>
        specifies one out potentially 16 distinct sets of 11 relays in
        the DSKY, and the fields <tt>SAAAAABBBBB</tt> are latched into
        those sets of relays when this value appears.&nbsp; The behavior
        of these patterns is quite simple, but is too complex to fix
        into this one bullet point, so I will describe the behavior of <tt>OUT0</tt>
        in more detail at the end of this bullet list below.<br>
      </li>
      <li><tt>OUT1</tt> (address 0011).&nbsp; Note that the bits of this
        register do not, in fact conform entirely to any of the
        available written documents.<br>
      </li>
      <ul>
        <li>B1:&nbsp; PROG alarm on LM DSKY<br>
        </li>
        <li>B2:&nbsp; COMP FAIL and alarm on DSKY<br>
        </li>
        <li>B3:&nbsp; KEY RLSE indicator on LM DSKY<br>
        </li>
        <li>B4:&nbsp; SCALER FAIL or TM FAIL (not sure which) alarm on
          LM DSKY<br>
        </li>
        <li>B5:&nbsp; CHECK FAIL alarm on DSKY<br>
        </li>
        <li>B6:&nbsp; Block UPLINK<br>
        </li>
        <li>B7:&nbsp; ERRUPT trap<br>
        </li>
        <li>B8:&nbsp; Slow speed, STANDBY<br>
        </li>
        <li>B9:&nbsp; Word Order Telem<br>
        </li>
        <li>B10:&nbsp; Block Endpulse<br>
        </li>
        <li>B11:&nbsp; PIPA SCALE FINE<br>
        </li>
        <li>B12:&nbsp; PIPA SCALE EMERG<br>
        </li>
        <li>B13:&nbsp; ENG START<br>
        </li>
        <li>B14:&nbsp; START CLOCK<br>
        </li>
        <li>B15:&nbsp; ENG OUT-OFF<br>
        </li>
      </ul>
      <li><tt>OUT2</tt> (address 0012):&nbsp; This output-register is
        dedicated to generating pulses for driving peripherals such as
        the CDUs, and the various bit-fields are described in some
        detail in the "METHOD FOR GENERATING OUTPUT RATES" section in
        R-393.</li>
      <ul>
        <li>B1:&nbsp; OPT X<br>
        </li>
        <li>B2:&nbsp; OPT Y<br>
        </li>
        <li>B3:&nbsp; THRUST (RATE II)<br>
        </li>
        <li>B4:&nbsp; +<br>
        </li>
        <li>B5:&nbsp; -<br>
        </li>
        <li>B6-7:&nbsp; Not used<br>
        </li>
        <li>B8:&nbsp; GYR X<br>
        </li>
        <li>B9:&nbsp; GYR Y<br>
        </li>
        <li>B10:&nbsp; GYR Z<br>
        </li>
        <li>B11:&nbsp; CDU X (RATE I)<br>
        </li>
        <li>B12:&nbsp; CDU Y<br>
        </li>
        <li>B13:&nbsp; CDU Z<br>
        </li>
        <li>B14:&nbsp; +<br>
        </li>
        <li>B15:&nbsp; -</li>
      </ul>
      <li><tt>OUT3</tt> (address 0013):&nbsp; Not used.<br>
      </li>
      <li><tt>OUT4</tt> (address 0014):&nbsp; This is a 16-it register,
        in which a word to be DOWNLINK'd is placed.&nbsp; The 16th bit
        is the parity.<br>
      </li>
    </ul>
    To understand the various fields (<tt>WWWW</tt>, <tt>S</tt>, <tt>AAAAA</tt>,
    <tt>BBBBB</tt>) used in the <tt>OUT0</tt> word, you have to be able
    to relate them to the various sets of 7-segment displays and +/-
    sign displays on the DSKY.&nbsp; Examine the following diagram,
    which is a stylized representation of the area on the DSKY
    containing the numerical displays:<br>
    <blockquote> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;









        <i>PROGRAM</i><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[MD1]









        [MD2]<br>
        <br>
        &nbsp;&nbsp;&nbsp; <i>VERB</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;









        <i>NOUN</i><br>
        [VD1]
        [VD2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[ND1]






        [ND2]<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
        &nbsp;&nbsp;&nbsp; <i>R</i><i>EGISTER 1</i><br>
        [R1S] [R1D1] [R1D2] [R1D3] [R1D4] [R1D5]<br>
      </tt> <tt><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
        &nbsp;&nbsp; <i>R</i><i>EGISTER 2</i><br>
        [R2S] [R2D1] [R2D2] [R2D3] [R2D4] [R2D5]<br>
      </tt> <tt><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
        &nbsp;&nbsp; <i>R</i><i>EGISTER 3</i><br>
        [R3S] [R3D1] [R3D2] [R3D3] [R3D4] [R3D5]<br>
      </tt> </blockquote>
    Thus, each one of the designations in [brackets] represents a
    displayed digit or else a +/- sign.&nbsp; For example, [VD1] is the
    left digit of the "verb".&nbsp; The value of each of signs is
    determined by a particular combination of <tt>WWWW</tt> and <tt>S</tt>
    fields, while each of the digits is determined by a particular
    combination of <tt>WWWW</tt> and <tt>AAAAA</tt> or <tt>BBBBB</tt>
    fields.&nbsp; The specific mapping used is:<br>
    <br>
    <div align="center">
      <table summary="" cellspacing="2" cellpadding="2" border="1">
        <tbody>
          <tr>
            <th align="center" valign="middle"> <tt>WWWW</tt><tt><br>
              </tt></th>
            <th align="center" valign="middle"> <tt>S</tt><tt><br>
              </tt></th>
            <th align="center" valign="middle"> <tt>AAAAA</tt><tt><br>
              </tt></th>
            <th align="center" valign="middle"> <tt>BBBBB</tt><tt><br>
              </tt></th>
          </tr>
          <tr>
            <td valign="top">017<br>
            </td>
            <td colspan="3" rowspan="1" align="center" valign="top"> <i>(cannot






                occur)</i><br>
            </td>
          </tr>
          <tr>
            <td valign="top">016<br>
            </td>
            <td colspan="3" rowspan="1" align="center" valign="top"> <i>(see






                below)</i></td>
          </tr>
          <tr>
            <td valign="top">015<br>
            </td>
            <td colspan="3" rowspan="1" align="center" valign="top"> <i>(see






                below)</i></td>
          </tr>
          <tr>
            <td align="center" valign="top">014<br>
            </td>
            <td colspan="3" rowspan="1" align="center" valign="top"> <i>(see






                below)</i><br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">013<br>
            </td>
            <td align="center" valign="middle">n/a<br>
            </td>
            <td align="center" valign="middle">MD1<br>
            </td>
            <td align="center" valign="middle">MD2<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">012<br>
            </td>
            <td align="center" valign="middle">FLASH<br>
            </td>
            <td align="center" valign="middle">VD1<br>
            </td>
            <td align="center" valign="middle">VD2<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">011<br>
            </td>
            <td align="center" valign="middle">n/a<br>
            </td>
            <td align="center" valign="middle">ND1<br>
            </td>
            <td align="center" valign="middle">ND2<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">010<br>
            </td>
            <td align="center" valign="middle">UPACT<br>
            </td>
            <td align="center" valign="middle">n/a<br>
            </td>
            <td align="center" valign="middle">R1D1<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">007<br>
            </td>
            <td align="center" valign="middle">R1S +<br>
            </td>
            <td align="center" valign="middle">R1D2<br>
            </td>
            <td align="center" valign="middle">R1D3<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">006<br>
            </td>
            <td align="center" valign="middle">R1S -<br>
            </td>
            <td align="center" valign="middle">R1D4<br>
            </td>
            <td align="center" valign="middle">R1D5<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">005<br>
            </td>
            <td align="center" valign="middle">R2S +<br>
            </td>
            <td align="center" valign="middle">R2D1<br>
            </td>
            <td align="center" valign="middle">R2D2<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">004<br>
            </td>
            <td align="center" valign="middle">R2S -<br>
            </td>
            <td align="center" valign="middle">R2D3<br>
            </td>
            <td align="center" valign="middle">R2D4<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">003<br>
            </td>
            <td align="center" valign="middle">n/a<br>
            </td>
            <td align="center" valign="middle">R2D5<br>
            </td>
            <td align="center" valign="middle">R3D1<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">002<br>
            </td>
            <td align="center" valign="middle">R3S +<br>
            </td>
            <td align="center" valign="middle">R3D2<br>
            </td>
            <td align="center" valign="middle">R3D3<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">001<br>
            </td>
            <td align="center" valign="middle">R3S -<br>
            </td>
            <td align="center" valign="middle">R3D4<br>
            </td>
            <td align="center" valign="middle">R3D5<br>
            </td>
          </tr>
          <tr>
            <td valign="top">000<br>
            </td>
            <td colspan="3" valign="top"><i>(normal, inactive state)</i><br>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <br>
    <br>
    As you can see, a couple of the <tt>S</tt> fields don't actually
    correspond to +/- signs at all.&nbsp; FLASH refers to the ability of
    the DSKY to flash the words "VERB" (appearing above VD1 and VD2) and
    "NOUN" (appearing above ND1 and ND2) about once per second; this
    feature is active after FLASH is set to 1, and deactivated (with the
    words remaining lit) after FLASH is set to 0.&nbsp; The UPACT bit
    refers to the UPTL activity lamp on the DSKY, and turns that lamp on
    or off.<br>
    <br>
    However, the principal purpose of <tt>OUT0</tt> is to control the
    digits and +/- signs displayed on the DSKY.&nbsp; As an example, the
    R1S sign is displayed as "+" when R1S+ is 1 and R1S- is 0, while the
    R1S sign is displayed as "-" when R1S+ is 0 and R1S- is 1.&nbsp; It
    is blank when both R1S- and R1S+ are 0.&nbsp; (I'm not sure what
    it's supposed to display if both are 1.)<br>
    <br>
    The <tt>AAAAA</tt> and <tt>BBBBB</tt> fields control what digits
    are displayed in R<i>n</i>D<i>m</i>, but not in the straightforward
    fashion of 0=0, 1=1, etc.&nbsp; Rather,<br>
    <br>
    <div align="center">
      <table summary="" cellspacing="2" cellpadding="2" border="1">
        <tbody>
          <tr>
            <th valign="middle"><tt>AAAAA</tt> <i>or</i> <tt>BBBBB</tt><br>
            </th>
            <th valign="middle">Displays<br>
            </th>
          </tr>
          <tr>
            <td align="center" valign="middle">000<br>
            </td>
            <td align="center" valign="middle">blank<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">025<br>
            </td>
            <td align="center" valign="middle">0<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">003<br>
            </td>
            <td align="center" valign="middle">1<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">031<br>
            </td>
            <td align="center" valign="middle">2<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">033<br>
            </td>
            <td align="center" valign="middle">3<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">027<br>
            </td>
            <td align="center" valign="middle">4<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">036<br>
            </td>
            <td align="center" valign="middle">5<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">034<br>
            </td>
            <td align="center" valign="middle">6<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">023<br>
            </td>
            <td align="center" valign="middle">7<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">035<br>
            </td>
            <td align="center" valign="middle">8<br>
            </td>
          </tr>
          <tr>
            <td align="center" valign="middle">037<br>
            </td>
            <td align="center" valign="middle">9<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
    </div>
    <br>
    So finally, as an example, suppose the value 027576 (<tt>WWWW</tt>=05,






    <tt>S</tt>=1, <tt>AAAAA</tt>=033, <tt>BBBBB</tt>=036) is written
    to <tt>OUT0</tt>.&nbsp; Then in REGISTER 2, the leftmost three
    positions would display "+35".&nbsp; Since this is latched in the
    DSKY, those positions continue to display that way until a new word
    with <tt>WWWW</tt>=05 is written to <tt>OUT0</tt> and are
    unaffected to writes to <tt>OUT0</tt> with different values of <tt>WWWW</tt>.<br>
    <br>
    Regarding the various combinations of <tt>WWWW</tt> not covered
    above:<br>
    <ul>
      <li><tt>WWWW</tt>=000:&nbsp; 0 is the normal state of the OUT0
        register when no new DSKY activity is currently being commanded,
        and the register is returned to this state by <a
          href="#Interrupt_Processing">T4RUPT</a> every few tens of
        milliseconds.</li>
      <li><tt>WWWW</tt>=014:&nbsp; In Solarium, this relay-word is
        created by the CDRVE function, which program comments indicate
        as pertaining to "SPACECRAFT RELAYS".&nbsp; TBD.</li>
      <li><tt>WWWW</tt>=015:&nbsp; In Solarium, this relay-word is
        created by the CDRVE1 function, which program comments indicate
        as pertaining to "IMU AND CAUTION LIGHTS".&nbsp; TBD.</li>
      <li><tt>WWWW</tt>=016:&nbsp; In Solarium, this relay-word is
        created by the CDRVE2 function, which program comments indicate
        as pertaining to "OPTICS".&nbsp; TBD.&nbsp;</li>
      <li><tt>WWWW</tt>=017:&nbsp; 017, while a theoretically-possible
        value for the register, cannot be created by the AGC software
        (at least not in Solarium).&nbsp;</li>
    </ul>
    <h3><a name="Counters_and_Timers" id="Counters_and_Timers"></a>Counters
and






      Timers</h3>
    <p>Counter/timer registers are registers in erasable memory which
      are automatically incremented or decremented by specific actions
      of the hardware, independent of the operation of the
      software.&nbsp; Thus, the software may (in some cases) usefully
      load an initial value into them, but for the most part just polls
      the contents of these registers when it needs to do so.&nbsp; In
      some cases too, an overflow of one of these registers may <a
        href="#Interrupt_Processing">trigger an interrupt</a>.<br>
    </p>
    <ul>
      <li><tt>OVCTR</tt> (address 034):&nbsp; This counter is
        incremented every time an addition or subtraction operation
        (i.e., <tt>AD</tt> or <tt>SU</tt>) creates <a
          href="#Overflow">positive overflow in the accumulator register</a>.&nbsp;
Conversely,






        it is decremented every time an addition or subtraction creates
        a negative overflow.&nbsp; However, just the existence of
        overflow outside of that context has no effect.<br>
      </li>
      <li><tt>TIME2</tt> (address 035):&nbsp; This 14-bit counter
        increments every time <tt>TIME1</tt> (see below) wraps from
        037777 to 0; this occurs every 163.84 seconds.&nbsp; <tt>TIME2</tt>
        and <tt>TIME1</tt> together form a single 28-bit timer counting
        the number of 10 ms intervals that have elapsed since power-up,
        and will itself wrap around to zero after just over 31 days ...
        comfortably longer than any possible Apollo mission.<br>
      </li>
      <li><tt>TIME1</tt> (address 036):&nbsp; This 14-bit counter
        increments every 10 ms.&nbsp; It will wrap around from 037777 to
        0 every 163.84 seconds.<br>
      </li>
      <li><tt>TIME3</tt> (address 037):&nbsp; This 14-bit counter
        increments every 10 ms, and triggers <a
          href="#Interrupt_Processing">a T3RUPT interrupt</a> when it
        counts past its maximum value of 037777.&nbsp; However, it is
        pre-loaded via software to maintain a nominal interrupt rate of
        TBD.&nbsp; It is used for managing the "waitlist", which is part
        of the multi-tasking capability of the system.<br>
      </li>
      <li><tt>TIME4</tt> (address 040):&nbsp; This 14-bit timer
        increments every 10 ms, and triggers <a
          href="#Interrupt_Processing">a T4RUPT interrupt</a> when it
        counts past its maximum value of 037777.&nbsp; It is generally
        pre-loaded by software in a such a way as to do this every 60
        ms, although sometimes that interval is split into a 20 ms
        interval followed by a 40 ms interval.&nbsp; The section
        entitled "T4RUPT OUTPUT CONTROL" in R-467 covers the
        functionality of the T4RUPT in some detail, but in brief, it
        handles all sorts of time-sensitive i/o other than the DSKY.<br>
      </li>
      <li><tt>UPLINK</tt> (address 041):&nbsp; This 16-bit
        shift-register receives the data stream of <a href="#Uplink">digital-uplink
data,






          as described earlier</a>.&nbsp; It is included in this section
        because it is implemented in hardware similar to a counter
        register, although the software simulation simply treats it as
        any other 15-bit input register.&nbsp; (The reason for the
        discrepancy between 16-bit and 15-bit here is that the 16th bit,
        which is physically the first one transmitted, is simply a
        "start bit" used for synchronization purposes, and carries no
        data accessible to the software.)<br>
      </li>
      <li><tt>OUTCR1</tt> (address 042), <tt>OUTCR2</tt> (address
        043):&nbsp; Used for counting the logical OR of all the set
        pulses to the CDUs and gyros.&nbsp; See the "METHOD FOR
        GENERATING OUTPUT RATES" section in R-393.<br>
      </li>
      <li><tt>PIPAX</tt> (address 044), <tt>PIPAY</tt> (address 045), <tt>PIPAZ</tt>
        (address 046), <tt>CDUX</tt> (address 047), <tt>CDUY</tt>
        (address 050), <tt>CDUZ</tt> (address 051):&nbsp; Used for
        capturing accelerometer (PIPA) and angular (CDU) data from the
        IMU, by means of <a href="#UnprogrammedSequences"><tt>PINC</tt>
          and <tt>MINC</tt> unprogrammed sequences</a>, I believe.<br>
      </li>
      <li><tt>OPTX</tt> (address 052), <tt>OPTY</tt> (address 053), <tt>TRKRX</tt>
        (address 054), <tt>TRKRY</tt> (address 055), <tt>TRKRR</tt>
        (address 056):&nbsp; Used for locating fixes from the sextant,
        by means of <a href="#UnprogrammedSequences"><tt>PINC</tt> and
          <tt>MINC</tt> unprogrammed sequences</a>, I believe.<br>
      </li>
    </ul>
    <h3><a name="Interrupt_Processing" id="Interrupt_Processing"></a>Interrupt






      Processing</h3>
    At fixed-memory address 02000, you find a vector-interrupt table,
    containing 7 interrupt vectors, each 4 words long, which are
    triggered automatically in the case of an interrupt ... which are
    referred to as "RUPTS". Actually, the 7th is not an interrupt vector
    at all, but rather the power-up entry point, but it seems reasonable
    to lump it in with the other 6.<br>
    <br>
    The different interrupt types are:<br>
    <ul>
      <li>T3RUPT (address 02000) — T3RUPTs are triggered when <a
          href="#Counters_and_Timers">CPU TIMER3</a> overflows. This is
        used for servicing the WAITLIST ... i.e., for managing
        multi-tasking.</li>
      <li>ERRUPT (address 02004) — ERRUPTs are triggered upon various
        error conditions reported by hardware, and specifically upon any
        of the bits B8-B15 in <a href="io_channels">input register IN2</a>
        becoming active.</li>
      <li>T4RUPT (address 02010) — triggered when <a
          href="#Counters_and_Timers">CPU TIMER4</a> overflows. This is
        used for servicing outputs to the DSKY.</li>
      <li>KEYRUPT (address 02014) — triggered when bit B6 in <a
          href="io_channels">input register <tt>IN0</tt></a> becomes
        active ... i.e., when a DSKY key (or the MARK key) is pressed.</li>
      <li>UPRUPT (address 02020) — for servicing uplink data, which is
        in the same form as (and treated the same way as) DSKY
        keystrokes.</li>
      <li>DOWNRUPT (address 02024) — for servicing the digital downlink
        (the telemetry data).</li>
      <li>Address 02030 — the power-up entry-point of the software.</li>
    </ul>
    An interrupt performs several functions automatically in hardware
    before the interrupt-servicing by the software begins. The existing
    <tt>Q</tt> and <tt>Z</tt> register values are transferred to the
    CPU registers <tt>QRUPT</tt> and <tt>ZRUPT</tt>, and then an
    implicit <tt>TC</tt> instruction transfers control to the interrupt
    vector code, thus overwriting <tt>Q</tt> and <tt>Z</tt> with new
    values. The interrupt-service routine must eventually be terminated
    with the <tt>RESUME</tt> instruction, which undoes those steps ...
    i.e., it restores <tt>Q</tt> and <tt>Z</tt> to their original
    forms and puts the program counter back to what it had been, the
    position of the next instruction that was due to be reached when the
    interrupt occurred.<br>
    <br>
    But note that the instruction stored at that return location is not
    necessarily the instruction executed at that point! That's because
    instructions are sometimes preceded in memory by an INDEX
    instruction (described later) which has the effect of altering the
    instruction in-place, even though usually stored in fixed memory, by
    adding something to it in advance. Thus if an interrupt occurs <i>between</i>
    an <tt>INDEX</tt> and the instruction being indexed that follows
    it, it is actually the indexed instruction that will be performed
    when after the <tt>RESUME</tt> occurs. The indexed instruction is
    stored in a special CPU register, <tt>BRUPT</tt>, while the
    interrupt is being serviced. This register is so-called because in
    normal operation the CPU stores the value of the instruction it is
    executing in a special hidden, non-addressable register called <tt>B</tt>.<br>
    <br>
    Other than <tt>Q</tt>, <tt>Z</tt>, and <tt>B</tt>, the remainder
    of the state is <i>not</i> automatically stored during the
    interrupt, and so the interrupt-service routine has to explicitly
    store any other data which must be retained, such as the <tt>A</tt>
    register.<br>
    <br>
    Only one interrupt can be serviced at a time, and interrupts
    occurring simultaneously are prioritized in the same order as shown
    above.<br>
    Interrupts can be inhibited in a variety of ways, in which case the
    interrupts don't occur until the inhibiting factor is removed. These
    inhibiting factors are:<br>
    <ul>
      <li>Interrupts can be explicitly disabled using the
        assembly-language instruction <tt>INHINT</tt>, and remain
        disabled until a subsequent <tt>RELINT</tt> instruction is
        encountered.</li>
      <li>Interrupts are inhibited if there is overflow in the <tt>A</tt>
        register, because there is no way to store and restored overflow
        during the interrupt.</li>
      <li>Interrupts are inhibited if there is overflow in the hidden <tt>B</tt>
        register. This condition occurs if the next instruction that
        would have been executed is an <tt>MP</tt>, <tt>DV</tt>, or <tt>SU</tt>,
        and relates to the fact that the opcodes for these instructions
        are otherwise identical to other instructions, and the only way
        to distinguish them is if this overflow condition can be
        checked.</li>
    </ul>
    <br>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Software" id="Software"></a>Software</h2>
    <h3><a name="The_Interpreter_vs._the_CPU"
        id="The_Interpreter_vs._the_CPU"></a>The Interpreter vs. the
      CPU's Basic Instruction Set<br>
    </h3>
    As mentioned above, the Block I AGC design did not end up being used
    in any moon missions, nor even in any manned missions, but if it <i>had</i>
    been used, the required software could not have been fit into the
    memory provided by the Block I unit if simply written in the AGC
    CPU's native assembly language.&nbsp; (Nor even in the Block II
    computer, <a
      href="assembly_language_manual.html#The_Interpreter_vs._the_CPU">as
described






      here</a>.)&nbsp; Consequently, as with the Block II design, both
    the native low-level assembly language (referred to as "basic") and
    a higher-level language (referred to as "interpreter") were
    supported by the system, and a Block I program is an intermixture of
    both of these two programming languages.<br>
    <br>
    Because each of the interpreter's instructions represented many AGC
    assembly-language instructions, a larger amount of functionality
    could be fitted into the same amount of core memory, even accounting
    for the fact that software was needed to implement the interpreter.
    The drawback was that implementing any particular functionality in
    interpretive language required far more execution time than
    implementing the same functionality directly in AGC assembly
    language. But as long as the program ran "fast enough", that didn't
    matter very much.&nbsp; Between an assembly-language block of code
    and an interpretive block of code, there will be a call (in assembly
    language) to the interpreter subroutine.&nbsp; In other words, the
    interpreter subroutine expects to find the code it is going to
    interpret following the assembly language instruction which called
    it.&nbsp; Similarly, a block of interpretive code ends with a
    specific interpreter instruction meaning "stop interpreting and jump
    to the next location in memory".<br>
    <br>
    Because of this intermixing, both assembly language and interpretive
    language have to be understood for effective programming of the
    device.<br>
    <h3><a name="Formatting" id="Formatting"></a>Source-Code Formatting
      Information<br>
    </h3>
    The Virtual AGC project's AGC assembler program is known as <a
      href="yaYUL.html"><b>yaYUL</b></a>.<br>
    <br>
    The format of source code accepted by <span style="font-weight:
      bold;">yaYUL</span> differs slightly from that accepted by the
    original <span style="font-weight: bold;">YUL</span> assembler, and
    thus reflected in the assembly listings created by <b>YUL</b>. This
    is partly because I didn't originally have any documentation for <span
      style="font-weight: bold;">YUL</span>, thus determining the exact
    format required by it wasn't really possible; but also, formatting
    restrictions based on strict column alignment—which make a lot of
    sense with punch-cards—make little sense now that punch-cards have
    gone to their final resting place.&nbsp; Thus, <b>yaYUL</b> accepts
    a format for the Block I source code which is <i>almost</i>
    independent of column structure but nevertheless ends up providing
    you with basically the same visual experience.<br>
    <br>
    Here are the principles used in formatting Block I <span
      style="font-weight: bold;">yaYUL</span> source files, along with
    my stylistic preferences:<br>
    <ul>
      <li>A source-code file is an ASCII (text) file, consisting of a
        series of lines.<br>
      </li>
      <li>Blank lines are ignored.</li>
      <li>The character '#' is used to begin comments. Everything on a
        source line following the '#' symbol is discarded. (In the
        original <span style="font-weight: bold;">YUL</span>, the
        source code was on punch cards, with one line of code per card.
        I believe that the entire card was a comment if a certain
        non-blank character appeared in column 1. I'm not certain how
        comments at the end of a line of source code were recognized;
        they were either column-dependent, or else the parser simply
        gave up after all valid fields had been parsed. In any case, <span
          style="font-weight: bold;">yaYUL</span> does not support any
        of the original <span style="font-weight: bold;">YUL</span>'s
        specific commenting methods.)</li>
      <li>If the character '$' is encountered in column 1 of a line,
        then the line contains the name of a source file which is to be
        inserted at that point. For example, if
        "$INTERRUPT_LEAD_INS.agc" is encountered in column 1, then <span
          style="font-weight: bold;">yaYUL</span> will process all of
        the file INTERRUPT_LEAD_INS.agc before proceeding to process the
        remainder of the original source file. (The original <span
          style="font-weight: bold;">YUL</span> had no such source-code
        directive, since it did not process "files".)<br>
      </li>
      <li>Programmer-defined names (such as program labels and constants
        being defined) begin in column 1. They are 8 characters or less
        in size, and may contain any character except '#', and may not
        begin with the character '$'. (For example, "-1/(D)+A" would be
        a <span style="font-style: italic;">legal</span> constant name
        or program label.)</li>
      <li>A typical arrangement of items on a line of assembly-code
        would be this: optional program label, followed by an AGC opcode
        or interpreter instruction, followed by an operand for the
        opcode, followed by an optional comment. In some cases,
        additional option fields may appear between the operand and the
        comment. All fields are separated by whitespace, except that no
        space needs to precede the '#' delimiter for a comment.&nbsp;
        Stylistically, my preference is for the opcode or interpreter
        instruction to begin at the second tab stop, the operand (if
        any) at the third tab stop, options to the operand are separated
        by spaces, and the comment (if any) to begin at the fifth tab
        stop, assuming that tab stops are 8 characters apart.<br>
      </li>
      <li>In some cases, a line may have no program label but may have a
        field such as "-1", "+1", "+110", etc., preceding the opcode.
        These notations appear to serve merely as comments, and are
        simply ignored by <span style="font-weight: bold;">yaYUL</span>.
        These notations cannot begin in column 1, or else they would be
        taken for program labels.&nbsp; Stylistically, I prefer that
        these notations begin at the first tab stop.</li>
      <li><i>There is two column-based dependences, which must be
          observed</i>:&nbsp;<br>
      </li>
      <ol>
        <li>The assembly language operator or pseudo-op, or the first
          interpreter command on a line, <i>must</i> begin at the 17th
          column, and will not be recognized as a an operator,
          pseudo-op, or command otherwise.&nbsp; Tab stops are assumed
          by the assembler to advance by multiples of 8 columns, so the
          17th column is the one after 16 non-tab characters, or two tab
          characters, or any of the usual combinations of non-tab
          characters and tab characters you would expect.</li>
        <li>Sometimes, a '-' character appears in the 16th column, i.e.,
          the character preceding the assembly-language operator if
          there is one.&nbsp; The is a directive to <i>logically-complement</i>
          the output binary at that location, and is not recognized at
          any other column position.<br>
        </li>
      </ol>
    </ul>
    These principles are perhaps best understood by viewing actual
    source-code listings from Solarium 055.<br>
    <h3><a name="Data_Representation" id="Data_Representation"></a>Data
      Representation</h3>
    <p>Numerical formats are identical to those for the Block II AGC,
      and I advise you to read <a
        href="assembly_language_manual.html#Data_Representation">the
        description of them that appears in the Block II discussion</a>.<br>
    </p>
    <h3><a name="Instruction_Representation"
        id="Instruction_Representation"></a>Basic Instruction
      Representation</h3>
    The instruction set is far smaller, and therefore far simpler, than
    in Block II.&nbsp; Every assembly-language instruction occupies
    precisely one word of memory (including operand), and consists of 15
    bits as follows:<br>
    <br>
    <div style="margin-left: 40px;"> <span style="font-family:
        monospace;">CCC AAA AAA AAA AAA<br>
      </span> </div>
    <br>
    The 3-bit field <span style="font-family: monospace;">CCC</span>
    represents the instruction type (the "code"), while the 12-bits <span
      style="font-family: monospace;">AAAAAAAAAAAA</span> represent a
    memory address.&nbsp; With this simple scheme, there are seemingly
    at most 8 instruction types, each of which can operate on any memory
    location within a 4096-word area of memory.<br>
    <br>
    Although, actually, more instruction types were packed into this
    format than just the 8 that would seemingly be allowed by the 3
    available bits <tt>CCC</tt>.&nbsp; The extra instructions were
    available in a couple of obvious ways, and in one very subtle,
    unobvious way.<br>
    <br>
    One of the "obvious" ways, of course, is that just as with the Block
    II basic instructions, certain special opcode+operand combinations
    are simply set aside and used differently that one would
    anticipate.&nbsp; These will be covered in the next section, but for
    example:&nbsp; If the <tt>INDEX</tt> instruction has the specific
    operand 017, then it is no longer an <tt>INDEX</tt> operation, but
    rather as an <tt>INHINT</tt> operation.&nbsp; The other "obvious"
    way is that certain operations on erasable memory don't make sense
    for fixed memory, or vice-versa, so their action is different
    depending on which memory area it applies to.&nbsp; For example, the
    <tt>XCH</tt> opcode — which means to exchange the contents of the
    accumulator register with an erasable memory location — is instead
    interpreted as a <tt>CAF</tt> instruction — which means to load the
    accumulator from fixed memory — when the operand is a fixed-memory
    location.<br>
    <br>
    The "subtle" way is to use the <tt>INDEX</tt> instruction in an
    unusual way.&nbsp; The purpose of an <tt>INDEX</tt>, which is
    covered in the next section, is to arithmetically <i>add</i> a
    value to the <i>next</i> instruction following it, and this is
    typically used for accessing an array by adding (or subtracting) a
    value from the operand of the instruction.&nbsp; However, depending
    on the value being added or subtracted, it could also be used to
    change the opcode as well.&nbsp; The most-subtle use, though, is
    that it's theoretically possible to use <tt>INDEX</tt> to add a
    value to the next instruction's opcode which will not only change
    the opcode, but could actually have a 16th bit which is non-zero,
    and that 16th bit allows you to add a 4th bit <tt>CCCC</tt> to the
    number of instruction types you can have!&nbsp; In fact, there, are
    three different types of such "extended" instructions, <tt>MP</tt>,
    <tt>DV</tt>, and <tt>SU</tt>, all of which will be covered in the
    next section.&nbsp; What's fascinating about these instructions is
    that they are encoded in precisely the same way as the <tt>CS, TS</tt>,
    and <tt>AD</tt> instructions, respectively, and there's literally
    no way to tell which is which unless you know the instruction that
    preceded them.&nbsp; Even more fascinating, while the <i>usual</i>
    case would be that the preceding instruction was an <tt>INDEX</tt>
    operation that just added a constant value, in which case it's easy
    to that the instruction following it is "extended", <i>sometimes</i>
    the <tt>INDEX</tt>'ing was done by adding a <i>variable</i> to the
    instruction, in order to multiply, divide, or subtract an array
    element.&nbsp; In that case, even looking at the preceding <tt>INDEX</tt>
    instruction isn't enough to tell you that the next instruction is
    "extended": to determine that you have to know the value of the
    variable, which is hard to know without actually executing the
    code.&nbsp; Of course, executing the code is no problem for the CPU
    itself, since that's what the CPU does, but it's a problem for
    someone (say) disassembling the code, and fortunately it was done
    extremely rarely.<br>
    <h3><a name="AGC4_Instruction_Set" id="AGC4_Instruction_Set"></a>Basic
Instruction






      Set&nbsp;</h3>
    <p>In reading about the effects of the various "basic" instructions
      below, there are several notational conveniences that you should
      be aware of:<br>
    </p>
    <ul>
      <li>An MCT is a "machine cycle time", and is 12/1024000 seconds
        long, or about 11.7 μs.</li>
      <li>The location of the current instruction is generally referred
        to as L, so the instruction following the current instruction is
        L+1, the instruction following that is L+2, and so on.<br>
      </li>
      <li>C(<i>x</i>) refers to the contents of location <i>x</i>,
        which will often be the accumulator, C(<tt>A</tt>), or of the
        operand, C(<tt>K</tt>).</li>
      <li>On those rare occasions when it is necessary to distinguish
        between the "before" and "after" contents of a location, C(<i>x</i>)
        will be the "after", and b(<i>x</i>) will denote the "before".</li>
    </ul>
    <p>As for why it may be necessary to distinguish "before" from
      "after", one reason is <a href="#CPU_Architecture_Registers">the
        so-called "editing registers" discussed earlier</a>, namely <tt>LP</tt>,
      <tt>CYR</tt>, <tt>SR</tt>, <tt>CYL</tt>, and <tt>SL</tt>.&nbsp;
      Recall that when you <i>write</i> to such a register, what's
      saved in the register isn't the value you're theoretically writing
      to it, but rather an "edited" form of that value.&nbsp; For
      example, with <tt>CYL</tt> this editing process is to rotate all
      the bits to the left.&nbsp; Some instructions have as a side
      effect re-writing the operand, denoted (if the operand is <tt>K</tt>)
      by<br>
    </p>
    <blockquote> C(<tt>K</tt>) = b(<tt>K</tt>)<br>
    </blockquote>
    <p>Thus even though a given instruction is seemingly using its
      operand as input rather than for output, if the operand is an
      editing register, it may be automatically rewritten, and that
      means it will be re-edited every time the instruction is used.<br>
    </p>
    <p>A couple of points about the Block I basic instruction set that
      may not be obvious at first glance are:<br>
    </p>
    <ul>
      <li>There is no instruction for loading the accumulator from
        erasable memory, though there is one for loading the accumulator
        from fixed memory (namely <tt>CAF</tt>).&nbsp; There are
        several workarounds, but one which guarantees no side-effects,
        unless <tt>K</tt> is an editing register, is "<tt>CS K</tt>"
        (C(<tt>A</tt>) = -C(<tt>K</tt>)) followed by "<tt>COM</tt>" (C(<tt>A</tt>)
        = -C(<tt>A</tt>)).</li>
      <li>There is no instruction without side-effects for saving the
        accumulator to erasable memory.&nbsp; The <tt>TS</tt>
        instruction is almost always used for this but can have an
        unwanted side-effect which must be guarded against, if the
        accumulator contains <a href="#Overflow">overflow</a>.<br>
      </li>
    </ul>
    <h4><a name="AD" id="AD"></a>AD</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Add"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">AD K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT or 3 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">060000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction adds the
            contents of a memory location to the accumulator:<br>
            <blockquote> C(<tt>A</tt>) = C(<tt>A</tt>) + C(<tt>K</tt>)<br>
            </blockquote>
            It does, however, have the side effect<br>
            <blockquote> C(<tt>K</tt>) = b(<tt>K</tt>)<br>
            </blockquote>
            which means that if <tt>K</tt> is an editing register, then
            it will be edited.<br>
            <br>
            It should be noted that for any number <i>x</i>,<br>
            <blockquote> <i>x</i> + -<i>x</i> = -0<br>
            </blockquote>
            Moreover, if the accumulator contains <a href="#Overflow">overflow</a>
            after the addition, the <tt>OVCTR</tt> register is modified
            as follows, thus taking one extra MCT to do so:<br>
            <ul>
              <li>If the overflow is positive, then <tt>OVCTR</tt> is
                incremented by one.</li>
              <li>If the overflow is negative, then <tt>OVCTR</tt> is
                decremented by one.</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>CAF</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Clear accumulator and add
            from fixed memory"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">CAF K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            <i>fixed</i> memory (06000-07777).<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">030000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction loads C(<tt>A</tt>)
            with C(<tt>K</tt>):<br>
            <blockquote> C(<tt>A</tt>) = C(<tt>K</tt>) </blockquote>
            The value is sign-extended before being loaded into the
            accumulator.<br>
            <br>
            The opcode is numerically identical to the <tt>XCH</tt>
            instructions, with the difference being that <tt>K</tt> is
            in fixed rather than erasable memory.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>CCS</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Count, Compare, and Skip"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">CCS K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            <i>fixed</i> memory.&nbsp; In other words, it cannot be in
            erasable memory.&nbsp; If less than 06000 it is in
            fixed-fixed memory, while if in the range 06000 to 07777 is
            in banked fixed memory and the <tt>Bank</tt> register is
            used to determine the applicable memory bank.&nbsp;
            Sometimes the <tt>TC</tt> occurs then <tt>Bank</tt> holds
            00000, which is actually interpreted as bank 03.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">010000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is used for conditional
            jumps and for loop control, and has several effects.&nbsp; <tt>K</tt>
            must be in erasable memory, and is thus the address of a
            variable.&nbsp; The operand is sign-corrected or
            sign-extended before use, depending on whether it is from a
            16-bit register or 15-bit memory.<br>
            <br>
            The accumulator (<tt>A</tt>) is loaded with the "diminished
            absolute value" of the operand,<br>
            <blockquote> C(<tt>A</tt>) = DABS( b(<tt>K</tt>) )<br>
            </blockquote>
            where DABS(<i>x</i>) is defined as<br>
            <blockquote>
              <table summary="" cellspacing="2" cellpadding="2">
                <tbody>
                  <tr>
                    <td valign="middle">DABS(<i>x</i>) =<br>
                    </td>
                    <td valign="middle"><font face="Helvetica, Arial,
                        sans-serif"><big><big><big><big> <big>{</big></big></big></big></big></font></td>
                    <td valign="middle">|<i>x</i>| - 1, if |<i>x</i>|
                      &gt; 1<br>
                      <br>
                      +0, if |<i>x</i>| ≤ 1</td>
                  </tr>
                </tbody>
              </table>
            </blockquote>
            Also, <tt>K</tt> is rewritten,<br>
            <blockquote> C(<tt>K</tt>) = b(<tt>K</tt>) </blockquote>
            so <tt>K</tt> is edited if it is an editing register.<br>
            <br>
            Lastly, a comparison is performed, and a jump is made on the
            basis of that comparison:<br>
            <ul>
              <li>Jump to L+1 (i.e., proceed along the normal flow of
                execution) if b(<tt>K</tt>) &gt; 0.</li>
              <li>Jump to L+2 if b(<tt>K</tt>) = +0.</li>
              <li>Jump to L+3 if b(<tt>K</tt>) &lt; 0.</li>
              <li>Jump to L+4 if b(<tt>K</tt>) = -0.</li>
            </ul>
            <p>If <tt>K</tt> has a 16th bit (for example, if it is the
              accumulator), it is the 16th bit (UC) which determines the
              sign, and not the 15th bit (SG).<br>
            </p>
            <p><b>Note:</b>&nbsp; the latter description is at odds with
              the description on p. 3-4 of R-393, which says that C(<tt>K</tt>)
              rather than b(<tt>K</tt>) is what's tested for the
              comparison.&nbsp; But <a
                href="Block1.html#John_Pultoraks_Assembler_and_Simulator">
                John Pultorak's simulator</a> (and mine) behave the way
              I've described here, and I trust John's reading of the
              control-pulse sequences more than I trust R-393.&nbsp; Of
              course, John <i>got</i> the pulse sequences from R-393,
              so it's a vicious cycle!&nbsp; The issue may need to be
              revisited later.<br>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>COM</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Complement"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">COM<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">040000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction is actually
            just a mnemonic for "<tt><a href="#CS">CS</a> A</tt>" and
            hence just negates (take a bitwise inverse) of the
            accumulator:<br>
            <blockquote> C(<tt>A</tt>) = -C(<tt>A</tt>)<br>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <h4><a name="CS" id="CS"></a>CS</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Clear and Subtract"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">CS K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">040000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction loads the
            accumulator with the negative of the contents of a memory
            location:<br>
            <blockquote> C(<tt>A</tt>) = -C(<tt>K</tt>)<br>
            </blockquote>
            which is just the bitwise inverse.&nbsp; It does, however,
            have the side effect<br>
            <blockquote> C(<tt>K</tt>) = b(<tt>K</tt>)<br>
            </blockquote>
            which means that if <tt>K</tt> is an editing register, then
            it will be edited.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>DOUBLE</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Double"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">DOUBLE<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT or 3 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">060000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction is a
            mnemonic for "<tt>AD A</tt>", and hence doubles the
            accumulator:<br>
            <blockquote> C(<tt>A</tt>) = b(<tt>A</tt>) + b(<tt>A</tt>)<br>
            </blockquote>
            If the accumulator contains <a href="Block1.html#Overflow">
              overflow</a> after the addition, the effect on the <tt>OVCTR</tt>
            register is as described for <a href="#AD"><tt>AD</tt></a>.
          </td>
        </tr>
      </tbody>
    </table>
    <h4>DV</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Divide"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">DV K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">18 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">050000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is an "extended"
            instruction, meaning that it is coded as<br>
            <blockquote> <tt>EXTEND</tt><tt><br>
              </tt> <span style="font-family: monospace;">DV</span> <tt>K</tt><br>
            </blockquote>
            or by some operation such as<br>
            <blockquote> <tt>INDEX K<sub>0</sub></tt><tt><br>
              </tt> <span style="font-family: monospace;">DV</span> <tt>K</tt><br>
            </blockquote>
            that produces a 16-bit <span style="font-family:
              monospace;">DV</span> instruction value ... i.e., whose
            bit 16 is non-zero.&nbsp; Thus even though the octal value
            of the instruction is shown above as <tt>050000+K</tt>, and
            that's what appears in the rope and how the assembler sees
            it, in fact by the time it is executed it is really <tt>0120000+K</tt>,
            which is how the CPU sees it.<br>
            <br>
            Logically, though not at the control-pulse level, what you
            can think of this instruction as doing is:<br>
            <ol>
              <li>Multiplying the accumulator by 2<sup>14</sup>.</li>
              <li>Dividing that number by the value stored in the
                operand.</li>
              <li>Storing the quotient in the accumulator.</li>
              <li>Storing the negative of the absolute value of the
                remainder in <tt>Q</tt>.</li>
              <li>Setting <tt>LP</tt> to some positive value if the
                quotient is positive, or to some negative value if the
                quotient is negative.<br>
              </li>
            </ol>
            In point of fact, it's not just "some" positive or negative
            value that's stored in <tt>LP</tt>, but rather some
            specific value determined by the <a href="#Pulse_Sequences">control-pulse






              sequences</a> defining the <tt>DV</tt> instruction, but
            R-393 does not define them, and it's impossible to know what
            they might be without following through the control-pulse
            sequences in detail. I choose not to do that at this time
            Unless some AGC developer chose to use his undocumented
            knowledge of these specific values, which is certainly
            possible, there should be no need to know the specific
            values.<br>
            <br>
            This instruction envisages that |b(<tt>A</tt>)| &lt; |C(<tt>K</tt>)|
but






            does make some statements about what should happen in other
            cases<br>
            <ul>
              <li>If |b(<tt>A</tt>)| = |C(<tt>K</tt>)|, then |C(<tt>A</tt>)|
=






                037777 and C(<tt>Q</tt>) = -|C(<tt>K</tt>)|.</li>
              <li>If |b(<tt>A</tt>)| &gt; |C(<tt>K</tt>)|, then |C(<tt>A</tt>)|
=






                037777 and C(<tt>Q</tt>) "is meaningless".</li>
            </ul>
            The latter condition would always be satisfied if the
            accumulator initially contains overflow, so that condition
            should be avoided.<br>
            <br>
            C(<tt>K</tt>) is unchanged, unless <tt>K</tt> is itself <tt>A</tt>,
            <tt>Q</tt> or <tt>LP</tt>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>EXTEND</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Extend"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">EXTEND<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">025777<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is a mnemonic for
            special form of the <tt>INDEX</tt> instruction which is
            used for producing the necessary <a href="#Overflow">overflow</a>
            in the <tt>MP</tt>, <tt>DV</tt>, or <tt>SU</tt>
            instruction following it, in a way that enables those
            instruction types, which would otherwise be interpreted as <tt>TS</tt>,
            <tt>AD</tt>, and <tt>MASK</tt> instructions.&nbsp; In other
            words, the most-straightforward way to use these extended
            instructions is as<br>
            <blockquote> <tt>EXTEND</tt><tt><br>
              </tt> <tt>MP K<sub>1</sub></tt><tt><br>
              </tt> <tt>...</tt><tt><br>
              </tt> <tt>EXTEND</tt><tt><br>
              </tt> <tt>DV K<sub>2</sub></tt><tt><br>
              </tt> <tt>...</tt><tt><br>
              </tt> <tt>EXTEND</tt><tt><br>
              </tt> <tt>SU K<sub>3</sub></tt><br>
            </blockquote>
            However, using <tt>EXTEND</tt> require a little
            preparation, because the assembler actually treats it as a
            mnemonic for "<tt>INDEX 05777</tt>" which will have
            embarassing results at runtime if the appropriate value
            isn't actually at address 05777 at runtime.&nbsp; Solarium
            uses the following code, which assembles the same as "<tt>OCT






              47777</tt>", so that's what I'd suggest doing:<br>
            <br>
            <blockquote> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SETLOC&nbsp;&nbsp;






                5777&nbsp; # STANDARD LOCATION FOR EXTENDING BITS</tt><tt><br>
              </tt> <tt>OPOVF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
XCADR&nbsp;&nbsp;&nbsp;






                0<br>
              </tt> </blockquote>
            How does this actually work?&nbsp; Well, suppose you needed
            to "extend" the instruction <tt>SU 1234</tt>:<br>
            <br>
            <blockquote> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;






                EXTEND<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SU






                1234<br>
              </tt> </blockquote>
            These two instructions are the same as <tt>INDEX 5777</tt>
            and <tt>OCT 61234</tt>, respectively, so when the CPU gets
            to the <tt>SU</tt>, the instruction that the CPU will be
            trying to execute is (because of sign-extension)
            0147777+0161234, which equals 0131234 (in 16-bit 1's
            complement addition, if there's a 1 in bit 17, which there
            was in this case, it's removed and 1 is added to the
            number).&nbsp; The top 4 bits of this 16-bit sum are <tt>CCCC</tt>=1011,
which






            tells the CPU that it's an <tt>SU</tt> instruction, but the
            operand is still 01234.&nbsp; All of which is, of course,
            rather convoluted, but it doesn't matter since all you have
            to remember is that if you stick the <tt>EXTEND</tt> in
            front then it magically works.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>INDEX</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Index"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">INDEX K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory other than 016, 017, or 025.&nbsp; If less than 06000
            it is in erasable or fixed-fixed memory, while if in the
            range 06000 to 07777 is in banked fixed memory and the <tt>Bank</tt>
            register is used to determine the applicable memory
            bank.&nbsp; Sometimes the <tt>TC</tt> occurs then <tt>Bank</tt>
            holds 00000, which is actually interpreted as bank 03.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">020000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction does not
            affect execution flow — i.e., the next program-counter
            location after <tt>INDEX</tt> is at L+1 — but next
            instruction <i>value</i> used is not C(L+1) but rather
            C(L+1)+C(<tt>K</tt>).&nbsp; In other words, the value stored
            at <tt>K</tt> is added to the next instruction value found.<br>
            <br>
            This effect can be used for several purposes:<br>
            <ul>
              <li>Indexing of data, if C(<tt>K</tt>) doesn't cause the
                operand to overflow 12 bits.</li>
              <li>Changing the instruction type, if the addition affects
                the top three bits of the instruction.</li>
              <li>"Extending" a <tt>CS</tt>, <tt>TS</tt>, or <tt>AD</tt>
                instruction to an <tt>MP</tt>, <tt>DV</tt>, or <tt>SU</tt>
                instruction, if the addition causes the instruction
                value to overflow 15 bits.&nbsp; This is the <i>only</i>
                manner in which the latter three instruction types can
                be triggered.</li>
            </ul>
            <p>C(<tt>K</tt>) can be either positive or negative.<br>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>INHINT</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Inhibit interrupts"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">INHINT<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">020017<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction causes all
            interrupts to be inhibited until a <tt>RELINT</tt>
            instruction is executed.<br>
            <br>
            It is actually a mnemonic for an "<tt>INDEX 17</tt>", but
            there is not actually any register at address 017, and the
            hardware treats this code specially rather than as an <tt>INDEX</tt>
            instruction.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>MASK</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Mask"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">MASK K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">070000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction takes the
            bitwise AND of the contents of a memory location and the
            accumulator:<br>
            <blockquote> C(<tt>A</tt>) = C(<tt>A</tt>) &amp; C(<tt>K</tt>)<br>
            </blockquote>
            It does, however, have the side effect<br>
            <blockquote> C(<tt>K</tt>) = b(<tt>K</tt>)<br>
            </blockquote>
            which means that if <tt>K</tt> is an editing register, then
            it will be edited.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4><a name="MP" id="MP"></a>MP</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Multiply"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">MP K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">8 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">040000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is an "extended"
            instruction, meaning that it is coded as<br>
            <blockquote> <tt>EXTEND</tt><tt><br>
              </tt> <tt>MP K</tt><br>
            </blockquote>
            or by some operation such as<br>
            <blockquote> <tt>INDEX K<sub>0</sub></tt><tt><br>
              </tt> <tt>MP K</tt><br>
            </blockquote>
            that produces a 16-bit <tt>MP</tt> instruction value ...
            i.e., whose bit 16 is non-zero.&nbsp; Thus even though the
            octal value of the instruction is shown above as <tt>040000+K</tt>,
            and that's what appears in the rope and how the assembler
            sees it, in fact by the time it is executed it is really <tt>0110000+K</tt>,
            which is how the CPU sees it.<br>
            <br>
            This instruction multiplies two single-precision (i.e.,
            15-bit) values, from a memory location and the accumulator
            (sign-corrected), and produces a 29-bit value stored in the
            accumulator (more-significant word) and the <tt>LP</tt>
            register (less-significant word).&nbsp; In other words,
            since the ranges of the input and output are each ±2<sup>14</sup>,
            the range of the product must be just ±2<sup>28</sup>, or 29
            bits in all; the sign bit is duplicated into each of the two
            words, making a total of 30 bits.
            <blockquote> C(<tt>A</tt>,<tt>LP</tt>) = b(<tt>A</tt>) × b(<tt>K</tt>)<br>
            </blockquote>
            The signs of the two output registers are identical, and are
            identical to the product of the signs of the two inputs ...
            which sounds obvious until you recognize that it covers
            cases like -0 × +53 = -0.<br>
            <br>
            C(<tt>K</tt>) is unchanged, unless <tt>K</tt> is itself <tt>A</tt>
            or <tt>LP</tt>.<br>
            <br>
            <b>Note:</b>&nbsp; R-393, p. 3-7, says that this instruction
            take 10 MCT.&nbsp; <a
              href="#John_Pultoraks_Assembler_and_Simulator">John
              Pultorak's simulator command-sequence simulator</a> says
            that it takes 8, and for the present time, I accept what
            John says.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>NOOP</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"<tt>No-op</tt>"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">NOOP<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">030000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction is a
            mnemonic for "<tt>XCH A</tt>", i.e., exchange the contents
            of the accumulator with itself.&nbsp; Since that doesn't
            have any effect other than to use up a couple of MCT, it is
            a "no operation".<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>OVIND</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Overflow indicator (?)"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">OVIND K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            <i>fixed</i> memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT if the accumulator
            contains no overflow, 3 MCT if the accumulator contains
            overflow.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">050000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction is actually
            identical to <tt>TS</tt>, and is simply a different
            mnemonic for it that is less confusing when the operand is
            fixed memory, because when the operand is fixed memory it is
            impossible to copy the accumulator to the operand.&nbsp;
            However, all other behavior (setting accumulator to 000001
            or 177776 and skipping the next instruction on overflow) is
            identical to what has been described for <a href="#TS"><tt>TS</tt></a>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>OVSK</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Overflow skip"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">OVSK<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">050000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction is a
            mnemonic for "<tt>TS A</tt>", though its behavior is not
            precisely identical to what you'd expect <tt>TS A</tt> to
            do, since C(<tt>A</tt>) is not modified even if there is
            overflow.<br>
            <br>
            As you may expect, its action is to continue to the next
            address if the accumulator does not contain overflow, but
            skips the next address and proceeds to the address after
            that if the accumulator does contain overflow.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>RELINT</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Release interrupts"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">RELINT<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">020016<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction causes all
            interrupts to be re-enabled after a corresponding a <tt>INHINT</tt>
            instruction has disabled them.<br>
            <br>
            It is actually a mnemonic for an "<tt>INDEX 16</tt>", but
            there is not actually any register at address 016, and the
            hardware treats this code specially rather than as an <tt>INDEX</tt>
            instruction.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>RESUME</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Resume" from interrupt<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">RESUME<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">020025<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction is
            numerically equivalent to "<tt>INDEX</tt> 25", but is not an
            <tt>INDEX</tt> instruction.&nbsp; As mentioned before, <a
              href="#Interrupt_Processing">when an interrupt occurs</a>,
            it automatically performs a sequence of steps like<br>
            <blockquote> Inhibit interrupts<br>
              C(<tt>BRUPT</tt>) = C(<tt>B</tt>)<br>
              C(<tt>QRUPT</tt>) = C(<tt>Q</tt>)<br>
              C(<tt>ZRUPT</tt>) = C(<tt>Z</tt>)<br>
              <a href="#TC">TC</a> to interrupt-service routine<br>
            </blockquote>
            where (recall) <tt>B</tt> is the register that holds next
            instruction that would have been executed when the interrupt
            occurred.&nbsp; (Not necessarily C(L), since an <tt>INDEX</tt>
            instruction might have preceded it an altered the numerical
            value of the instruction.)&nbsp; Note that this interrupt
            inhibition is a different mechanism from the one used by <a
              href="#INHINT"><tt>INHINT</tt></a> and <a href="#RELINT"><tt>RELINT</tt></a>.<br>
            <br>
            What <tt>RESUME</tt> does is to undo these steps:<br>
            <blockquote> C(<tt>B</tt>) = C(<tt>BRUPT</tt>)<br>
              C(<tt>Q</tt>) = C(<tt>QRUPT</tt>)<br>
              C(<tt>Z</tt>) = C(<tt>ZRUPT</tt>)<br>
              Stop inhibiting interrupts<br>
            </blockquote>
            This has the effect of putting the program counter (<tt>Z</tt>)
            back to what it had been before the interrupt, restoring any
            return address that had been in <tt>Q</tt>, and executing
            the same instruction (<i>numerically</i>) that had been
            about to execute, regardless of whether it's what was stored
            at the return location or not: i.e., regardless of whether
            or not the interrupt had occurred between an <tt>INDEX</tt>
            instruction and the instruction following it.<br>
            <br>
            Notice that in theory, you could force any instruction you
            like to execute upon return from interrupt, simply by
            replacing the contents of the <tt>BRUPT</tt> register from
            within the interrupt-service routine.&nbsp; Why you might
            want to do that, I can't say.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>RETURN</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Return"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">RETURN<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">1 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">000001<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction is a
            mnemonic for "<tt>TC Q</tt>", meaning that it can be used to
            return from a subroutine.</td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>SQUARE</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Square"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">SQUARE<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">8 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">040000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is an "extended"
            instruction, meaning that it is coded as<br>
            <blockquote> <tt>EXTEND</tt><tt><br>
              </tt> <tt>SQUARE</tt><br>
            </blockquote>
            Thus even though the octal value of the instruction is shown
            above as <tt>040000</tt>, and that's what appears in the
            rope and how the assembler sees it, in fact by the time it
            is executed it is really <tt>0110000</tt>, which is how the
            CPU sees it.<br>
            <br>
            This instruction has the effect
            <blockquote> C(<tt>A</tt>,<tt>LP</tt>) = b(<tt>A</tt>) × b(<tt>A</tt>)<br>
            </blockquote>
            and all of the comments for <a href="#MP"><tt>MP</tt></a>
            apply to it.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>SU</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Subtract"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">SU K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            memory.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT or 3 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">060000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is an "extended"
            instruction, meaning that it is coded as<br>
            <blockquote> <tt>EXTEND</tt><tt><br>
              </tt> <tt>SU K</tt><br>
            </blockquote>
            or by some operation such as<br>
            <blockquote> <tt>INDEX K<sub>0</sub></tt><tt><br>
              </tt> <tt>SU K</tt><br>
            </blockquote>
            that produces a 16-bit <tt>SU</tt> instruction value ...
            i.e., whose bit 16 is non-zero.&nbsp; Thus even though the
            octal value of the instruction is shown above as <tt>060000+K</tt>,
            and that's what appears in the rope and how the assembler
            sees it, in fact by the time it is executed it is really <tt>0130000+K</tt>,
            which is how the CPU sees it.<br>
            <br>
            This instruction subtracts the contents of a memory location
            from the accumulator:<br>
            <blockquote> C(<tt>A</tt>) = C(<tt>A</tt>) - C(<tt>K</tt>)<br>
            </blockquote>
            In all other respects — timing, side-effects, special cases
            — it is identical to the <tt>AD</tt> instruction. </td>
        </tr>
      </tbody>
    </table>
    <h4>TCAA</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Transfer control to address
            in <tt>A</tt>"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">TCAA<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">050002<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction is a
            mnemonic for "<tt>TS Z</tt>", though its behavior is not
            precisely identical to what you'd expect <tt>TS Z</tt> to
            do, since there is no skip-on-overflow.<br>
            <br>
            Suppose that the initial contents of the accumulator, b(<tt>A</tt>),
is






            the logical OR<br>
            <blockquote> b(<tt>A</tt>) = <tt>OP</tt> | <tt>K</tt><br>
            </blockquote>
            where only the 4 most-significant bits of the 16-bit value <tt>OP</tt>
            may be non-zero, and only the least-significant 12 bits of <tt>K</tt>
            may be zero.&nbsp; The operation of <tt>TCAA</tt> will be:<br>
            <ul>
              <li>C(<tt>A</tt>):</li>
              <ul>
                <li>If b(<tt>A</tt>) contains no overflow: C(<tt>A</tt>)=b(<tt>A</tt>).</li>
                <li>If b(<tt>A</tt>) contains positive overflow: C(<tt>A</tt>)=000001.</li>
                <li>If b(<tt>A</tt>) contains negative overflow: C(<tt>A</tt>)=177776.</li>
              </ul>
              <li>The next instruction executed will be at address <tt>K</tt>.</li>
            </ul>
            <p>But there's a tricky aspect to this, in that since <tt>TCAA</tt>
              is still a "transfer to storage" operation, this means
              that the 16-bit <tt>Z</tt> register will in fact have its
              upper 4 bits loaded with <tt>OP</tt>, and those upper 4
              bits remain set unless you explicitly set them to
              something else!&nbsp; In other words, the lower 12 bits of
              <tt>Z</tt> will continue to change as we advance from one
              instruction to the next, but the upper 12 bits won't
              change. However, the upper 4 bits of the <tt>Z</tt>
              register are normally 0, and if <tt>OP</tt> isn't zero,
              that leaves a potential problem lurking for the
              future.&nbsp; The problem is what happens when the next <tt>TC</tt>
              instruction is encountered.&nbsp; Recall that a <tt>TC</tt>
              instruction, in addition to transferring control, also
              loads the <tt>Q</tt> register with the return
              address.&nbsp; Now, that's a shorthand way of saying that
              <tt>Q</tt> gets loaded with a <tt>TC</tt> to the return
              address.&nbsp; But if <tt>OP</tt> isn't zero, then what
              that eventual <tt>TC</tt> loads into <tt>Q</tt> is not a
              <tt>TC</tt> to the return address, but some other
              instruction (<tt>OP</tt>) whose operand is the return
              address.&nbsp; Of course, a TC which is a simple "jump"
              won't have a problem, since it won't expect to find any
              return address, and the problem will occur only if you're
              using it as a call to a subroutine.<br>
            </p>
            <p>All of which boils down to saying that unless you intend
              to exploit this wacky feature, don't use this instruction,
              or else make sure you get the upper 4 bits of <tt>Z</tt>
              set back to zero somehow before the next subroutine call
              you want to use!<br>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
    <h4><a name="TC" id="TC"></a>TC or TCR<br>
    </h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Transfer Control"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">TC K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address
            whatever in memory.&nbsp; If less than 06000 it is in
            erasable or fixed-fixed memory, while if in the range 06000
            to 07777 is in banked fixed memory and the <tt>Bank</tt>
            register is used to determine the applicable memory
            bank.&nbsp; Sometimes the <tt>TC</tt> occurs then <tt>Bank</tt>
            holds 00000, which is actually interpreted as bank 03.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">1 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">000000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This is used both for
            unconditional jumps to locations, or for calling
            subroutines.&nbsp; It can be done for the latter because a
            side effect is that<br>
            <blockquote> C(<tt>Q</tt>) = L + 1<br>
            </blockquote>
            i.e., that the <tt>Q</tt> register is loaded with the next
            address following the <tt>TC</tt> instruction (and the
            original value of <tt>Q</tt> is lost), and a return from a
            subroutine can be done with the instruction<br>
            <blockquote> <tt>TC Q</tt><br>
            </blockquote>
            But there's no stack, so you have to be extremely careful
            when doing things like calling subroutines from within other
            subroutines, because each call destroys the existing return
            address.&nbsp; So one thing that subroutines typically do is
            to save the <tt>Q</tt> register as a variable immediately
            upon entry , and to restore it from that variable
            immediately prior to exiting.<br>
            <br>
            The instruction <tt>TCR</tt> does not differ from <tt>TC</tt>
            in any way, but it may clarify the intention of your source
            code to use <tt>TCR</tt> when you are calling a subroutine
            from which there will be a return, and <tt>TC</tt> when you
            are performing a simple jump.&nbsp; However, this seems to
            have been done very seldom in a program like Solarium.<br>
            <br>
            Note that a return from interrupt is not done in this
            manner, and requires its own dedicated instruction, <tt>RESUME</tt>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4><a name="TS" id="TS"></a>TS</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Transfer to Storage"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">TS K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            <i>erasable</i> memory (0-01777).<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT if the accumulator
            contains no overflow, 3 MCT if the accumulator contains
            overflow.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">050000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction always
            copies the accumulator to memory,<br>
            <blockquote> C(<tt>K</tt>) = C(<tt>A</tt>)<br>
            </blockquote>
            If <tt>K</tt> is 15-bit memory, then <tt>A</tt> is
            sign-corrected (i.e, <a href="#Overflow">the 16th bit US is
              moved to the 15th bit SG</a>) before storing.&nbsp; If <tt>K</tt>
            is an <a href="#CPU_Architecture_Registers">editing
              register</a>, then editing is performed during storage.<br>
            <br>
            <div align="center"> <b>Skip on Overflow</b><br>
            </div>
            <br>
            If the accumulator does not contain overflow, then that is
            the end of the operation.&nbsp; But if the accumulator does
            contain overflow, then the following "skip on overflow"
            operation (which occupies an additional 1 MCT) is performed:<br>
            <ul>
              <li>If b(<tt>A</tt>) contains positive overflow, then C(<tt>A</tt>)=000001.</li>
              <li>If b(<tt>A</tt>) contains negative overflow, then C(<tt>A</tt>)=0177776.</li>
              <li>The instruction at L+1 is skipped, and the next
                instruction executed is at L+2.<br>
              </li>
            </ul>
            This skip-on-overflow feature is used for multi-precision
            arithmetic, where it is convenient, but it means that the <span
              style="font-family: monospace;">TS</span> instruction has
            to be used with extreme caution in other
            circumstances.&nbsp; If you think of it merely as a storage
            instruction, you will quickly run into circumstances where
            it's behavior is very confusing.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>XAQ</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Execute C(<tt>A</tt>) using
            <tt>Q</tt>"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">XAQ<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;">None.<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">1 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">000000<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;"> This instruction is a
            mnemonic for "<tt>TC A</tt>", meaning that it will:<br>
            <ul>
              <li>Jump to address 0, storing a return address in <tt>Q</tt>.</li>
              <li>Execute whatever instruction it finds at address 0
                (which is the <tt>A</tt> register).</li>
              <li>Proceed to address 1 (presuming that there wasn't a <tt>TC</tt>
                or <tt>CCS</tt> at address 0).</li>
              <li>Since what is stored at address 1, the <tt>Q</tt>
                register, is the return address, which is numerically
                identical to a <tt>TC</tt> to the return address, it
                will thus return to the address following the <tt>XAQ</tt>.<br>
              </li>
            </ul>
            However, this is confusing when you see it in a simulation,
            and R-393 recommends instead using the following presumably
            less-confusing commands in preference to an <tt>XAQ</tt>:<br>
            <blockquote> <tt>INDEX A</tt><tt><br>
              </tt> <tt>TC 0</tt><br>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h4>XCH</h4>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Description:<br>
          </td>
          <td style="vertical-align: top;">"Exchange"<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">XCH K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><tt>K</tt> is any address in
            <i>erasable</i> memory (0-01777).<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;"> Timing:<br>
          </td>
          <td style="vertical-align: top;">2 MCT<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">030000 + K<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;"> Notes:<br>
          </td>
          <td style="vertical-align: top;">This instruction exchanges C(<tt>A</tt>)
            and C(<tt>K</tt>).&nbsp; If <tt>K</tt> is an editing
            register, it is edited in the process of doing this.<br>
            <br>
            The opcode is numerically identical to the <tt>CAF</tt>
            instructions, with the difference being that <tt>K</tt> is
            in erasable rather than fixed memory.<br>
            <br>
            <b>Note:</b>&nbsp; The Virtual AGC Block I simulator will
            not change C(<tt>K</tt>) if <tt>K</tt> happens to be one of
            the input registers, <tt>IN0</tt> - <tt>IN3</tt>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><br>
    </h3>
    <h3><a name="Pseudo-Operations" id="Pseudo-Operations"></a>Pseudo-Operations</h3>
    <p>The pseudo-ops are a subset of those in Block II.&nbsp; Actually,
      <b>yaYUL</b> supports the identical pseudo-ops for Block I as it
      does for Block II, but some of those pseudo-ops simply make no
      sense for Block I and therefore will never appear in actual
      code.&nbsp; I know I should have yaYUL exclude the nonsensical
      pseudo-ops, but I have no present intention of doing so.&nbsp; <a
        href="assembly_language_manual.html#Pseudo-Operations">See the
        Block II description</a>.<br>
    </p>
    <h3><a name="Interpreter_Instruction_Set"
        id="Interpreter_Instruction_Set"></a>Interpreter Instruction Set<br>
    </h3>
    Block I interpreter language is superficially similar to Block II
    interpreter language, but is actually structured quite
    differently.&nbsp; Moreover, it partakes of certain coding
    conventions not present in Block II.&nbsp; It is also missing a
    number of interpreter commands that are present in Block II, while
    it has a number of commands that are not present in Block II.<br>
    <h4>Source Code and Encoding<br>
    </h4>
    Interpreter source code is structured as a series of what are
    referred to as "equations", though they are not.&nbsp; Each
    "equation" consists of a group of commands of variable length,
    followed by a group of operands of a variable length.<br>
    <br>
    There are several different forms an equation can take, and rather
    than trying to give you a rule for them, I'll just illustrate the 4
    possible forms they can take:<br>
    <blockquote> <tt><i># Pattern 1:<br>
          OPERATOR<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
            <br>
          </sub></i></tt> <tt><i><tt><i># Pattern 2:<br>
            </i></tt> OPERATOR</i></tt><tt><i><sub>A</sub> &nbsp;
          OPERATOR<sub>B</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
            <br>
          </sub></i></tt> <tt><i><tt><i># Pattern 3:<br>
            </i></tt> OPERATOR</i></tt><tt><i><sub>0</sub> &nbsp; M<br>
        </i></tt> <tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>1A</sub>&nbsp;






              OPERATOR<sub>1B<br>
              </sub></i></tt></i></tt> <tt><i>.<br>
          .<br>
          . &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
        </i></tt> <tt><i><tt><i><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>MA</sub>&nbsp;






                      OPERATOR<sub>MB<br>
                      </sub></i></tt></i></tt></i></tt>
          &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
          </sub></i></tt><br>
      <tt><i><sub><br>
          </sub></i></tt> <tt><i><tt><i># Pattern 4:<br>
            </i></tt> OPERATOR</i></tt><tt><i><sub>0</sub> &nbsp; M<br>
        </i></tt> <tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>1A</sub>&nbsp;






              OPERATOR<sub>1B<br>
              </sub></i></tt></i></tt> <tt><i>.<br>
          .<br>
          . &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
        </i></tt> <tt><i><tt><i><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>M</sub><sub><br>
                      </sub></i></tt></i></tt></i></tt>
          &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
          </sub></i></tt> </blockquote>
    Now, each operator employs a certain number of operands, either 0 or
    1, and you would superficially expect the number of operands in the
    equation to add up to the number of operands required by the
    operators.&nbsp; However, this is seldom true, and there can be
    either more or less operands than you would expect.<br>
    <br>
    TBD<br>
    <br>
    <hr size="2">
    <h2><a name="Pulse_Sequences" id="Pulse_Sequences"></a>Control-Pulse
      Sequences</h2>
    <p>As has been explained above, the Block I AGC's "basic
      instructions" (i.e., the assembly-language instructions as opposed
      to interpretive instruction) mostly require 2 machine cycle times
      (MCTs) to executed, although the <tt>TS</tt> instruction usually
      takes only 1 MCT, and others like <tt>MP</tt> or <tt>DV</tt>
      take considerably more.&nbsp; One MCT requires about 11.7 μs, or
      more-precisely, 12/1.024 = 11.71875&nbsp; μs (plus or minus
      whatever the clock tolerance is, of course).<br>
    </p>
    <p>That is the viewpoint from the abstraction level of "basic
      instructions", and is the world-view enforced by our Block I CPU
      simulator, but does not represent the underlying physical reality
      of hardware AGC.&nbsp; From the physical standpoint:<br>
    </p>
    <ul>
      <li>The CPU operates at a 1.024 MHz clock rate.</li>
      <li>During each clock period (which for the sake of discussion
        we'll call an SCL), from 0 to 5 "control pulses" can execute
        simultaneously and independently of each other.&nbsp; These
        "control pulses" are essentially microcode instructions that
        operate on a set of hidden registers, mostly not addressable
        directly by basic instructions, and are of many types:&nbsp;
        many more types than there are basic instructions.</li>
      <li>The basic instructions are simply abstractions consisting of
        12 or 24 (or some other multiple of 12) sets of 0-5 control
        pulses each.</li>
    </ul>
    <p>The sequence of control pulses corresponding to a basic
      instruction is, of course, its "control-pulse sequence".&nbsp; In
      theory, any question about the ultimate behavior of any given
      basic instruction can be answered by analyzing its control-pulse
      sequence closely enough, although this can be quite a challenging
      proposition, particularly for complex instructions like <tt>MP</tt>
      or <tt>DV</tt>.&nbsp; For example, when the <tt>DV</tt>
      instruction was defined earlier, certain constraints were placed
      on the dividend vs the divisor, and if those constraints weren't
      satisfied, we merely stated that the results were undefined.&nbsp;
      However, they're not undefined, and you can find out what the
      result <i>should</i> be if you analyze the control-pulse
      sequences.&nbsp; However, CPU simulator does not do that, and you
      cannot expect agreement with the physical AGC in those
      cases.&nbsp; Of course, the danger is that original AGC developers
      could have used their inside knowledge of what should have
      happened, rather than abide by the documented constraints, and
      hard-coded that tribal knowledge into a program like
      Solarium.&nbsp; Well, if they did, then it will make me sad.<br>
    </p>
    <p>Control-pulse sequences are used for more than just basic
      instructions, however.&nbsp; All manner of auxiliary operations
      are coded as control-pulse sequences, and thus occupy CPU time
      when they occur.&nbsp; These include:<br>
    </p>
    <ul>
      <li>Vectoring to interrupts.</li>
      <li>Shifting in digital-uplink data.</li>
      <li>Incrementing timer registers.</li>
      <li>Incrementing or decrementing counter registers.<br>
      </li>
    </ul>
    <p>My focus in this project is to provide useful software simulation
      of the AGC and so, while I consider simulation of the
      control-pulse sequences to be the technically "correct" way of
      creating such a simulation, I also believe that reaching the point
      of having a satisfactory practical understanding of control-pulse
      sequences has a far-steeper learning curve than obtaining a
      practical understanding of basic AGC assembly-language
      programming.&nbsp; Moreover, programming the basic instructions
      much have been what AGC developers did 99% of the time, with
      teasing out control-pulse sequences (or asking an on-site expert
      about them) must have represented very little of their time.&nbsp;
      So from that standpoint, I consider simulating the basic
      instructions themselves, and ignoring control-pulse sequences, to
      be the "correct" overall approach.&nbsp; Your opinion may, of
      course differ.&nbsp; Plus, it never occurred to me to do it that
      way.<br>
    </p>
    <p>The only knowledge of control-pulse sequences you need in order
      to follow the remainder of the discussion on the present page is
      that the control-pulse sequence that increments a CPU counter
      register is called a <tt>PINC</tt>, and one which decrements it
      is called a <tt>MINC</tt>.<br>
    </p>
    <p>If you do want to find out more about control-pulse sequences in
      the Block I AGC, the discussion of them (intermixed with
      discussion of basic instructions) is spread throughout Chapter 3
      of R-393.<br>
      <br>
    </p>
    <hr size="2">
    <h2><a name="Available_Block_1_AGC_Software"
        id="Available_Block_1_AGC_Software"></a>Available Block I AGC
      Software</h2>
    <p>This has been written up in more detail on our Colossus page,
      which is where I advise you to look if you want more
      information.&nbsp; But in summary, what's available to us in the
      way of true Block I for the AGC is the following:<br>
    </p>
    <ul>
      <li>Trivium — A short sample program that simply demonstrated how
        to use the original assembler, YUL.</li>
      <li>Sunrise 45 — The program used for Block I system tests.</li>
      <li>Sunrise 69 — The program <i>later</i> used for Block I system
        tests.</li>
      <li>Corona 261 — Flight software for the unmanned AS-202 mission.<br>
      </li>
      <li>Solarium 55 — Flight software for the unmanned Apollo 4 and 6
        missions.</li>
    </ul>
    <p>What has me pulling out what's left of my hair is the <i>absence</i>
      of Sunspot 247, the flight software for Apollo 1.&nbsp; (If you
      have it, give it to me!)<br>
    </p>
    <p>See also the section on <a
        href="#John_Pultoraks_Assembler_and_Simulator">John Pultorak's
        assembler and simulator</a>.<br>
    </p>
    <hr size="2">
    <h2><a name="Available_Supporting_Software"
        id="Available_Supporting_Software"></a>Available Supporting
      Software</h2>
    <h3><a name="Virtual_AGCs_Assembler_yaYUL"
        id="Virtual_AGCs_Assembler_yaYUL"></a>Virtual AGC's Assembler
      (yaYUL)</h3>
    The Virtual AGC project itself also provides a Block I assembler,
    and it is <a href="yaYUL.html">the same <b>yaYUL</b> assembler
      used for Block II code</a>.&nbsp; The only difference is that you
    add a command-line switch of --block1, but otherwise it operates
    identically, and accepts the full syntax of the Solarium program.<br>
    <h3><a name="CPU_Simulators" id="CPU_Simulators"></a>CPU Simulators</h3>
    <h4><a name="Comparison" id="Comparison"></a>Comparison</h4>
    <p>There are <i>two</i> Block I CPU simulators.&nbsp; Because each
      has its advantages, both are described in more detail in the
      sections dedicated to them that follow.&nbsp; However, a capsule
      comparison is given by the following table.&nbsp;<br>
    </p>
    <table summary="" align="center" cellspacing="2" cellpadding="2"
      border="1">
      <tbody>
        <tr>
          <th valign="top">Feature<br>
          </th>
          <th valign="top">Pultorak Simulator (yaAGC-Block1)<br>
          </th>
          <th valign="top">Virtual AGC Simulator (yaAGCb1)<br>
          </th>
        </tr>
        <tr>
          <td valign="middle"><b>Detailed information</b><b><br>
            </b></td>
          <td valign="middle"><a
              href="#John_Pultoraks_Assembler_and_Simulator">See the
              next section</a><br>
          </td>
          <td valign="middle"><a
              href="#Virtual_AGCs_CPU_Simulator_yaAGCb1">See second
              section after this</a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Design rationale</b><b><br>
            </b></td>
          <td valign="middle">Simulates <a href="#Pulse_Sequences">command-pulse






              sequences</a><br>
          </td>
          <td valign="middle">Simulates <a
              href="#Assembly-Language_Instructions">basic instruction
              set</a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>DSKY?</b><b><br>
            </b></td>
          <td valign="middle">Textual interface only<br>
          </td>
          <td valign="middle">Operates with <a
              href="#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">the simulated
              DSKY</a><br>
          </td>
        </tr>
        <tr>
          <td valign="top"><b>Uplink?</b><br>
          </td>
          <td valign="top">No<br>
          </td>
          <td valign="top">Operates with <a href="yaUplinkBlock1">the
              simulated uplink</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Other peripherals?</b><b><br>
            </b></td>
          <td valign="middle">Text-based interface<br>
          </td>
          <td valign="middle">Has a <a href="developer.html">yaAGC-type
              socket interface</a> or (theoretically) NASSP/Orbiter
            interface for implementation of arbitrary peripheral devices<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Language</b><b><br>
            </b></td>
          <td valign="middle">C++<br>
          </td>
          <td valign="middle">C<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Building the simulator<br>
            </b></td>
          <td valign="middle">Any platform supporting gcc or similar<br>
          </td>
          <td valign="middle">Any platform supporting gcc or similar<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Written by</b><b><br>
            </b></td>
          <td valign="middle">John Pultorak<br>
          </td>
          <td valign="middle">Ron Burkey<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Purpose</b><b><br>
            </b></td>
          <td valign="middle">Intended to support John's development of
            his hardware Block I simulator, running John's port of a
            portion of the Block II program Colossus 249.<br>
          </td>
          <td valign="middle">Intended to intended to integrate into
            Virtual AGC on the same footing as Block II AGC and AEA
            simulators, and specifically to run <a href="Colossus.html">Solarium






              055</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Status</b><b><br>
            </b></td>
          <td valign="middle">Fairly usable.<br>
          </td>
          <td valign="middle">Progressing nicely, but not quite as
            mature as the Pultorak simulator yet.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>The table above refers to the version of John Pultorak's
      simulator which has been ported to gcc and corrected, rather than
      to his original code, which is also available.&nbsp; Both versions
      are discussed in the following section.<br>
    </p>
    <h4><a name="John_Pultoraks_Assembler_and_Simulator"
        id="John_Pultoraks_Assembler_and_Simulator"></a>John Pultorak's
      Assembler and Simulator</h4>
    Preliminary to his <a
      href="Pultorak.html#John_Pultoraks_Block_I_AGC">construction
      project for a hardware simulation of the Block I AGC</a>, or even
    the existence of the Virtual AGC project at all, John Pultorak also
    developed a Block I AGC assembler and Block I AGC software CPU
    simulator as a tool in aiding his development of his hardware
    simulation.&nbsp; The assembler accepts only John's own syntax
    rather than actual Block I program syntax, based on manual entry and
    editing of source code (for example, I believe it does not accept
    Block I interpreter code), and I have nothing further to say about
    it.&nbsp; Editing a 1000-page program for use with it would be
    overwhelming, particularly when there's an alternate assembler (<b>yaYUL</b>)
    that already accepts the full syntax.&nbsp; Rather, my scope here is
    limited to the simulator.<br>
    <br>
    John's original software source code for the simulator, intended to
    be built with Microsoft Visual C++, is <a
      href="Pultorak_files/PultorakAssemblerAndSimulator.zip"> available
      from us</a>.&nbsp; Unfortunately, his source-code files only cover
    his simulator versions through 1.15.&nbsp; Nevertheless, I have
    extracted version 1.16 from the program listing in <a
      href="Pultorak_files/build_agc_7.pdf">his PDF description</a>, and
    it is contained in the Pultorak-Simulator-1.16/ directory of <a
href="https://github.com/virtualagc/virtualagc/tree/master/Pultorak-Simulator-1.16">our






      GitHub repository</a>.<br>
    <br>
    Donna Polehn has also created <a
      href="https://github.com/donnaware/AGC">a kind of Visual C++
      assembler/simulator development environment</a> based on this
    original code, in so far as I understand it, which you may find
    interesting.&nbsp;<br>
    <br>
    Since I don't myself use Visual C++, or even Windows if I can help
    it, John's Visual C++ source code was of no direct use to me.&nbsp;
    I have, however, taken the steps needed to port version 1.16 of
    John's simulator to GNU gcc (g++).&nbsp; Feel free to assume that
    any deficiencies in the user interface are due my porting effort,
    and it's certainly true that I "fixed" things in his program that I
    later had to "fix" back to what John had originally.&nbsp; It's
    perhaps worth noting that my purpose in porting this program was
    primarily to use it as a comparison and sanity check against my own
    simulator, as described in the next section, and so my motivation in
    improving the program's user interface (assuming it needs
    improvement) was lacking.&nbsp; Somebody might find pepping up
    John's original source or my gcc port of it to be an interesting
    exercise.&nbsp; I, however, personally decline this opportunity for
    fun.<br>
    <br>
    Right now, you can find this ported code <a
href="https://github.com/virtualagc/virtualagc/tree/master/yaAGC-Block1-Pultorak">in






      our GitHub repository</a>.&nbsp; I have only worked with it in
    Linux, but I expect it should probably build in Mac OS X or Windows
    (with MinGW/Msys), as long as you have g++ and pthreads
    installed.&nbsp; All you have to do is<br>
    <blockquote> <tt>cd <i>DirectoryContainingTheSource</i></tt><tt><br>
      </tt> <tt>make</tt><br>
    </blockquote>
    The program defaults to loading Solarium055, for which you should
    have Solarium055.bin and Solarium055.lst, and hopefully
    Solarium055.pad, or at least symbolic filesystem links to them, in
    the current directory.&nbsp; The command to run it is simply<br>
    <blockquote> <tt>./yaAGC-Block1 --power</tt><br>
    </blockquote>
    at which point anything else that happens must be controlled by the
    program's internal textual interface.&nbsp; John describes using
    this command set in <a href="Pultorak_files/build_agc_7.pdf">his
      PDF description of the simulator</a>, though my own changes have
    forced changes in the command set as well.&nbsp; The commands I
    personally find useful are:<br>
    <ul>
      <li>m&lt;Enter&gt; — displays a menu of commands.</li>
      <li>n&lt;Enter&gt; — toggles between stepping through
        control-pulses vs stepping through basic instructions.&nbsp;
        (The default is basic instructions.)</li>
      <li>t&lt;Enter&gt; — steps one control pulse or basic instruction.</li>
      <li>v&lt;Enter&gt; — begin a free run of the program.</li>
      <li>u&lt;Enter&gt; — stops a free run of the program.<br>
      </li>
      <li>t<i>N</i>&lt;Enter&gt; — steps <i>N</i> control pulses or
        basic instructions.</li>
      <li>b<i>E</i>&lt;Enter&gt; or b<i>B,O</i>&lt;Enter&gt; — set a
        breakpoint at erasable or fixed-fixed address <i>E</i> (i.e.,
        0000-7777) or fixed address <i>B,O</i> (03,6000 through
        34,7777).&nbsp; All are octal.&nbsp; A "flat" address can also
        be used.&nbsp; Only one breakpoint can be set at any given time.<br>
      </li>
      <li>b — clear a breakpoint if one is set.</li>
      <li>bc<i>N</i>&lt;Enter&gt; — break after a total of <i>N</i> MCT
        (instruction cycles) have elapsed since power-up.</li>
      <li>l&lt;Enter&gt; — (that's a lower-case L) if --log was used on
        the command-line, toggle logging off or on again.</li>
      <li>e<i>N</i>&lt;Enter&gt; — inspect memory words beginning at
        (erasable, fixed-fixed, or flat, but at present not banked)
        address <i>N</i>.</li>
      <li>f&lt;Enter&gt; — toggle source-code display on/off.&nbsp;
        Default is on.</li>
      <li>q&lt;Enter&gt; — quit the program.</li>
    </ul>
    <p>However, this is not necessarily a complete list, even of the
      commands I created for it, so please do use the 'm' command to see
      what additional ones there may be that I've forgotten to list
      here.&nbsp; There are also commands for John's built-in textual
      DSKY, but I don't understand how they work, and I have only used
      the simulator essentially without a DSKY.<br>
    </p>
    <p>There are also command-line options that allow you to do various
      things, such as selecting a different program than Solarium
      055.&nbsp; The program will accept rope files and program-listing
      files created either <b>yaYUL</b> (with the --block1 switch),
      assuming you had some Block I program other than Solarium to work
      with, or else as produced by John's own assembler.&nbsp; A <b>yaYUL</b>
      command like the following<br>
    </p>
    <blockquote> <tt>yaYUL --block1 --unpound-page MAIN.agc &gt;</tt><tt><i>program</i></tt><tt>.lst<br>
        mv MAIN.agc.bin <i>program</i>.bin<br>
      </tt> </blockquote>
    would produce the necessary files, which could then be run in the
    simulator as follows:<br>
    <blockquote>
      <p><tt>./yaAGC-Block1 --power --rope=<i>program</i></tt><br>
      </p>
    </blockquote>
    As far as John's own sample Block I program (agc.bin + agc.lst),
    which he manufactured manually from portions of Colossus 249, it
    will actually no longer run properly in this ported version of the
    simulator, even though the simulator accepts output from John's
    assembler.&nbsp; JThat would require the use of John's original
    Visual C++ code.<br>
    <br>
    The reason for this is that the program has not merely been ported
    from Visual C++ to gcc, but also corrected in a variety of ways, and
    these corrections prevent John's original code from running,
    although the changes needed to make it run seem fairly
    trivial.&nbsp; The <i>reason</i> that the corrections were needed
    do not reflect on John, or on anybody, but are just an unfortunate
    fact of life.&nbsp; Specifically, at the time John created his
    project, the principal (only?) written documentation he had to work
    from was <a href="#Available_Documentation">Instrumentation Labs
      document R-393</a>, which was itself inaccurate in a number of
    ways.&nbsp; As the document itself points out in its Preface,<br>
    <blockquote> <small>"... Fine detail and internal consistency have
        been under-emphasized for the sake of promptness so that this
        report could be written within a few weeks of the inception of
        the design."</small><br>
    </blockquote>
    In other words, they had to get it done and get it into service
    quickly, and didn't have time fix every little thing in it.&nbsp;
    Moreover, there was no available sample of Block I software of any
    kind for John to work with.&nbsp; In fact, as he himself says, the
    sole sample of AGC code he had, the Block II program Colossus 249,
    was itself not complete, and was merely a fragment.&nbsp; So all
    things considered, it is remarkable that he got any of it to work at
    all, and the fact that there are some errors is inevitable.&nbsp;
    But those errors are more than enough to prevent John's original
    code from running on a corrected version of his simulator.<br>
    <br>
    The reason I am pointing this out is to provide you with a warning,
    should you decide to forego the corrected, gcc version of the
    program, and instead revert to John's original Visual C++
    simulator.&nbsp; None of the corrections for the problems I've been
    mentioning have been back-ported to the Visual C++ version of the
    program.&nbsp; It might be an interesting exercise for somebody to
    indeed backport these changes.&nbsp; The most-significant problems
    were:
    <ol>
      <li>The memory model is undersized:&nbsp; the amount of fixed rope
        memory in the device was increased after R-393 was written, from
        the 12 banks to 24 banks, and Solarium 055 will in fact not fit
        into 12 banks.</li>
      <li>The (corrected) interrupt-vector table is at address 2000, and
        the entry point for the program is at 2030.&nbsp; In the
        original version of the program, however, they are at 2004 and
        2000, respectively.</li>
      <li>Timer registers (TIME1, 2, 3, and 4) increment at 10× the
        speed they're supposed to. Specifically, TIME1, 3, and 4, which
        are supposed to increment every 10 ms., actually increment every
        1 ms. TIME2, which is triggered by overflow in TIME1, increments
        every 16.384 seconds rather than every 163.84 seconds as it's
        supposed to.</li>
      <li>Okay, I admit I'm not too sure about this one ... but the sim
        seems to integrate parity bits everywhere.&nbsp; That gave me a
        lot of trouble, so I simply disabled it.<br>
      </li>
      <li>Bit assignments in output-register OUT1 (only OUT0-OUT1, of
        OUT0-OUT4 are implemented) are not correct. They unfortunately
        had to be taken from the bit assignments of the Block II output
        register of the same name, but those do not correspond to the
        Block I computers. (The corresponding OUT0 registers in Block I
        and Block II do, however, correspond perfectly to each other!)</li>
    </ol>
    A remarkably short list of problems, but nevertheless a list in
    which one would encounter difficulties <i>immediately</i> in trying
    to run actual Block I software ... as indeed I did.&nbsp;<br>
    <br>
    Here is the full syntax at present for using the gcc port of John's
    simulator:<br>
    <blockquote> <tt>yaAGC-Block1 [<i>OPTIONS</i>]<br>
      </tt> </blockquote>
    where the available options are:<br>
    <ul>
      <li>--go=<i>address</i>, where the <i>address</i>, in octal, is
        the location of the AGC program's entry point.&nbsp; This is
        always 02030, and that's the default, but the option is present
        for legacy reasons, because the program originally used a
        starting address of 02000.&nbsp; However, this option is never
        needed for a true Block I program.</li>
      <li>--rope=<i>basename</i>.&nbsp; The program expects by default
        to find the rope file Solarium055.bin and the assembly-listing
        file Solarium055.lst (both created by the yaYUL assembler) in
        the current working directory, as well as the Solarium055.pad
        file (generally created by manual editing).&nbsp; The latter two
        are actually optional, but should be present for fully
        functionality, whereas the former two could theoretically have
        been produced by John's assembler rather than by yaYUL.&nbsp; In
        any case, <i>basename</i> could be changed from the default
        "Solarium055" to some other string, if another Block I program
        becomes available some day.</li>
      <li>--log=<i>filename</i>.&nbsp; Instructs the assembler to create
        a log file that traces the AGC program's execution.&nbsp; By
        default, there is no log file.</li>
      <li>--extra=<i>address</i>.&nbsp; Instructs the simulator to add
        the contents of the memory location at the flat-address <i>address</i>
        to its log file.<br>
      </li>
      <li>--power.&nbsp; Instructs the program to automatically issue
        the 'p', 'r', and 't' commands upon entry.&nbsp; What this does
        is to set up the simulator's debugging facility to start out
        treating the AGC program as a set of assembly-language
        instructions, whereas by default it would instead treat it as a
        set of command-pulse sequences.&nbsp; Unless you are trying to
        debug the simulator itself, as opposed to the AGC program that
        the simulator is running, the former is what's desired, and thus
        --power should almost always be used.</li>
      <li>--zero.&nbsp; Instructs the simulator to automatically zero
        out all erasable memory before running the AGC program.&nbsp;
        This is the default behavior.<br>
      </li>
      <li>--uinint.&nbsp; Instructs the simulator to automatically fill
        all erasable memory with the illegal value 0166666 before
        running the AGC program. In general, if the pad-load file (by
        default Solarium055.pad) is constructed correctly, there should
        be no behavioral difference in the AGC program between --zero
        and --uninit.&nbsp; However, --uninit is helpful in determining
        of the AGC program is accessing uninitialized erasable memory.<br>
      </li>
    </ul>
    <h4><a name="Virtual_AGCs_CPU_Simulator_yaAGCb1"
        id="Virtual_AGCs_CPU_Simulator_yaAGCb1"></a>Virtual AGC's CPU
      Simulator (yaAGCb1)</h4>
    <p>My own Block I simulator is written independently of <a
        href="#John_Pultoraks_Assembler_and_Simulator">John Pultorak's</a>,
      and no code from John's has been reused in mine, nor served as a
      model for mine.&nbsp; That isn't intended to imply that John's
      program was not used, or that there is great flaw that prevents it
      from being used.&nbsp; In fact, I used it <i>extensively</i> as a
      cross-check on the functioning of mine, with the intention of
      being able to run the two side-by-side, and have them match up
      register-for-register, instruction-for-instruction, on a
      cycle-by-cycle basis.&nbsp; Sometimes this revealed errors in
      John's simulator, which I corrected.&nbsp; Other times, it
      revealed bugs in mine, which I corrected.&nbsp; Often, there were
      just differences I hadn't anticipated, usually involving
      arithmetical overflow bits that got written into registers I
      hadn't expected; in which case, when they were reasonable even if
      unexpected, I did what checking I could but almost always adopted
      John's approach in place of my own.<br>
    </p>
    <p>So the upshot of that is that these programs now behave
      essentially identically.<br>
    </p>
    <p>Then why have two (other than the obvious advantage of being able
      to cross-check one against the other ... though one shouldn't
      underestimate the great advantage of being able to do that)?&nbsp;
      Well, it mainly has to do with the fact that the CPU simulator has
      to be able to integrate with other Virtual-AGC style peripheral
      devices, such as simulated DSKYs, to be able to participate in the
      GUI code::blocks style debugging capabilities that other Virtual
      AGC simulators have, and so on, and after investigating it I just
      thought it was cleaner and simpler to start from scratch in doing
      so, given the programming style I personally preferred to
      use.&nbsp; Obviously, others' opinions may differ, and the
      problems I perceived I was solving could easily be more in my mind
      than in John's program.<br>
    </p>
    <p>You can find code for my new simulator <a
        href="https://github.com/virtualagc/virtualagc/tree/master/yaAGCb1">in
our






        GitHub repository</a>.&nbsp; I have only worked with it in
      Linux, but I expect it should probably build in Mac OS X or
      Windows (with MinGW/Msys), as long as you have g++ and pthreads
      installed.&nbsp; All you have to do is<br>
    </p>
    <blockquote> <tt>cd <i>DirectoryContainingTheSource</i></tt><tt><br>
      </tt> <tt>make</tt><br>
    </blockquote>
    The program defaults to loading Solarium055, for which you should
    have Solarium055.bin and Solarium055.lst, and preferably
    Solarium055.pad as well, or at least symbolic filesystem links to
    them, in the current directory.&nbsp; The command to run it is
    simply<br>
    <blockquote> <tt>./yaAGCb1</tt><br>
    </blockquote>
    at which point anything else that happens must be controlled by the
    program's primitive textual-debugging interface, <a
      href="Block1.html#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">the
      simulated DSKY interface</a>, or <a href="#yaUplink">the
      simulated digital uplink</a>.&nbsp; The program's textual
    debugging interface is indeed <i>extremely</i> primitive.&nbsp; The
    only existing commands at the moment are:<br>
    <ul>
      <li>m&lt;Enter&gt; (or actually any unrecognized command) —
        displays a menu of available commands.<br>
      </li>
      <li>t&lt;Enter&gt; — steps one control pulse or basic instruction.</li>
      <li>t<i>N</i>&lt;Enter&gt; — steps <i>N</i> control pulses or
        basic instructions.</li>
      <li>e<i>N</i>&lt;Enter&gt; or e<i>B,O</i>&lt;Enter&gt; — examine
        the memory at the specified address, and for a few addresses
        following it.</li>
      <li>e<i>N</i>=<i>V</i>&lt;Enter&gt; or e<i>B,O</i>=<i>V</i>&lt;Enter&gt;
—






        set the value of an erasable-memory location (including
        registers, i/o ports, timers, and counters) or fixed-memory
        location.&nbsp; The value can be 16-bit even though most of
        these locations are in principle 15-bit only.<br>
      </li>
      <li>b<i>N</i>&lt;Enter&gt; or b<i>B,O</i>&lt;Enter&gt; — set a
        breakpoint or watchpoint at an address.&nbsp; Up to 16
        breakpoints are allowed.<br>
      </li>
      <li>bc<i>N</i>&lt;Enter&gt; — break after a total of <i>N</i> MCT
        (instruction cycles) have elapsed since power-up.</li>
      <li>be&lt;Enter&gt; — break after a any read access to an
        uninitialized erasable.</li>
      <li>b&lt;Enter&gt; — remove all breakpoints.</li>
      <li>b?&lt;Enter&gt; — list all breakpoints.</li>
      <li>l&lt;Enter&gt; — (that's a lower-case L) if --log was used on
        the command-line, toggle logging off or on again.</li>
      <li>q&lt;Enter&gt; — quit the program.</li>
    </ul>
    One useful capability that both of the CPU simulators (Pultorak and
    Virtual AGC) have is to be able to produce a log file <i>in
      identical formats</i> of the cycle-by-cycle program
    execution.&nbsp; This allows easy comparison for discrepancies with
    programs like diff or <a href="http://meldmerge.org/">meld</a>, or
    any of a number of others.&nbsp; The steps in either simulator are
    the same:<br>
    <ol>
      <li>Run the simulator with a command-line switch "--log=<i>FILENAME</i>".</li>
      <li>Execute identical portions of the code in the simulator, for
        example with "t2000" to execute 2000 assembly-language
        instructions.</li>
      <li>Quit the simulator ("q").</li>
    </ol>
    <p>This capability is enhanced with the 'bc<i>N</i>' and 'l'
      commands, since those may allow you to avoid adding a large amount
      of information to the log when you know in advance that it will be
      identical.<br>
    </p>
    <p>Here is the full syntax at present for using the my Block I
      simulator is:<br>
    </p>
    <blockquote> <tt>yaAGCb1 [<i>OPTIONS</i>]<br>
      </tt> </blockquote>
    where the available options are:<br>
    <ul>
      <li>--go=<i>address</i>, where the <i>address</i>, in octal, is
        the location of the AGC program's entry point.&nbsp; This is
        always 02030, and that's the default, but the option is present
        for legacy reasons, because the simulator originally used a
        starting address of 02000.&nbsp; However, this option is never
        needed for a true Block I program.</li>
      <li>--rope=<i>filename</i>.&nbsp; The simulator expects by default
        to find the rope file Solarium055.bin in the current working
        directory, but this option allows you to change that filename.</li>
      <li>--listing=<i>filename</i>.&nbsp; The simulator expects by
        default to find the assembly-listing file Solarium055.lst in the
        current working directory, but this option allows you to change
        that filename.</li>
      <li>--pads=<i>filename</i>.&nbsp; The simulator expects by default
        to find the pad-load file Solarium055.pad in the current working
        directory, but this option allows you to change that filename.</li>
      <li>--run.&nbsp; By default the simulator immediately pauses the
        AGC program at its first instruction, and drops into an
        interactive textual-debugging mode.&nbsp; With this option, you
        can simply cause the simulator to begin running the AGC program
        without pausing.<br>
      </li>
      <li>--log=<i>filename</i>.&nbsp; Instructs the assembler to create
        a log file that traces the AGC program's execution.&nbsp; By
        default, there is no log file.</li>
      <li>--extra=<i>address</i>.&nbsp; Instructs the simulator to add
        the contents of the memory location at the flat-address <i>address</i>
        to its log file.<br>
      </li>
      <li>--zero.&nbsp; Instructs the simulator to automatically zero
        out all erasable memory before running the AGC program.&nbsp;
        This is the default behavior.<br>
      </li>
      <li>--uinint.&nbsp; Instructs the simulator to automatically fill
        all erasable memory with the illegal value 0166666 before
        running the AGC program. In general, if the pad-load file (by
        default Solarium055.pad) is constructed correctly, there should
        be no behavioral difference in the AGC program between --zero
        and --uninit.&nbsp; However, --uninit is helpful in determining
        of the AGC program is accessing uninitialized erasable memory.</li>
      <li>--port=<i>portnum</i>.&nbsp; By default, the simulator listens
        on TCP ports 19671-19680 for connection attempts by virtual
        peripherals like the simulated DSKY or simulated digital
        uplink.&nbsp; This option allows you to change the starting
        address of that range.&nbsp; In case it is not obvious, 19671
        refers to the Apollo 1 tragedy, which occurred on January 27,
        1967, and thus is a kind of memoriam for the crew of Apollo
        1.&nbsp; Apollo 1 and Apollo 2, if either had ever flown, would
        have flown with Block I AGCs.</li>
    </ul>
    <h4><a name="Status_of_yaAGCb1" id="Status_of_yaAGCb1"></a>Status of
      yaAGCb1</h4>
    <p>I have not fully completed <b>yaAGCb1</b> in the sense that <b>yaAGC</b>
      is complete, and thus wouldn't expect it to fully work if
      integrated into a full spacecraft simulator.&nbsp; While I don't
      have a complete list at the moment of what works and what doesn't,
      nor have all the parts of <b>yaAGCb1</b> that I <i>think</i>
      work been fully tested, I can definitely say that I've not yet
      bothered with the following:<br>
    </p>
    <ul>
      <li>I have not hooked up simulated input signals to the CPU's
        counter registers (CDU, PIPA, etc.)<br>
      </li>
    </ul>
    <h3><a name="Virtual_AGCs_DSKY_Simulator_yaDSKYb1"
        id="Virtual_AGCs_DSKY_Simulator_yaDSKYb1"></a>Virtual AGC's DSKY
      Simulator (yaDSKYb1)</h3>
    There are two versions of the simulated DSKY, corresponding to <a
      href="#DSKY">the control-panel and nav-bay versions of the
      physical DSKY as described earlier</a>, but both are available
    from the same yaDSKYb1 program, with different command-line
    options.&nbsp; The code resides in the same yaDSKYb1/ directory <a
href="https://github.com/virtualagc/virtualagc/tree/master/yaDSKYb1">in
      our GitHub repository</a>.<br>
    <br>
    Building this software is simply a matter of cd'ing into its source
    directory and running 'make'. <i>&nbsp;</i> There are a number of
    graphical images which the program needs to use as resources in
    order to work properly, and by default these are found in the
    images/ sub-directory of the same directory in which yaDSKYb1 is
    being run from, and finding these images is likely the principal
    problem the program will have in trying to run, but you can specify
    the directory on the command line:<br>
    <blockquote> <tt>cd <i>ParentDirectoryOfyaDSKYb1</i>/<br>
        yaDSKYb1/yaDSKYb1main [--images=<i>DIRECTORY</i>] [--port=<i>PORTNUM</i>]
        [--nav-bay]<br>
      </tt> </blockquote>
    The value for <tt><i>PORTNUM</i></tt> depends on the range of TCP
    ports on which yaAGCb1 is listening, but the default value of 19671
    is usually satisfactory.<br>
    <br>
    Unlike the Block II AGC, there are not separate i/o ports (i.e., IN<i>n</i>
    and OUT<i>n</i> registers) in the AGC for the control-panel and
    nav-bay DSKYs, so I'm not sure how the Block I AGC connected to more
    than one DSKY at a time.<br>
    <h3><a name="yaUplinkBlock1" id="yaUplinkBlock1"></a>Virtual AGC's
      Digital Uplink Simulator (yaUplinkBlock1)</h3>
    <p>At present, a program called yaUplinkBlock1 is provided (in the
      similarly-named source-code directory <a
href="https://github.com/virtualagc/virtualagc/tree/master/yaUplinkBlock1">in






        our GitHub repository</a>. It is a simple command-line program,
      in which you can type (or feed in from a script) ASCII mnemonics
      for DSKY keys, which the program then converts to the proper
      uplink format and sends to the Block I AGC simulator.<br>
    </p>
    <p>The ASCII mnemonics for the various DSKY keys, rather
      straightforwardly, are:<br>
    </p>
    <ul>
      <li>' ' is a "blank" or no key pressed.</li>
      <li>'0'-'9' are the keys 0-9.</li>
      <li>'+' and '-' are the plus and minus keys.<br>
      </li>
      <li>'v' is the VERB key.</li>
      <li>'n' is the NOUN key.</li>
      <li>'c' is the CLEAR key.</li>
      <li>'r' is the ERROR RESET key.</li>
      <li>'k' is the KEY RLSE key.</li>
      <li>&lt;Enter&gt; is the ENTER key.</li>
    </ul>
    <p>Thus, entering "v36&lt;Enter&gt;" in yaUplinkBlock1 is equivalent
      to V36E on the DSKY keypad.<br>
    </p>
    <p>The full command-line syntax is</p>
    <blockquote>
      <p><tt>yaUplinkBlock1 [--port=<i>PORTNUM</i>] [--batch]</tt><br>
      </p>
    </blockquote>
    <p>The --port setting, of course, changes the default TCP port
      (19675) of the uplink program.&nbsp; By default, yaUplinkBlock1 is
      suitable for accepting input interactively from a computer
      keyboard, but not from a (say) a script.&nbsp; The --batch switch
      flips that around, so that (for example) with the --batch switch
      you could do something like the following if you wanted to:<br>
    </p>
    <blockquote>
      <p><tt>echo "v11n16" | yaUplinkBlock1 --batch</tt><br>
      </p>
    </blockquote>
    <h2><a name="Taking_Solarium_for_a_Spin"
        id="Taking_Solarium_for_a_Spin"></a>Taking Solarium for a Spin</h2>
    Here are a few things you can do with Block I, without firing up
    Orbiter+NASSP.<br>
    <br>
    To start a simulation running SOLARIUM, you can use the VirtualAGC
    GUI:&nbsp; Just select Apollo 4 or 6 and hit "RUN".&nbsp; From this
    point, you can now interact with the AGC, running Solarium, entirely
    through the DSKY.&nbsp; There is kind of a dilemma, though, in that
    the references for the kinds of things you <i>can</i> do with
    Solarium are pretty sparse, or at least haven't yet reached <i>me</i>.&nbsp;
    You have a few choices, if you want to explore them on your own:<br>
    <ol>
      <li><a href="hrst/archive/1721.pdf">R-467, The Compleat Sunrise</a>
        briefly covers what was available in the Block I SUNRISE program
        (September 1964).&nbsp;<br>
      </li>
      <li>You can pick through <a
          href="listings/Solarium055/ASSEMBLY_AND_OPERATION_INFORMATION.agc.html">
          the Solarium 055 source code</a> (April 1968), to try and
        figure out what's available.</li>
      <li>You can look at the available documentation for Colossus 237
        (December 1968), though considering that Colossus 237 was a
        Block II program and Solarium a Block I program, it's unclear
        how much similarity we can expect to see.<br>
      </li>
    </ol>
    Unfortunately you <i>cannot</i> get useful Solarium-related
    information from <a href="Pultorak_files/build_agc_1.pdf">John
      Pultorak's meticulously-crafted Block I documents and
      demonstration</a> ... the problem being, you see, that John had no
    Block I software to use as a model, and hence based his Block I
    hardware simulation on Block II AGC software, namely Colossus 249,
    which is later even than Colossus 237.&nbsp; But your mileage may
    vary, and it doesn't hurt to look if you like.&nbsp; As a practical
    option I fear that choice number 2 (picking through the Solarium
    source code) is really the best place to start at the present time.<br>
    <br>
    But anyway, assuming you have started the simulation as indicated
    above, I do know enough to tell you how to do a few things with it:<br>
    <br>
    <table summary="" cellspacing="2" cellpadding="2" border="1"
      width="100%">
      <tbody>
        <tr>
          <td valign="middle"><a href="block1-demo/startup.jpg"><img
                alt="Click to enlarge" src="block1-demo/thm-startup.jpg"
                height="200" border="2" width="198"></a><br>
          </td>
          <td valign="middle">Startup screen, immediately after starting
            simulation.<br>
          </td>
          <td valign="middle">Actually, this is not really the first
            thing you see, but just the first screen that persists long
            enough to take a screenshot of it.&nbsp;<br>
            <br>
            At first, it will really show "PROGRAM 00" rather than
            "PROGRAM 77", because the AGC is in "major mode" 00.&nbsp;
            What has happened, however, is that on power-up the AGC
            hasn't been able to detect any Inertial Measurement Unit
            (IMU), because we don't have a simulation for one hooked up
            to it!&nbsp; Detecting this condition, a specific AGC
            program called the "Night Watchman" has detected this
            condition and decided to flip over to major mode 77 ...
            which isn't documented, as far as I can tell, and none of
            the original AGC developers I've contacted remember it,
            including Jim Kernan, who was Solarium's "rope mother".<br>
            <br>
            Of the other items displayed, "VERB 05" is an "octal display
            of data" while "NOUN 31" indicates that the data being
            displayed is "Failreg", the failure register.&nbsp; The
            5-digit displays, I believe, are the last three error
            conditions reported, of which only one, 00203 actually has
            an error code in it.&nbsp; Thus, you are seeing "Alarm
            00203".&nbsp; According to <a
              href="listings/Solarium055/ASSEMBLY_AND_OPERATION_INFORMATION.agc.html">
              the source code</a>, alarm 00203 is "NO IMU MODE INDICATED
            TO COMPUTER".<br>
            <br>
            The IMU mode is communicated to the AGC through its input
            register IN2, I believe, which is all zeroes at this point,
            given that there is no IMU, and all zeroes is not recognized
            as a legitimate IMU mode.<br>
          </td>
          <td valign="middle"><a href="block1-demo/startup-nav.jpg"><img
                alt="" src="block1-demo/thm-startup-nav.jpg"
                height="300" border="2" width="90"></a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><a href="block1-demo/V36E.jpg"><img
                alt="Click to enlarge" src="block1-demo/thm-V36E.jpg"
                height="200" border="2" width="198"></a><br>
          </td>
          <td valign="middle">V36E<br>
          </td>
          <td valign="middle">No problem.&nbsp; Let's use V36E, "Fresh
            Start".&nbsp; It doesn't get rid of the Alarm 00203 message,
            but at least it does put us into major mode 00, as we're
            entitled, I expect.<br>
          </td>
          <td valign="middle"><a href="block1-demo/V36E-nav.jpg"><img
                alt="" src="block1-demo/thm-V36E-nav.jpg" height="300"
                border="2" width="90"></a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><a href="block1-demo/V32EV32EV32E.jpg"><img
                alt="Click to enlarge"
                src="block1-demo/thm-V32EV32EV32E.jpg" height="200"
                border="2" width="198"></a><br>
          </td>
          <td valign="middle">V32EEE</td>
          <td valign="middle">I don't actually know how to get rid of
            that Failreg display, short of instructing the AGC to
            display something else ... or we could use V32E, "Bump
            displays", i.e., scroll the register display downward.&nbsp;
            To get rid of all 3 error codes, we have to do it three
            times.<br>
          </td>
          <td valign="middle"><a href="block1-demo/V32EV32EV32E-nav.jpg"><img
                alt="" src="block1-demo/thm-V32EV32EV32E-nav.jpg"
                height="300" border="2" width="90"></a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><a href="block1-demo/thm-V31N02E.jpg"><img
                alt="Click to enlarge" src="block1-demo/thm-V31N02E.jpg"
                height="200" border="2" width="198"></a><br>
          </td>
          <td valign="middle">V31N02E<br>
          </td>
          <td valign="middle"> We could use V32N02E to let us display
            the contents of the AGC's memory.&nbsp; What you see if you
            use this command is that the "REGISTER 3" display clears,
            and we can enter an octal address.&nbsp; These addresses are
            what I personally call "flat" addresses, though I think
            there may be some official buzzword for it that I don't
            recall at the moment.&nbsp; With flat addresses, the entire
            AGC memory space is simply a continuous one from octal
            addresses 000000 through 071777, where<br>
            <ul>
              <li>000000-001777 is erasable memory.</li>
              <li>002000-005777 are "fixed-fixed" memory.</li>
              <li>006000-007777 is bank 03</li>
              <li>010000-011777 is bank 04</li>
              <li>...</li>
              <li>070000-071777 is bank 34.</li>
            </ul>
            <p>So if, for example, I now entered 12345E (into the open
              space for REGISTER 3), what I <i>should</i> get is the
              contents of 05,6345, which a quick check of Solarium's
              assembly listing reveals to be 03136.&nbsp; And amazingly,
              that's what the DSKY shows in REGISTER 1 as well.<br>
            </p>
            <p>At this point, you can actually keep examining as many
              memory locations as you like, just by pressing ENTER, then
              a new octal address, and then ENTER again.&nbsp; It
              doesn't seem to work for registers, though.&nbsp; Perhaps
              the address should be kept at 060 or higher.<br>
            </p>
          </td>
          <td valign="middle"><a href="block1-demo/V31N02E-nav.jpg"><img
                alt="" src="block1-demo/thm-V31N02E-nav.jpg"
                height="300" border="2" width="90"></a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><a href="block1-demo/V16N65E.jpg"><img
                alt="Click to enlarge" src="block1-demo/thm-V16N65E.jpg"
                height="200" border="2" width="199"></a><br>
          </td>
          <td valign="middle">V16N65E<br>
          </td>
          <td valign="middle"> Or perhaps, we might want to display the
            time since startup.&nbsp; V16, " Monitor (in decimal) all
            component (s) of", combined with N65E, "Time (Hours and
            Seconds)", does the trick.&nbsp;<br>
            <br>
            The terse descriptions of the verbs and nouns from resources
            like R-467 make it a bit tough to figure out what we're
            actually seeing on the DSKY's display, but you can figure it
            out with a little bit of cogitation:<br>
            <ul>
              <li>REGISTER 1:&nbsp; The time, in decimal, in units of
                1/100 hours.&nbsp; Therefore, it increments every
                3600/100=36 seconds.</li>
              <li>REGISTER 2:&nbsp; The time, in decimal, in units of
                1/100 seconds.&nbsp; According to R-393, it should be
                updating every 1/2 second, but it's pretty clear that
                it's updating once per second instead.&nbsp;&nbsp; Since
                it only goes up to +99999, obviously we expect it to
                wrap around to +00000 every 1000 seconds.<br>
              </li>
            </ul>
          </td>
          <td valign="middle"><a href="block1-demo/V16N65E-nav.jpg"><img
                alt="" src="block1-demo/thm-V16N65E-nav.jpg"
                height="300" border="2" width="90"></a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><a href="block1-demo/V15N31Eetc.jpg"><img
                moz-do-not-send="true"
                src="block1-demo/thm-V15N31Eetc.jpg" title="Click to
                enlarge" alt="" height="202" border="2" width="200"></a><br>
          </td>
          <td valign="middle">V15N31E<br>
            V21N27E 77777E<br>
            KEY REL<br>
          </td>
          <td valign="middle"><a name="SelfTest"></a>Or, if you were
            crazy — but you <i>are</i> reading this page, so what does
            that say about you? And I'm writing it, so what does that
            say about me? — you could manually start SOLARIUM's built-in
            self-test program.&nbsp; <br>
            <br>
            If an error is detected, it shows up in REGISTER 2.&nbsp;
            REGISTER 2 holds 00000 if no failure has been detected,
            whereas otherwise it holds the address in AGC memory <i>immediately
              following</i> the point at which the self-test code
            detected the failure.&nbsp; To interpret what that means you
            have to actually look at <a moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/listings/Solarium055/AGC_SELF-CHECK.agc.html">the
              assembly listing of SOLARIUM's self-test code</a>.&nbsp;
            Horrifying!<br>
            <br>
            For example, if REGISTER 2 held 0630<u>5</u>, you'd look for
            the address 0630<u>4</u>&nbsp; (actually 11,6304) in the
            self-test code, and you'd find out that it was an error in
            the check of the <code>DV</code> (divide) instruction,
            because you'd find this:<br>
            <pre>                                              ...<br>010382,000238: 11,6244           36557        DVCHK              CAF      SCON3/8                               <br>010383,000239: 11,6245           50001                           TS       Q                                     <br>010384,000240: 11,6246           34502        DV++               CAF      SCON1/4                               <br>010385,000241: 11,6247           25777                           INDEX    5777                                  <br>010386,000242: 11,6250           50001                           5        Q                                     #  C(A) = 25252, CHECKS RSC PULSE<br>010387,000243: 11,6251           51771                           TS       SKEEP1                                <br>010388,000244: 11,6252           30003                           XCH      LP                                    <br>010389,000245: 11,6253           51772                           TS       SKEEP2                                <br>010390,000246: 11,6254           40001        DV+-               CS       Q                                     #  +1/4<br>010391,000247: 11,6255           25777                           INDEX    5777                                  <br>010392,000248: 11,6256           56560                           5        SCON-3/8                              #  C(A) = 52525<br>010393,000249: 11,6257           61771                           AD       SKEEP1                                #  C(A) = -0<br>010394,000250: 11,6260           51775                           TS       SKEEP5                                #  SHOULD BE -0<br>010395,000251: 11,6261           30003                           XCH      LP                                    <br>010396,000252: 11,6262           51773                           TS       SKEEP3                                <br>010397,000253: 11,6263           30001        DV--               XCH      Q                                     #  -1/4<br>010398,000254: 11,6264           25777                           INDEX    5777                                  <br>010399,000255: 11,6265           56560                           5        SCON-3/8                              #  C(A) = 25252<br>010400,000256: 11,6266           51771                           TS       SKEEP1                                <br>010401,000257: 11,6267           30003                           XCH      LP                                    <br>010402,000258: 11,6270           51774                           TS       SKEEP4                                <br>010403,000259: 11,6271           30001        DV-+               XCH      Q                                     #  -1/4<br>010404,000260: 11,6272           25777                           INDEX    5777                                  <br>010405,000261: 11,6273           56557                           5        SCON3/8                               <br>010406,000262: 11,6274           61771                           AD       SKEEP1                                #  C(A) = -0<br>010407,000263: 11,6275           51771                           TS       SKEEP1                                <br>010408,000264: 11,6276           40003                           CS       LP                                    #  C(A) = 37776<br>010409,000265: 11,6277           61771                           AD       SKEEP1                                #  C(A) = 37776<br>010410,000266: 11,6300           61772                           AD       SKEEP2                                #  C(A) = 37777<br>010411,000267: 11,6301           61773                           AD       SKEEP3                                #  C(A) = -0<br>010412,000268: 11,6302           61774                           AD       SKEEP4                                #  C(A) = +1<br>010413,000269: 11,6303           61775                           AD       SKEEP5                                #  C(A) = +1<br>010414,000270: 11,630<u>4</u>           06033                           TC       -ONECHK    -1                         <br>                                              ...<br></pre>
            <p>User friendly?&nbsp; No!&nbsp; But very fine-grained. And
              obviously not very instructive unless you can make the
              self-test fail somehow!&nbsp; But that's not going to
              happen unless our Block I AGC emulator itself fails.&nbsp;
              And the only way you could make it fail is to modify the
              source-code of the Block I emulator (yaAGCb1)!&nbsp; Which
              wouldn't be my recommendation.&nbsp; (Actually, I tell a
              lie:&nbsp; If you used yaAGCb1's built-in debugger, you
              could introduce errors at will without modifying yaAGCb1's
              source code.&nbsp; I'll leave this as an exercise for the
              advanced student.)<br>
            </p>
            <p>But I can say that the self-test has revealed errors in
              the past, resulting in the correction of bugs in the
              emulator, so the emulator would not be what it is today
              without SOLARIUM's self-test.&nbsp; On the other hand,
              I'll also point out that SOLARIUM's isn't the only Block I
              test code available, and there are more-comprehensive
              tests than those in SOLARIUM in the Block I program called
              SUNRISE.&nbsp; SUNRISE flew in no missions, as its purpose
              in life was to act as a test suite.&nbsp; So as an
              alternative demo of Block I, you could run SUNRISE 69
              rather than SOLARIUM.&nbsp; <a moz-do-not-send="true"
                href="Colossus.html#SUNRISE">Some or all of the tests
                available in SUNRISE 69 are listed here</a>.&nbsp; (Read
              <i>both</i> the SUNRISE 45 and SUNRISE 69 blurbs!)<br>
            </p>
          </td>
          <td valign="middle"><a href="block1-demo/V15N31Eetc-nav.jpg"><img
                moz-do-not-send="true"
                src="block1-demo/thm-V15N31Eetc-nav.jpg" alt=""
                height="300" border="2" width="89"></a><br>
          </td>
        </tr>
      </tbody>
    </table>
    <p><br>
    </p>
    <hr style="width: 100%; height: 2px;"> <br>
    <center> <br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">Creative
Commons






          No Rights Reserved License</a></span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-08-26.<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" height="100" width="300"></a><br>
        </font></i> </center>
    <br>
  </body>
</html>
