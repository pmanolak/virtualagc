<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    
<title>XPL and XPL/I Development Tools</title>


    
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    
<meta name="Author" content="Ronald Burkey">


    
<link rel="icon" type="image/png" href="favicon.png">


    
<meta name="author" content="Ronald S. Burkey">


    
<script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    
<script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","XPL/I and XPL Development Toolchain").replace("@SUBTITLE@","Contemporary and Modern"))
</script><br>


    



    
<h1>Table of Contents </h1>


    
<ul>


      <li><a moz-do-not-send="true" href="#Introduction">Introduction</a></li>
<li><a moz-do-not-send="true" href="#WhyXPLI">XPL/I Versus Standard XPL</a></li>
<li><a moz-do-not-send="true" href="#XCOMI">XCOM-I</a></li>
<li><a moz-do-not-send="true" href="#Installation">Installation of XCOM-I<br>
</a></li>
<ul>
  <li><a moz-do-not-send="true" href="#Linux">Linux or Mac OS<br>
    </a></li>
  <li><a moz-do-not-send="true" href="#Windows">Windows Specific</a></li>
  <li><a moz-do-not-send="true" href="#testTheInstallation">Testing the Installation</a></li>
</ul>
<li><a moz-do-not-send="true" href="#sim360">Emulating the IBM System/360 CPU</a></li>
<li><a moz-do-not-send="true" href="#compilingXCOM">Insane Bootstrapping!</a></li>
<li><a moz-do-not-send="true" href="#halsfc">How to Build HAL/S-FC</a></li>
<li><a moz-do-not-send="true" href="#xpli">The Peculiarities of Standard XPL and Intermetrics XPL/I</a><br>
</li>
<li><a moz-do-not-send="true" href="#programOptions">Program Options</a></li>
<li><a moz-do-not-send="true" href="#builtin">Built-In Runtime-Library Functions</a></li>
<li><a moz-do-not-send="true" href="#monitor">The MONITOR Built-In Runtime-Library Function</a><br>
</li>
<li><a moz-do-not-send="true" href="#debugging">Debugging XPL Programs </a><br></li>

<ul>

  
</ul>

<li><a moz-do-not-send="true" href="#hooks">Patches for Insertion of Inline Code</a></li>
<li><a moz-do-not-send="true" href="inlines">More on IBM System/360 Inline Code</a></li>
<li><a moz-do-not-send="true" href="#appendix">Appendix:&nbsp; Suitable C Compilers</a><br>
</li>


</ul>


    
<h1><a name="Introduction"></a>Introduction<br>
</h1>XPL was a computer language (<a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>) in the 1960's and 1970's that was defined by a book called <i>A Compiler Generator</i>,
 by William M. McKeeman, James J. Horning, and David B. Wortman.&nbsp; 
(Incidentally, there will also be frequent references to Intermetrics 
document IR-182-1, <a moz-do-not-send="true" href="Shuttle/19760020796.pdf#page=822">"HAL/S-FC &amp; HAL/S-360 Compiler System Program Description"</a>, though the document is not about the XPL language as such; for brevity, I'll refer to it simply as IR-182-1.) <br>
<br>
I'm unaware of any continued use of the XPL language today, though I 
don't claim to be enough of an XPL scholar to know for sure.&nbsp; (Let 
me know, if you know differently!)&nbsp;&nbsp; As for why the language 
is dead, I'd speculate that some of the more-important reasons are:<br>
<ul>
  <li>The book remains the principal source of information about the 
language, and it's mainly about relatively-abstract topics.&nbsp; There 
is no "user's manual" for XPL.&nbsp; No "programmer's guide".&nbsp; No 
tutorials as to how to get started with it.&nbsp; Indeed, there is not 
even a "Hello, world!" program.&nbsp; The closest thing to a sample 
program in XPL is the source code for a full-blown language compiler!&nbsp; In short, 
there's no convenient way for a programmer to get started with it, except for immediately jumping into the deep end of the pool.<br>
  </li>
  <li>The language was not designed for general-purpose 
applications.&nbsp; It was tailored for the specific purpose of writing 
compilers for other computer languages, and writing compilers is not an 
everyday activity of large numbers of people.&nbsp; For example, while 
there is an integer datatype, there's no floating-point datatype; so how
 could you easily write mathematically-intensive programs in it?<br>
  </li>
  <li>The definition of the language is highly dependent on the 
characteristics of IBM System/360 mainframe computers, to the extent 
that even writing an XPL compiler that could run on non-compatible 
computers is quite a chore.&nbsp; Indeed, the 
preface to the book explicitly states that they were creating a language
 specifically for the IBM 360. </li>
</ul>
So why bother with it?<br>
<br>
To be blunt, it's all about the Space Shuttle and its flight software.&nbsp; If you want to work with Space Shuttle flight 
software, you need a compiler for a computer language called HAL/S, and fortunately <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0">we do have XPL source code for such a HAL/S compiler</a>.&nbsp; But if you want to use that HAL/S compiler, 
you first need an XPL compiler.&nbsp; And preferably, both compilers should
work on computers that the general public actually has access to, such 
as Windows, Mac OS, or Linux computers, rather than being confined to 
mainframe systems that are no longer common.<br>

<br>
This web page is devoted to such a modern XPL compiler, which I call <b>XCOM-I</b>.&nbsp; A corresponding web page devoted to the modern HAL/S compiler, <b>HAL/S-FC</b> (which I'll often refer to as <b>HALSFC</b> in order to avoid the issue of having the / character in filenames), can be found <a moz-do-not-send="true" href="HAL.html">here</a>.&nbsp; A corresponding web page devoted to the Space Shuttle flight software (<b>PASS</b> and <b>BFS</b>) — and to the Space Shuttle computing systems in general —, can be found <a moz-do-not-send="true" href="Shuttle.html">here</a>.&nbsp; <b>HALSFC</b> will be discussed <i>here</i> only to the extent of instructions for building it using <b>XCOM-I</b>.<br>
<h1><a name="WhyXPLI"></a>XPL/I Versus Standard XPL<br>
</h1>
The Space Shuttle flight software and the HAL/S compiler used to compile
 it were originally written by a company called Intermetrics, Inc.<br>
<br>
When I said earlier that the HAL/S compiler was written in XPL, I was 
taking certain liberties with the truth.&nbsp; The standard XPL language
 as described in <i>A Compiler Generator</i> was not adequate in 
Intermetrics's view, so they extended the language in various ways, and 
slightly modified its behavior in others.&nbsp; Intermetrics continued 
to refer to the language as "XPL", but XPL compilers conforming to <i>A Compiler Generator</i>,
 or indeed any XPL compiler outside the premises of Intermetrics itself,
 could not have compiled any significant program written in the XPL 
variant that Intermetrics had created.&nbsp; The lack of distinction 
between standard XPL and this extended XPL didn't matter as long as 
Fortress Intermetrics operated its walled garden separately from the 
remainder of the computing world.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; For example, the previous attempt best-known to me of a modern XPL compiler is <a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel 
Weaver's XPL-to-C translator</a>.&nbsp; Alas, it is incapable of compiling Intermetrics's extended form of XPL.</font><br>
</blockquote>
But times have changed.&nbsp; <i>We</i> sometimes will need to distinguish between the standard XPL language of <i>A Compiler Generator</i>
 and the extended XPL language of Intermetrics in our discussion.&nbsp; 
When we do need to distinguish, I'll call that extended Intermetrics 
language "XPL/I".<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; In case you're wondering, there is no known surviving copy of 
Intermetrics's own XPL/I compiler.&nbsp; In fact, there is reason to 
believe that it was intentionally destroyed.&nbsp; (Prove me wrong, 
please!)&nbsp; If it had survived, however, I presume it would have 
been written in standard XPL and itself compiled by a standard XPL compiler on an IBM 360 computer.</font><br>
</blockquote>Inconveniently, the differences between the standard XPL 
language and XPL/I are not fully documented.&nbsp; Or perhaps more 
accurately, if they are fully documented, then that documentation has 
either not survived or else has not made its way into my hands.&nbsp; <a moz-do-not-send="true" href="Shuttle/19760020796.pdf#page=822">Section 13 of IR-182-1</a>, does describe some (but not all) of the known differences.&nbsp; It is also true that the specification of standard XPL in <i>A Compiler Generator</i>,
 is perhaps not 100% complete or perfect, and much that is unsaid (or 
underemphasized) in it relies on the tribal knowledge of the intended 
audience at the time of publication ... tribal knowledge from a tribe 
which has today essentially vanished.<br>
<br>
Thus developing an XPL/I compiler, or even a standard XPL compiler, is 
today more like scientific research than like computer 
programming.&nbsp; In computer programming, if you want to know how to 
do something, you look it up in the documentation or in a book or 
website that has predigested it for you, and then you exactly follow the
 instructions given there; or if you're lucky, you "google" it to find 
that somebody else had already done almost exactly what you wanted to 
do, and you just cut-and-paste what they had already done.&nbsp; Whereas
 in scientific research, you observe, you make hypotheses, you explore 
the consequences of those hypotheses ... and you start all over again if
 your hypotheses were found to be wrong!&nbsp; And in scientific research, even if 
you think you've found the perfect answer, you may still be wrong in the 
end, in ways you can't detect or understand.&nbsp; In fact, you probably
 will be.<br>
<br>
Or to put it differently, computer programming is like a game where you 
can look up all of the rules, whereas scientific research (or writing an
 XPL/I compiler) is like a game where you don't know all of the rules.<br>
<br>
The latter is my XPL/I world, and welcome to it!<br>
<h1><a name="XCOMI"></a>XCOM-I</h1>
The modern XPL/I compiler is known as <b>XCOM-I</b>.&nbsp; It is designed to compile both XPL/I programs and standard XPL programs.<br>
<br>
It is perhaps a misnomer to call it a "compiler", because it's really an
 XPL/I-to-C translator.&nbsp; There's a two-step process to compile an 
XPL or XPL/I program:&nbsp; You first translate your program into C via <b>XCOM-I</b>, and then you compile the C code to get a program that actually runs on your computer.<br>
<blockquote><font size="-1"><b>Aside:&nbsp; XCOM-I</b> itself is written in the Python 3 language, and getting <b>XCOM-I</b> to run on your computer is dead simple:&nbsp; Just install Python 3, copy <b>XCOM-I</b>
 onto your computer, add it to your PATH, and you're ready to go!&nbsp; 
Setting up your computer to compile the C code is something else, 
though.&nbsp; Once again it's dead simple, <i>if</i> you have the common C compiler known as <b>gcc</b>.&nbsp;
 But it's not so simple on (say) Microsoft Windows where most people use
 the far-less-compatible Visual Studio system.&nbsp; And that's a <i>lot</i> of people.&nbsp; So let's put the installation problem aside for a few minutes and come back to it a little later.</font><br>
</blockquote>
On a properly-set-up computer, compiling an XPL or XPL/I program is 
quite simple.&nbsp; Suppose we have an XPL program called HELLO.xpl 
whose contents are this:<br>
<blockquote>
  <pre><font color="#663300">OUTPUT = 'Hello, world!';<br>EOF</font><br></pre>
</blockquote>
To compile it, we do this:<br>
<blockquote>
  <pre><font color="#663300">XCOM-I.py --xpl HELLO.xpl<br>make -C HELLO.build<br></font></pre>
</blockquote>
To run the compiled program, you could do this:<br>
<blockquote>
  <pre><font color="#663300">./HELLO</font><br></pre>
</blockquote>giving output that looks like this:<br>
<blockquote>
  <pre><font color="#663300">PAGE 1<br><br><br>Hello, world!</font><br></pre>
</blockquote>
Note, by the way, that on most platforms there won't be be a line feed after the final exclamation 
point, so when your command-line prompt reappears, it will immediately 
follow the ! rather than being on a separate line.<br>
<br>
Not quite what you expected, I bet, if you're a coder and have seen lots
 of Hello World programs in the past!&nbsp; Blame the 1960's-era 
computing environment.&nbsp; Back then, programmers weren't sitting in 
front of a display screen and a keyboard when they wrote or ran their 
programs, but were instead punching their programs into 80-column 
computer cards, submitting computing jobs that would run at some later 
but undetermined time, and outputting the results of running their 
programs on 
physical printers, probably on fan-fold, tractor-feed paper.&nbsp; 
Probably that paper has horizontal green-and-white bars on it, or 
perhaps horizontal black lines between every few lines of print.&nbsp; 
Pages of printouts had headings printed on them, and those headings 
included page numbers.<br>
<br>
If you were to write a computer program today that printed a line of 
text, you'd probably expect it to move to the next line after each line 
was "printed" on your display screen.&nbsp; Not in the 1960's on IBM 
printers!&nbsp; In that
 environment, it was more similar to moving to the next line and <i>then</i> printing the text.&nbsp; That's why there's no line-feed at the end of our printout:&nbsp; It came <i>before</i>
 the line was printed, not after it.&nbsp; Not that this is a big deal, 
of course, merely that our own ingrained expectations no longer 
completely match those of 1960's-era IBM programmers. <br>
<br>
As for what the compilation process above did for us, the result of running <b>XCOM-I</b>
 was that a directory called HELLO.build was created, containing the 
translation into C of our XPL program.&nbsp; That new directory is 
completely self-contained, and no longer requires <b>XCOM-I</b> nor 
HELLO.xpl.&nbsp; You could move it to an entirely-different computer 
before compiling the C code, if you liked.&nbsp; Its contents look 
something like this:<br>
<blockquote>
  <pre>-rw-rw-r-- 1 rburkey rburkey  11207 Aug 12 07:23 COMPACTIFY.c<br>-rw-rw-r-- 1 rburkey rburkey   1730 Aug 12 07:23 configuration.h<br>-rw-rw-r-- 1 rburkey rburkey  16921 Jul  7 10:50 debuggingAid.c<br>-rw-rw-r-- 1 rburkey rburkey   4269 Aug  5 09:01 inline360.c<br>-rw-rw-r-- 1 rburkey rburkey   1195 Aug  5 09:01 inline360.h<br>-rw-rw-r-- 1 rburkey rburkey   1835 Aug 12 07:23 main.c<br>-rw-rw-r-- 1 rburkey rburkey   4545 Aug 10 17:07 Makefile<br>-rw-rw-r-- 1 rburkey rburkey  24759 Aug 12 07:23 memory.c<br>-rw-rw-r-- 1 rburkey rburkey    883 Aug 12 07:23 procedures.h<br>-rw-rw-r-- 1 rburkey rburkey    161 Aug 12 07:23 resetAllReentryGuards.c<br>-rw-rw-r-- 1 rburkey rburkey 125864 Aug  9 13:52 runtimeC.c<br>-rw-rw-r-- 1 rburkey rburkey  18037 Jul 18 10:52 runtimeC.h<br></pre>
</blockquote>
The command "<font color="#663300"><code>make -C HELLO.build</code></font>" 
simply compiles the C code in HELLO.build, and moves the executable (also called 
"HELLO" or in Windows, "HELLO.exe") up into the current working directory after it builds it.&nbsp; But 
the executable doesn't <i>have</i> to be there; you can move it somewhere else 
before running it, and even delete the HELLO.build directory or the current working directory completely.<br>
<br>
The <b>XCOM-I</b> command line switch <font color="#663300"><code>--xpl</code></font>, incidentally, wasn't necessary for HELLO.xpl.&nbsp; You can see all of the available command-line switches with<br>
<blockquote>
  <pre><font color="#663300">XCOM-I.py --help</font><br></pre>
</blockquote>
In particular, the switch <font color="#663300"><code>--xpl</code></font> simply informed the 
compiler that the source code was standard XPL rather than XPL/I.&nbsp; XPL/I is the default.&nbsp; But 
HELLO.xpl is a perfectly-valid XPL/I program too, so we could just have omitted <font color="#663300"><code>--xpl</code></font> with no problem.&nbsp; That doesn't mean that an identical result is produced, though!&nbsp; For example, if we left off the <font color="#663300"><code>--xpl</code></font> switch, we might see the following messages when we ran <b>XCOM-I</b>:<br>
<blockquote>
  <pre>No code is generated for the following PROCEDURE(s):<br>	Not called:  DESCRIPTORuMONITOR<br>	Not called:  uRECORDuCONSTANT<br>	Not called:  uNEEDMOREuSPACE<br>	Not called:  uRECORDuSEAL<br>	Not called:  uRECORDuUNSEAL<br>	Not called:  uRECORDuGROUPHEAD<br>	Not called:  uRECORDuCOORDINATED<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uINCREASEuRECORD<br>	Not called:  uALLOCATEuSPACE<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uATTACHuRECORD<br>	Not called:  uGETuSPACE<br>	Not called:  uHOWuMUCH<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uFINDuFREE<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uSTEAL<br>	Not called:  uMOVEuRECS<br></pre>
</blockquote>
Those aren't errors or warnings, but are instead informative messages 
indicating that certain XPL/I procedures implicitly imported by the 
compiler hadn't been needed, and thus were being discarded.&nbsp; 
Whereas the compiler wouldn't have tried to import these procedures in 
the first place if compiling standard XPL.&nbsp; You'd also find that 
the contents of the HELLO.build directory were quite different as well:<br>
<blockquote>
  <pre>-rw-rw-r-- 1 rburkey rburkey   2890 Aug 12 07:52 uACTIVEuDESCRIPTORS.c<br>-rw-rw-r-- 1 rburkey rburkey   2040 Aug 12 07:52 uATTACHuBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey   1485 Aug 12 07:52 uATTACHuBLOCKxJOIN.c<br>-rw-rw-r-- 1 rburkey rburkey   1086 Aug 12 07:52 uCHECKuFORuTHEFT.c<br>-rw-rw-r-- 1 rburkey rburkey  21641 Aug 12 07:52 COMPACTIFY.c<br>-rw-rw-r-- 1 rburkey rburkey   1747 Aug 12 07:52 COMPACTIFYxADDuDESC.c<br>-rw-rw-r-- 1 rburkey rburkey   1711 Aug 12 07:52 configuration.h<br>-rw-rw-r-- 1 rburkey rburkey  16921 Jul  7 10:50 debuggingAid.c<br>-rw-rw-r-- 1 rburkey rburkey   1330 Aug 12 07:52 uDETACHuRECORD.c<br>-rw-rw-r-- 1 rburkey rburkey  10136 Aug 12 07:52 uFREEBLOCKuCHECK.c<br>-rw-rw-r-- 1 rburkey rburkey   1157 Aug 12 07:52 uFREEBLOCKuCHECKxADDRESSuCHECK.c<br>-rw-rw-r-- 1 rburkey rburkey   4322 Aug 12 07:52 uFREEBLOCKuCHECKxBLKPROC.c<br>-rw-rw-r-- 1 rburkey rburkey   4269 Aug  5 09:01 inline360.c<br>-rw-rw-r-- 1 rburkey rburkey   1195 Aug  5 09:01 inline360.h<br>-rw-rw-r-- 1 rburkey rburkey   7047 Aug 12 07:52 main.c<br>-rw-rw-r-- 1 rburkey rburkey   4545 Aug 10 17:07 Makefile<br>-rw-rw-r-- 1 rburkey rburkey  31342 Aug 12 07:52 memory.c<br>-rw-rw-r-- 1 rburkey rburkey   1692 Aug 12 07:52 uMOVEuWORDS.c<br>-rw-rw-r-- 1 rburkey rburkey   1176 Aug 12 07:52 uPREVuFREEBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey   1142 Aug 12 07:52 uPREVuRECORD.c<br>-rw-rw-r-- 1 rburkey rburkey   5236 Aug 12 07:52 procedures.h<br>-rw-rw-r-- 1 rburkey rburkey   2419 Aug 12 07:52 uRECORDuFREE.c<br>-rw-rw-r-- 1 rburkey rburkey   1597 Aug 12 07:52 RECORDuLINK.c<br>-rw-rw-r-- 1 rburkey rburkey   3990 Aug 12 07:52 uREDUCEuBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey    652 Aug 12 07:52 resetAllReentryGuards.c<br>-rw-rw-r-- 1 rburkey rburkey   2362 Aug 12 07:52 uRETURNuTOuFREESTRING.c<br>-rw-rw-r-- 1 rburkey rburkey   6157 Aug 12 07:52 uRETURNuUNUSED.c<br>-rw-rw-r-- 1 rburkey rburkey 125864 Aug  9 13:52 runtimeC.c<br>-rw-rw-r-- 1 rburkey rburkey  18037 Jul 18 10:52 runtimeC.h<br>-rw-rw-r-- 1 rburkey rburkey    475 Aug 12 07:52 uSPACEuROUND.c<br>-rw-rw-r-- 1 rburkey rburkey   2023 Aug 12 07:52 uSPMANERR.c<br>-rw-rw-r-- 1 rburkey rburkey   7067 Aug 12 07:52 uSQUASHuRECORDS.c<br>-rw-rw-r-- 1 rburkey rburkey   4714 Aug 12 07:52 uTAKEuBACK.c<br>-rw-rw-r-- 1 rburkey rburkey   1466 Aug 12 07:52 uUNUSEDuBYTES.c<br></pre>
</blockquote>
The way <b>XCOM-I</b> operates, each XPL <font color="#663300"><code>PROCEDURE</code></font>, even if its definition is embedded in another <font color="#663300"><code>PROCEDURE</code></font>, is given its own dedicated C file.&nbsp; Our simple HELLO.xpl program didn't have even a single <font color="#663300"><code>PROCEDURE</code></font> in it, though the compiler did implicitly import a number of support procedures such as <font color="#663300"><code>COMPACTIFY</code></font>, so you can see that a COMPACTIFY.c file has been generated.&nbsp; <font color="#663300"><code>COMPACTIFY</code></font>, as it happens, has an embedded <font color="#663300"><code>PROCEDURE</code></font> called <font color="#663300"><code>ADD_DESC</code></font>.&nbsp; That's where the file COMPACTIFYxADD_DESC.c comes from; the little "x" indicates the embedding.<br>
<br>
Just for grins, let's take a look at the generated C code.&nbsp; When compiled with the <font color="#663300"><code>--xpl</code></font> switch, the C file that most-directly relates to HELLO.xpl is main.c, which looks like this:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File main.c generated by XCOM-I, 2024-08-12 08:01:10.<br>  XPL/I source-code files used: XPL.LIBRARY.xpl HELLO.xpl.<br>  To build the program from the command line, using defaults:<br>          cd HELLO/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          HELLO [OPTIONS]<br>  Use `HELLO --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br><br>// clang-format off<br>/*<br>            *** Memory Map ***<br>  Address (Hex)   Data Type   Variable<br>  -------------   ---------   --------<br>  1318 (000526)   BASED       userMemory<br>  1346 (000542)   BASED       privateMemory<br>  1376 (000560)   FIXED       COMPACTIFYxI<br>  1380 (000564)   FIXED       COMPACTIFYxJ<br>  1384 (000568)   FIXED       COMPACTIFYxK<br>  1388 (00056C)   FIXED       COMPACTIFYxL<br>  1392 (000570)   FIXED       COMPACTIFYxND<br>  1396 (000574)   FIXED       COMPACTIFYxTC<br>  1400 (000578)   FIXED       COMPACTIFYxBC<br>  1404 (00057C)   FIXED       COMPACTIFYxDELTA<br>  1408 (000580)   BIT(16)     COMPACTIFYxDX(500)<br>  2412 (00096C)   FIXED       COMPACTIFYxMASK<br>  2416 (000970)   FIXED       COMPACTIFYxLOWER_BOUND<br>  2420 (000974)   BIT(1)      COMPACTIFYxTRIED<br>*/<br>// clang-format on<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  // Setup for MONITOR(6), MONITOR(7), MONITOR(21).  Initially,<br>  // entire physical memory is a single pre-allocated block.<br>  MONITOR6a(USER_MEMORY, PHYSICAL_MEMORY_LIMIT, 0);<br>  MONITOR6a(PRIVATE_MEMORY, PRIVATE_MEMORY_SIZE, 0);<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  static int reentryGuard = 0;<br>  reentryGuard = guardReentry(reentryGuard, "main");<br>  // OUTPUT = 'Hello, world!'; (0)<br>  {<br>    descriptor_t *stringRHS;<br><font color="#009900">    stringRHS = cToDescriptor(NULL, "Hello, world!");<br>    OUTPUT(0, stringRHS);<br></font>    stringRHS-&gt;inUse = 0;<br>  }</font><br></pre>
</blockquote>
The part I've highlighted in green is the only part that directly 
relates to HELLO.xpl.&nbsp; All of the rest is overhead related to 
modeling the IBM 360 computing environment in C.&nbsp; The functions <font color="#009900"><code>cToDescriptor</code></font> and <font color="#009900"><code>OUTPUT</code></font> are part of <b>XCOM-I</b>'s runtime library.<br>
<h1><a name="installation"></a>Installation of XCOM-I<br>
</h1>
<h2><a name="Linux"></a>Linux or Mac OS<br>
</h2>
<p>Note that my newest Mac is 17 years old, and hasn't been updatable 
for a long time now, so my Mac comments may or may not apply to your 
(probably!) much newer Mac.<br>
</p>


<p>
</p>


<ol>
  <li><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc">Download the entire Virtual AGC source tree</a>.&nbsp; For brevity, I'm going to assume that this ends up as a folder called <i>virtualagc</i>, but you need to substitute the actual name in the instructions below.&nbsp; My personal suggestion would be to get it via <b>git</b>, as in the following command, because that makes it easy to keep up-to-date later via "<font color="#663300"><code>git pull</code></font>":</li>
</ol>
<blockquote>
  <blockquote>
    <pre><font color="#663300"><code>git clone --depth=1 https://github.com/virtualagc/virtualagc.git</code></font></pre>
  </blockquote>
</blockquote>
<ol start="2">
  <li>Add the following folders to your PATH:&nbsp; <i>"virtualagc</i>/XCOM-I", <i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS", and <i>"virtualagc</i>/yaShuttle/Source Code/PASS.REL32V0" to 
your PATH.&nbsp; 
(Hint:&nbsp; In Linux, I usually do this by editing ~/.bashrc; in Mac 
OS, by editing /etc/paths.&nbsp; But Google it if you're unsure!)&nbsp; Afterward, you may need to close and 
reopen any terminal windows in order for the change to take effect.</li>
<li>Install Python 3, if not already installed.</li><li>Optionally, install <b>clang-format</b>.&nbsp; You don't necessarily need to install <b>clang</b> itself, but you certainly can do so.&nbsp; This allows you optionally to "pretty print" the C code that <b>XCOM-I</b> generates.<br>
</li>
</ol>
<p>Less common:&nbsp; If you want to build Windows executables using Linux, you need to 
additionally install a C cross-compiler.&nbsp; On Linux Mint, which I 
use, this is called "mingw-64", whereas on your platform it may 
differ.&nbsp; The instructions below assume that the program used to 
invoke the cross-compiler is "x86_64-w64-mingw32-gcc" (or alternately 
"i686-w64-mingw32-gcc"), but again, perhaps it is different on your 
platform.&nbsp; To run the Windows executables <i>on</i> Linux requires the 
installation of WINE.&nbsp; On Linux Mint, both mingw-64 and WINE can be
 installed from the standard package repository.&nbsp; Whether any of 
that is possible on a Mac, I have no idea whatever; not on <i>my</i> old Mac, for sure!<br>
</p>
<ol start="4">

</ol>
<p>
</p>


<h2><a name="Windows"></a>Windows Specific</h2>
<p>The problem in Windows is not <b>XCOM-I</b> <i>per se</i>, which works as-is, but rather to set up some kind of reasonably-compliant environment for compiling the C files produced by <b>XCOM-I</b>.&nbsp; That's more effort in Windows than in Linux or Mac OS (since you generally don't have to do it in Linux or Mac OS).<br>
</p>
<blockquote>

  <font size="-1"><b>Aside:</b>&nbsp; A choice that will likely be obvious to most people is to use the </font><font size="-1">Windows Subsystem for Linux (WSL).&nbsp; I
 have been unable to try it.&nbsp; I purchased Windows 11 to do so, 
but I'm running Windows 11 in a virtual machine myself, and it turns out
 that you cannot run WSL on Windows inside of a virtual machine.&nbsp; Too 
bad!&nbsp; If you try WSL on a physical machine and make it work, let me
 know.<br>
  </font></blockquote>
At any rate, I'll be offering you two choices of how to install.&nbsp; My 
recommended choice is to work with something called MSYS2, which is a 
development environment that's very Linux-like, and includes many of the 
same development tools that Linux provides.&nbsp; I'll also offer a way 
to use Visual Studio instead, though you'll still have to end up installing so many
 Linux-like tools that it's probably more effort, for a result that doesn't seem superior.&nbsp; But it's your 
choice.<br>

<h3>Option 1: MSYS2</h3>

<ol>
<li>Install <a moz-do-not-send="true" href="https://www.msys2.org/">MSYS2</a>, which gives you a Linux/Mac-like command-line working environment for compiling stuff.&nbsp; <br>
</li><li>Run MSYS2.<br>
  </li>

  <li>Install various packages with this command:&nbsp;&nbsp;<font color="#663300"><code></code></font></li>
</ol>

<blockquote>
  <blockquote><font color="#663300"><code>pacman -S mingw-w64-ucrt-x86_64-gcc make grep diffutils python3 </code></font><font color="#663300"><code><font color="#663300"><code>python3-pip </code></font>git clang</code></font><br>
  </blockquote>
</blockquote>
<ol start="4">
  <li><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc">Download the entire Virtual AGC source tree</a>.&nbsp; For brevity, I'm going to assume that this ends up as a folder called <i>virtualagc</i>, but you need to substitute the actual name in the instructions below.&nbsp; My personal suggestion would be to get it via <b>git</b>, as in the following command, because that makes it easy to keep up-to-date later via "<font color="#663300"><code>git pull</code></font>":</li>
</ol>
<blockquote>
  <blockquote>
    <pre><font color="#663300"><code>git clone --depth=1 https://github.com/virtualagc/virtualagc.git</code></font></pre>
  </blockquote>
</blockquote>

<ol start="5">
  <li>Add the following folders to your PATH:&nbsp; <i>"virtualagc</i>/XCOM-I", <i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS", and <i>"virtualagc</i>/yaShuttle/Source Code/PASS.REL32V0".&nbsp; In MSYS2, you'd do that by editing the file ~/.bashrc, 
which you can do with the command "<font color="#663300"><code>nano ~/.bashrc</code></font>".&nbsp; Google how to permanently
 change the PATH in Linux if you're unsure what to do.&nbsp; Afterward, 
you will need to exit MSYS2 and rerun it to see the change take effect.</li>
</ol>
<p>It's worth noting that if you followed these instructions to the 
letter, then your "home directory" in MSYS2 will probably be something 
like C:\msys64\home\<i>USERNAME</i>, whereas your home directory for a normal command-line would be c:\users\<i>USERNAME</i>.&nbsp; That's good to keep in mind if you need to transfer any files in or out of there!<br>
</p>

<h3>Option 2: Visual Studio</h3>
<blockquote><font size="-1"><b>Warning:</b>&nbsp; I have never used 
Visual Studio prior to this, or if I have then it was so long ago I no longer remember doing so.&nbsp; Besides which, for <b>XCOM-I</b>
 I'm only using Visual Studio's command-line tools 
rather than its Integrated Development Environment (IDE).&nbsp; The 
upshot of this that you shouldn't interpret my giving you Visual Studio 
instructions as meaning you're going to get the wonderful integration 
into Visual Studio that you might dream of.&nbsp; You <i>might</i>, but you'll have to work it out yourself!</font><br>
</blockquote>
<p>Note that almost everything I'm going to tell you to do, either here 
in the setup, or elsewhere on the page, is done from what's called the 
Developer Command Prompt for Visual Studio, which you can run from the 
Windows Start menu if you have Visual Studio installed.&nbsp; You won't 
be working from a normal (non-developer) command prompt most of the 
time.&nbsp; I think the main reason you have to 
do this is that the C compiler (<b>cl</b>) is in its PATH, but not in the PATH in a normal command prompt.&nbsp; You'll have to '<code>cd</code>'
 to some other directory, though, to get anything done, since you'll 
have no permissions to actually modify anything in the working directory
 this plunks you into.&nbsp; Isn't that a fun feature?&nbsp; It's your 
own choice, of course, but perhaps you could go to your normal command-line home directory.</p>
<ul>

</ul>

Another thing worth knowing is that if Python programs such as <b>XCOM-I</b>
 are run from a command line in Windows, 
they open up in a new window in which all of their messages appear, but 
the window vanishes as soon as the 
Python program completes.&nbsp; That means that you have little or no 
time to ponder or capture the messages it may be showing you, 
particularly the error messages.&nbsp; You can work around this 
phenomenon, whenever I explicitly instruct you to run <b>XCOM-I</b>, by invoking <b>XCOM-I</b> as<br>
<blockquote>
  <pre>python XCOM-I.py <i>... </i><br></pre>
</blockquote>
On the other hand, any invocations of <b>make</b> I instruct you to use will already have take care of this for you.<br>
<br>
Here's the setup:<br>

<ul>
  <li>Get the entire <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc">Virtual AGC source-code tree</a> from GitHub.&nbsp; <br>
</li>
  <li>Add the following folders to your PATH:&nbsp; <i>"virtualagc</i>/XCOM-I", <i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS", and <i>"virtualagc</i>/yaShuttle/Source Code/PASS.REL32V0"..&nbsp; If you've already opened a VS 
developer command prompt, then close it and start a new one to see the 
effect of the changed PATH.</li>
  <li>Install Python 3, if it's not already installed.&nbsp; <br>
</li>
<li>Set the environment variable <code>PYTHONUTF8=1</code> to enable
 Python's UTF-8 processing ability.&nbsp;&nbsp;</li>
<li>Obtain <a moz-do-not-send="true" href="https://github.com/bmatzelle/gow">a zipfile of numerous UNIX-style utilities from here</a>.&nbsp;
 Extract the contents somewhere on your local computer, and add the 
subdirectory called "bin" to your PATH.&nbsp; (Remember to close and 
then reopen any developer command line you may have open, in order to 
see the effect of the change to the PATH.)&nbsp;&nbsp;</li>
<li>The version of GNU <b>make</b> provided with these UNIX-style utilities is too out-of-date (version 3.81) to be fully satisfactory for use with <b>XCOM-I</b>.&nbsp;
 So you'll have to install a newer version.&nbsp; Here's a reasonably-easy way to do that:</li>
<ul>
  <li>Download <a moz-do-not-send="true" href="https://www.gnu.org/software/make/#download">the latest source code from here</a> (version 4.4.1 as I'm writing this) and extract it.</li>
  <li>From a Visual Studio developer command line, 'cd' in to the source-code directory just created.</li>
  <li>Run the batch script called <font color="#663300"><code>build_w32.bat</code></font>.&nbsp; This creates the file gnumake.exe in the subdirectory called WinRel/.</li>
  <li>Rename gnumake.exe as just make.exe.<br>
  </li>
  <li>Get it into your PATH somewhere that precedes the older version of <b>make</b> found in 
the UNIX-style utilities.&nbsp; What I do is just copy it atop the older version in the UNIX-style utilities' bin/ folder.</li>
  <li>You can verify the version by running <code>make -v</code>.<br>
  </li>
</ul>

</ul><blockquote>
</blockquote>

<h2><a name="testTheInstallation"></a>Testing the Installation</h2>
<p>We can do a very quick test of your setup and of <b>XCOM-I</b> itself by compiling and running the HELLO.xpl program I <a moz-do-not-send="true" href="#XCOMI">used as an example earlier</a>.</p>
Do the following:<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="top"><u>Linux</u><u><br>
        </u></th>
      <th valign="top"><u> Mac OS</u><u><br>
        </u></th>
      <th valign="top"><u>Windows</u><u><br>
        </u></th>
    </tr>
    <tr>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:
        <blockquote>
          <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s -C HELLO.build<br>./HELLO</pre>
        </blockquote>

      </td>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:
        <blockquote>
  <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s CC=clang EXTRA=-w -C HELLO.build<br>./HELLO<br></pre></blockquote>(Omit <code>--pp</code> if <b>clang-format</b> not installed.)<br>

        <br>



      </td>
      <td valign="top">Open an MSYS2 command line.&nbsp; Then:
        <blockquote>
          <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s RDYNAMIC= -C HELLO.build<br>HELLO<br></pre></blockquote>Or from a Visual Studio developer command line,<br>

<blockquote>
  <pre>md temp<br>cd temp<br>set PYTHONUTF8=1<br>python XCOM-I.py --xpl ..\virtualagc\XCOM-I\Tests\HELLO.xpl<br>make CC=cl -C HELLO.build<br>HELLO</pre>
</blockquote>

<blockquote>
        </blockquote>

      </td>
    </tr><tr>
  <th rowspan="1" colspan="1" valign="top"><u>Build in Linux, for use in Windows</u></th>
</tr>
<tr>
  <td rowspan="1" colspan="1" valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
    <blockquote>
      <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s CC=x86_64-w64-mingw32-gcc EXT=.exe -C HELLO.build<br></pre>
    </blockquote>
Copy HELLO.exe to Windows or run on Linux with WINE.<br>
  </td>
</tr>

  </tbody>
</table>
<br>
By the way, you don't actually <i>need</i> to create an empty directory (~/temp) to work in, but why clutter up your directory with whatever files <b>XCOM-I</b> may produce?<br>
<br>
If you were alert enough — <i>I</i> wouldn't have been! —, you'll have noticed a few differences from when I gave this same example earlier:<br>
<ul>
  <li>The <b>XCOM-I</b> <font color="#663300"><code>--pp</code></font> option:&nbsp; This "pretty prints" the C-language files produced by <b>XCOM-I</b>,
 so that the indentation is nicer, the code doesn't trail out of view 
past the right-hand margin, and so on.&nbsp; On the other hand, it may 
also mess up column alignment in comments.&nbsp; You pays your money and
 takes your chances!</li>
  <li>The <font color="#663300"><code>-s</code></font> in the make command:&nbsp; Optional.&nbsp; It just prevents <b>make</b> from giving you a running commentary on whatever commands it happens to be running.&nbsp; No big deal! <br>
  </li>
  <li><font color="#663300"><code>CC=clang EXTRA=-w</code></font> in the Mac OS <b>make</b> command:&nbsp; Probably not necessary.&nbsp; The same <b>make</b> command as for Linux could have been used.&nbsp; And <b>clang</b> is the default anyway in Mac OS anyway, I think, so adding <font color="#663300"><code>CC=clang</code></font> just makes it explicit.&nbsp; In fact, to force it to use <b>gcc</b>, you'd have to use the command <font color="#663300"><code>make -s CC=gcc EXTRA="-w -std=c99" -C HELLO</code><code>.build</code></font>.&nbsp; In my experience, <b>clang</b> produces a lot of pointless (and incorrect) warning messages, which is why I disable all of the warnings by adding <font color="#663300"><code>EXTRA=-w</code></font>.&nbsp; <br>
  </li>
  <li><font color="#663300"><code>RDYNAMIC=</code></font> in the Windows make command:&nbsp; Disables a compiler command-line option that the Windows version of <b>gcc</b> doesn't support.<br>
  </li>
</ul>
Various other helpful options will show up in later examples.<br>
<br>
By the way, the Test/ directory from which we just retrieved HELLO.xpl has 
lots of other sample XPL and XPL/I files in it as well, which could be 
run in the same manner as HELLO.xpl.&nbsp; In fact, I've cobbled 
together a much-more-extensive test of <b>XCOM-I</b> by using them, and you can run that more-extensive test like so:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">

  <tbody>
    <tr>
      <th valign="top"><u>Linux</u><u><br>
        </u></th>
      <th valign="top"><u> Mac OS</u><u><br>
        </u></th>
      <th valign="top"><u>Windows</u><u><br>
        </u></th>
    </tr>
    <tr>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
        <blockquote>
          <pre>cd <i>virtualagc</i>/XCOM-I<br>make -f Makefile-regression<br></pre></blockquote>or<br>
<blockquote>
  <pre>make CC=clang EXTRA=-w -f Makefile-regression</pre>
</blockquote>
</td><td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:
        <blockquote>
  <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w -f Makefile-regression<br></pre></blockquote>or<br>
<blockquote>
  <pre>make CC=gcc EXTRA="-w -std=c99" -f Makefile-regression</pre>
</blockquote>
<blockquote>
        </blockquote>



      </td>
      <td valign="top"><a name="winRegression"></a>Open an MSYS2 command line.&nbsp; Then:
        <blockquote>
          <pre>cd <i>virtualagc</i>/XCOM-I<br>make RDYNAMIC= -f Makefile-regression<br></pre></blockquote>Or from a Visual Studio developer command line,<br>


  
<blockquote>
<pre>make CC=cl -f Makefile-regression</pre>

</blockquote>

<blockquote>
        </blockquote>

      </td>
    </tr><tr>
  <th valign="top"><u>Build in Linux, for use in Windows</u></th>
</tr>
<tr>
  <td valign="top">Build for Windows, but test (requires WINE) on Linux. <br>
    <br>
Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
    <blockquote>
      <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe -f Makefile-regression</pre>
    </blockquote>
  </td>
</tr>

  </tbody>
</table>
<br>
What you should expect to see in any case is some messages like the following:<br>
<blockquote>
  <pre>make -s -C Example-6.18.3.build<br>make -s -C Example-6.18.4.build<br>make -s -C Example-6.18.5.build<br>make -s -C Example-6.18.6.build<br>make -s -C breakCharactersDemo.build<br>make -s -C ANALYZER.build<br>make -s -C SKELETON.build<br>make -s -C bitsizeDemo.build<br>make -s -C bitsizeDemoCommon.build<br>make -s -C bitsizeDemoCommonIn.build<br>Files bitsizeDemo.build/out.txt and Tests/bitsizeDemo.regression are identical<br>Files bitsizeDemo.build/xxxxA and bitsizeDemoCommon.build/xxxxA are identical<br>Files bitsizeDemoCommon.build/xxxxA and bitsizeDemoCommonIn.build/xxxx are identical<br>Files bitsizeDemoCommon.build/COMMONa.out and bitsizeDemoCommonIn.build/COMMONa.out are identical<br>Files Example-6.18.3.build/out.txt and Tests/Example-6.18.3.regression are identical<br>Files Example-6.18.4.build/out.txt and Tests/Example-6.18.4.regression are identical<br>Files Example-6.18.5.build/out.txt and Tests/Example-6.18.5-and-6.regression are identical<br>Files breakCharactersDemo.build/out.txt and Tests/breakCharactersDemo.regression are identical<br>Files ANALYZER.build/out.txt and ANALYZER.build/out.regression are identical<br>======================== All regression tests passed! ========================<br></pre>
</blockquote>
These were "regression tests", in the sense that the various programs 
mentioned in the output messages had been performed at some time in the 
past, and these new runs of those same programs were compared against 
those earlier outputs.&nbsp; In other words, they test expectations 
rather than accuracy.&nbsp; By the way, several of the programs, 
including those label Example-xxxx and ANALYZER come straight out of <i>A Compiler Generator</i>.&nbsp;
 The ANALYZER.xpl program is itself quite a significant chunk of code, 
in that what it does is to accept a BNF grammar for a language and 
generate a table-driven parser for the language, in essence building a compiler for the language; in the regression test,
 it generates a parser for a simple language called SKELETON.<br>
<br>
If you want still more testing to convince yourself that <b>XCOM-I</b> 
actually works on your platform, I'm going to give it to you in a 
moment, in a section I call "Insane Bootstrapping!".&nbsp; But before that, 
we need to make a brief detour.

<h1><a name="sim360"></a>Emulating the IBM System/360 CPU

</h1>
<p>XPL or XPL/I programs compiled by <b>XCOM-I</b> are native to your own local computer system, and if <b>XCOM-I</b> has done its job properly, there should be no lingering dependencies on the IBM System/360 in the compiled programs.<br></p>
<p>Nevertheless ... XPL was <i>designed</i> to be a program for 
generating compilers, so a lot of legacy XPL or XPL/I code is actually 
the source code of a compiler for one or another computer language, and 
those compilers invariably spit out IBM System/360 object code.  
Suppose for example that we had an XPL program called <b>X</b> that was a compiler for a programming language called "X".  It's true that if we compile the source code for <b>X</b> with <b>XCOM-I</b> that we'll get executable code for <b>X</b>
 that runs on our native Linux/Mac/Windows computer (rather than, say, 
an IBM 360).  But it's also true that if we <i>use</i> that native-Linux, Mac, or Windows version of <b>X</b> to compile source-code in the X language, say for a program called <b>Y</b>,
 then the output of the compiler will still be an object file for the 
IBM System/360.  So we still wouldn't be able to run program <b>Y</b> on our native computer, and would still need an IBM System/360 to run <b>Y</b>.<br></p>
<p>Which means that even with <b>XCOM-I</b> in hand, it's still very useful to have an IBM System/360 emulator in which to run not the programs <i>produced</i> by <b>XCOM-I</b>, but the programs produced by the compilers compiled by <b>XCOM-I</b>.&nbsp; Yes, I know that makes your head swim a bit.&nbsp; Well, wait until you get to the next section.<br></p>
<p>If you're already an IBM System/360 expert or even someone who wants 
to be an IBM System/360 user, then perhaps an IBM System/360 
emulator such as <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>
 might work well for you.  As for myself, having tried to figure 
out&nbsp; without success how to use
Hercules, I have to concede that I'm neither an expert nor want to be 
one, and thus I have no desire to confront that learning curve.  I'd 
much 
prefer a <i>lightweight</i> IBM System/360 emulator, with essentially no 
learning curve at all.  (And a lightweight emulator is far more in line 
with Virtual AGC's goal of integrating Space Shuttle computing support 
into spaceflight simulation programs than a full-blown mainframe 
emulator would be anyway.)<br></p>

<p>As it happens, there <i>is</i> an available lightweight IBM System/360 emulator.  This emulator, called <b>sim360</b>,
 was written by the same Daniel Weaver who I've also mentioned earlier 
as the author of an earlier XPL-to-C translator for standard XPL.  You can find 
the
 source code for <b>sim360</b> as modified for my purposes here in <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I/sim360-source/simulate">the Virtual AGC software repository</a>, but <a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/">the official place to get the most up-to-date version is Dan's own site</a>.&nbsp;
 If you follow the hyperlink to Dan's site, you'll find that it's 
disguised as a Pascal compiler, which it is.&nbsp; But don't be 
confused:  There's an IBM System/360 emulator in there!<br>
</p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
There is a limit, of course, to how "lightweight" an IBM 360 emulator 
can be while still remaining useful.&nbsp; To run programs originally 
written in XPL or XPL/I, for example, just emulating the CPU's 
instruction set is not enough.&nbsp; Such XPL or XPL/I programs depend 
on there being an operating system in place to allow operations like 
inputting data (from a files or keyboards) or outputting data (to a 
displays, printers, or files) to occur.&nbsp; But an XPL program doesn't
 actually interact directly with the operating system.&nbsp; Instead, an
 XPL program expects that there's a separate program called the <i>submonitor</i>
 running along side of it, and the XPL program makes its low-level 
requests for input, output, allocation of memory, and so on, to this 
submonitor program.&nbsp; In fact, there will be <a moz-do-not-send="true" href="#builtin">a whole section later on</a> that describes XPL's built-in functions, some of which rely on the submonitor, as well as <a moz-do-not-send="true" href="#monitor">another section covering the <font color="#663300"><code>MONITOR</code></font> procedure</a>, <i>all</i> of whose functionality comes from the submonitor.&nbsp; But the point is that to be useful to us, a lightweight emulator like <b>sim360</b>
 must provide enough submonitor capability to respond correctly when the
 XPL program makes these requests of the submonitor, even though the IBM 
360 operating system is entirely absent.</font><font size="-1">&nbsp; Fortunately, <b>sim360</b> does so.&nbsp; Thanks, Dan!<br>
    <br>
By the way, if in place of <b>sim360</b> you were to use <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>, an emulation of the XPL or XPL/I submonitor would <i>not</i>
 be built into it.&nbsp; Rather, you would have to assemble the IBM System/360 
Basic Assembly Language (BAL) source code for the submonitor, and 
presumably contrive the JCL needed to run the submonitor program 
along-side your compiled XPL program on the emulator.&nbsp; Fortunately,
 although we don't need it if we are using <b>sim360</b>, we <i>do</i> have source code for the submonitor:&nbsp; <br>
  </font>
  <ul>
    <li><font size="-1">For <i>A Compiler Generator</i>'s <b>XCOM</b>, it's <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/XPL-TWS-1969-03/XMON.bal">XMON.bal</a>.</font></li>
    <li><font size="-1">For SUNY's <b>XCOM</b> 4.5, which we've not discussed yet but which we'll get to in the next section, it's the slightly-different <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLSM4.5.bal">XPLSM.bal</a>.</font></li>
    
    <li><font size="-1">For Intermetrics's unavailable <b>XCOM</b>, it's the collection of BAL source-code files known as <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM">MONITOR.ASM</a>.&nbsp; <br>
      </font></li>
  </ul>
  <p><font size="-1">What we don't have in this scenario is a BAL
 assembler, nor an IBM System/360 linker program, so in spite of this wealth of
 source code for submonitors, in the end we still have no way to build 
the submonitor programs that I'm aware of.</font><br>
  </p>
</blockquote>


<p>Let's build <b>sim360</b>.&nbsp; Do this:<br>
</p>
<table align="center" cellspacing="2" cellpadding="2" border="1">


  <tbody>
    <tr>
      <th valign="top"><u>Linux</u><u><br>
        </u></th>
      <th valign="top"><u> Mac OS</u><u><br>
        </u></th>
      <th valign="top"><u>Windows</u><br>
<u>
        </u></th>
    </tr>
    <tr>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
        <blockquote>
          <pre>cd <i>virtualagc</i>/XCOM-I<br>make sim360<br></pre></blockquote>Or:
<blockquote>
  <pre>make CC=clang EXTRA=-w sim360</pre>
</blockquote>
</td><td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:&nbsp;        <blockquote>
  <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w sim360<br></pre></blockquote>Or:
<blockquote>
  <pre>make CC=gcc EXTRA="-w -std=c99" sim360</pre>
</blockquote>
<blockquote>
        </blockquote>



      </td>
      <td valign="top">Open an MSYS2 command line.&nbsp; Then:&nbsp;<strike>
        </strike><blockquote>
          <pre>cd <i>virtualagc</i>/XCOM-I<br>make sim360<br></pre></blockquote>Or:
<blockquote>
  <pre>make CC=clang EXTRA=-w sim360<br></pre></blockquote>Or from a Visual Studio developer command line,<br>
<blockquote>
  <pre>make CC=cl sim360.exe<br></pre>
</blockquote>




      </td>
    </tr><tr>
  <th valign="top"><u>Build in Linux, for use in Windows</u></th>
</tr>
<tr>
  <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>

        
          
    <blockquote>
      <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe sim360.exe<br></pre>
    </blockquote>
Or:<br>
    <blockquote>
      <pre>make CC=i686-w64-mingw32-gcc EXT=.exe sim360.exe</pre>
    </blockquote>
  </td>
</tr>

  </tbody>
</table>
<br>To try out <b>sim360</b>, you'll need an IBM System/360 <i>load file</i>
 for some actual program.&nbsp; In the next couple of sections, we'll 
produce a lot of such load files.&nbsp; For now, I'll just point out that the
 IBM System/360 load file for a simple Hello World program is available in our 
Tests folder, and that you can run it like so:<br>




<blockquote>
  <pre><font color="#663300">sim360 -o0ET stdout -i0AT stdin Tests/HELLO.obj</font><br></pre>
</blockquote>
Which (surprise!) gives you this output:<br>
<blockquote>
  <pre>Hello, world!<br></pre>
</blockquote>
The command-line switches for <b>sim360</b> probably look mysterious, but they're not so bad.  You can see a full list of command-line options with the command "<font color="#663300"><code>sim360 --help</code></font>", but what the mysterious switches in the example above mean is this:<br>


<ul>
<li><font color="#663300"><code>-o0ET stdout</code></font>:  Causes any output to "device 0" from the IBM 360 program to be routed to <font color="#663300"><code>stdout</code></font>, and automatically translate it from EBCDIC to ASCII.<br></li><li><code><font color="#663300">-i0AT stdin</font></code>:  Causes input from "device 0" into the IBM 360 program to be routed from <font color="#663300"><code>stdin</code></font>, and automatically to translate it from ASCII to EBCDIC.</li></ul>The spectre of EBCDIC that looms over this entire enterprise will be discussed later.<br>
<ul>

</ul>

<h1><a name="compilingXCOM"></a>Insane Bootstrapping!</h1>

And I do mean <i>insane</i>.<br>
<br>Earlier, I promised (threatened?) to give you some much heftier testing of <b>XCOM-I</b> on your computer, and now that we have <b>sim360</b> in hand, we're going to do that with a vengeance!&nbsp; We're going try <i>bootstrapping</i>
 some legacy standard-XPL compilers.&nbsp; By a "legacy" compiler, I 
mean an IBM 360 XPL compiler from the good-old 1960's or 1970's.&nbsp; 
We'll use our ability to do this to gauge the authenticity of <b>XCOM-I</b>'s behavior, at least in so far as standard XPL is concerned.&nbsp; We happen to have XPL source code <i>and</i> IBM 360 executables for <i>two</i> such legacy compilers.&nbsp; (And by "we", I mean that I copied them from Dan Weaver's website.)<br>
<br>
<table cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Available Legacy IBM 360 XPL Compilers</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Designation<br>
      </th>
      <th valign="bottom" align="center">Notes<br>
      </th>
      <th valign="bottom" align="center">Where I Got it From<br>
      </th>
      <th valign="bottom" align="center">Legacy XPL Source Code for XCOM Proper<br>
      </th>
      <th valign="bottom" align="center">Legacy XPL Source Code for Library<br>
      </th>
      <th valign="bottom" align="center">Legacy IBM 360 Executable<br>
      </th>
      <th valign="bottom" align="center">"Modern" Patch(es) for use with XCOM-I<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM3</b><br>
      </td>
      <td valign="middle">This is the version of XCOM listed in the book <i>A Compiler Generator</i>.&nbsp; Printouts from it identify it as "XCOM III".<br>
        <br>
In reality, there's no way to know if it's identical to the book without
 comparing it line by line, which I have not done.&nbsp;&nbsp; The notes
 in the download file state that the files were recovered from a legacy 
computer tape from the Stanford Computation Center, dated 1969-01-23. 
&nbsp; The contemporary notes on the tape itself hint that it is the 
source code from the book, but stop short of saying explicitly that it's
 the precise version that appears in the book.&nbsp;&nbsp; The 
contemporary notes further state that <br>
        <blockquote><font size="-1">"THE BINARY IMAGE OF THE XCOM COMPILER ... [is] THE RESULT OF USING XCOM TO COMPILE ITSELF FROM THE SOURCE CARDS"</font><br>
        </blockquote>
However, if you run the binary executable (in <b>sim360</b>), its printout says that it was
 built on May 2, 2001, at 13:40:40.19.&nbsp; I'd suggest it's rare to 
find files created in 2001 on tapes made in 1969.&nbsp; As a separate matter, if you compile the legacy <b>XCOM3</b> source code with the legacy <b>XCOM3</b> executable, you do <i>not</i> get an identical copy of the legacy <b>XCOM3</b> executable.&nbsp; I'm convinced that a <i>different</i> version of <b>XCOM</b> compiled it. How the resulting 2001 
executable made its way onto the 1969 tape, or at 
least into the download file, I cannot say.<br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/xpl.zip">University of Toronto XPL page</a><br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM.xpl">XCOM.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/XPL.LIBRARY.xpl">XPL.LIBRARY.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM3-20010502.obj">XCOM3-20010502.obj</a><br>
      </td>
      <td valign="middle" align="center">n/a<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM45</b><br>
      </td>
      <td valign="top">The accompanying notes indicate that this is from
 a computer tape from the State University of New York, 
Stonybrook.&nbsp; The notes from the tape itself date it 1977-05-22.<br>
        <br>
No information is given about how the binary executable of the compiler 
was created.&nbsp; Its printout (when run in <b>sim360</b>) identifies itself as "XCOM 4.5", compiled on
 July 19, 1976, at 21:05:40.16.&nbsp; Fortunately, unlike <b>XCOM3</b>, 
that's consistent with the date of the tape itself.&nbsp; But as with <b>XCOM3</b>, and for the same reasons, I'm convinced that <b>XCOM45</b> had not itself been used to compile the <b>XCOM45</b> load file we have.<br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/files/suny0005.tar.gz/download">Dan Weaver's XPL project</a><br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/xcom4.xpl">XCOM4.5.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLIB4.5.xpl">XPLIB4.5.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/XCOM4-1976.obj">XCOM45-19760719.obj</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/patch0.c">patch0.c</a></td>
    </tr>
  </tbody>
</table>
<br>
To avoid confusion, from now on I'll refer to these specific compilers as <b>XCOM3</b> or <b>XCOM45</b>,
 rather than via vague references like "<i>A Compiler Generator</i>'s XCOM" as I've been doing up to now.&nbsp; Also from 
now on, if I'm speaking generically about any of these old compilers, 
I'll simply refer to <b>XCOM<i>x</i></b>.&nbsp; (For the legacy executables, I'll generically call those <b>XCOM</b><b><i>x-YYYYMMDD</i></b>.)&nbsp;
 As for the "patches" in the rightmost column, this refers to the fact 
that XPL programs may contain inline IBM System/360 machine code 
inserted directly by the programmer. &nbsp; <a moz-do-not-send="true" href="#hooks"><b>XCOM-I</b>
 has a framework for providing C-language patch files to replace the 
functionality the original XPL source code implemented by such inline IBM System/360
 machine code</a>.&nbsp; Fortunately, <b>XCOM3</b> has no such inlined IBM 360 code, and <b>XCOM45</b> has merely has a single block of 19 consecutive machine-code instructions.&nbsp; The patch file, of course, was <i>not</i> on the legacy computer tape; I wrote it myself.<br>
<br>
"Bootstrapping" is a process employed by folks who feel compelled to 
write computer-language compilers that can "self-compile"; in the case of XPL, that means that an <b>XCOM</b> executable can compile the XPL source code for <b>XCOM</b>, and get back an executable <i>identical</i>
 to itself when it does so.&nbsp; How could it have possibly worked the 
very first time back in the 1960's, when there was XPL source code but 
no <b>XCOM</b> executable yet to compile it with?&nbsp; Well, obviously the initial versions of <b>XCOM</b> must have been very cut-rate; and they must have been compiled with something <i>other</i> than <b>XCOM</b>, something presumably with very-constrained functionality itself and not written in XPL itself.&nbsp; But over time, as <b>XCOM</b> became more and more capable, <b>XCOM</b> was eventually able to compile 
itself.&nbsp; That process is called "bootstrapping", as in "hauling 
yourself up by your own bootstraps".&nbsp; We're now going to try doing 
that with <b>XCOM<i>x</i></b>.<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; To be clear, <b>XCOM-I</b> is not self-compiling.&nbsp; It's written in Python, not XPL.&nbsp; Rather, <b>XCOM3</b> and <b>XCOM45</b> are what I expect to be self-compiling once they're bootstrapped.&nbsp; In the bootstrapping scenario, <b>XCOM-I</b> is that <i>other</i> compiler used to compile the initial version of <b>XCOMx</b> before an <b>XCOMx</b> executable exists.&nbsp; Except that unlike the normal bootstrapping scenario, <b>XCOM-I</b>, <b>XCOM3</b>, and <b>XCOM45</b> are full-blown compilers rather than being the initial weak-and-feeble versions thereof.</font><br>
</blockquote>


Also to be clear, the use case for <b>XCOM-I</b> I'm personally interested in is building <b>HAL/S-FC</b> and then forgetting that XPL and <b>XCOM-I</b> even exist.&nbsp;&nbsp;<img moz-do-not-send="true" src="smiley.png" alt="" width="16" height="16">&nbsp; We don't need <i>a single one</i> of these <b>XCOM<i>x</i></b> programs to do that.&nbsp; But still, compiling <b>HAL/S-FC</b> is going to go much more smoothly if we can have confidence that <b>XCOM-I</b> works properly in the first place.&nbsp; And if we can use <b>XCOM-I</b> for bootstrapping <b>XCOM<i>x</i></b>, that will give us a certain degree of confidence that <b>XCOM-I</b>
 does in fact work as intended. And if in that process <b>XCOM-I</b> can be made useful for 
somebody who (unlike myself) actually wants to play around with XPL, 
then why not?<br>
<br>
Here's the bootstrapping game-plan as it applies to either or both of the legacy <b>XCOM<i>x</i></b> compilers:<br>
<ol>
  <li>We'll use <b>XCOM-I</b> to compile the XPL source code for <b>XCOM<i>x</i></b>.  That will give us an executable which I'll call <b><b>XCOM<i>x</i></b>-native</b> that runs natively on our Linux, Windows, or Mac computer. <br>
</li>
  <li>We'll then use <b>XCOM<i>x</i></b><b>-native</b> to compile the XPL source code for <b>XCOM<i>x</i></b> <i>again</i>.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360</b> that's native to the IBM 360. I.e., it only runs on an IBM 360 or a simulation thereof, producing IBM 360 object code as well.<br></li>
  <li>Finally, we'll run&nbsp;<b><b>XCOM<i>x</i></b>-360</b> under <b>sim360</b> to compile the source code for <b>XCOM<i>x</i></b> one last time.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360A</b>.&nbsp; If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360A</b> should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>.<br>
</li>
<li><i>Finally</i> <i>finally</i>, we'll run the legacy <b>XCOM<i>x</i></b><b>-<i>YYYYMMDD</i></b> executable under <b>sim360</b> to compile source code for <b>XCOM<i>x</i></b> one <i>really-truly</i> last time.&nbsp; That will give us an executable which I'll call <b>XCOM<i>x</i>-360C</b>.&nbsp; If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360C</b> should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b> and <b><b>XCOM<i>x</i></b>-360A</b>.<br>
</li>

</ol>

That's a <i>lot</i> of XPL compilers floating around to keep straight.&nbsp; Here's a synopsis of the <b>XCOM</b> variants relevant to the discussion, color coded for cuteness:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Summary of XPL Compilers in Bootstrapping Process</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Compiler Variant<br>
      </th>
      <th valign="bottom" align="center">Compiler's Own<br>
Source-Code Files<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Compiled With<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on IBM 360?<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on Linux/Mac/Windows<br>
      </th>
      <th valign="bottom" align="center">Source-Code Language<br>
&nbsp;and Encoding Accepted<br>
By Compiler<br>
      </th>
      <th valign="bottom" align="center">Object Files Directly <br>
Output By Compiler<br>
      </th>
      <th valign="bottom" align="center">Encoding of <br>
Textual I/O When<br>
Running the <br>
Output<br>
Object Files <br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM-I</b><b>.py<br>
        </b></td>
      <td valign="middle" align="center">XCOM-I.py <i>et al.</i><br>
      </td>
      <td valign="middle" align="center">n/a<br>
      </td>
      <td valign="middle" align="center">No<br>
      </td>
      <td valign="middle" align="center">Yes<br>
      </td>
      <td valign="middle" align="center">XPL or XPL/I, ASCII (or UTF-8) coding<br>
      </td>
      <td valign="middle" align="center">C-language files<br>
      </td>
      <td valign="middle" align="center">ASCII<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM.xpl, XPL.LIBRARY.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I.py</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">No</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">Yes</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">XPL, ASCII coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM45-native</b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM4.5.xpl, XPLIB4.5.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I</b><b>.py<br>
          </b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Yes</font><font color="#cc9933"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-360.obj</b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-native</b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360A</b><b>.obj</b><br>
        </font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Yes<br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360A.obj</b></font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360.obj</b></font></td>
    </tr><tr>
  <td valign="middle" align="center"><b>XCOM3-20010502.obj</b><b><br>
</b>

  </td>
  <td valign="middle" align="center">XCOM.xpl, XPL.LIBRARY.xpl</td>
  <td valign="middle" align="center">n/a</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">Yes</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">Only under <b>sim360</b> or similar</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">XPL, EBCDIC coding</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">IBM 360 load file</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">EBCDIC<br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center"><b>XCOM45-19760719.obj</b><b><br>
</b>
  </td>
  <td valign="middle" align="center">XCOM4.5.xpl, XPLIB4.5.xpl</td>
  <td valign="middle" align="center">n/a<br>
  </td>
</tr><tr>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM3-360C.obj<br>
  </font></b>
  </td>
  <td valign="middle" align="center"><font color="#ff0000">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM3-20010502.obj</font></b></td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">Yes<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">Only under <b>sim360</b> or similar<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">XPL, EBCDIC coding<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">IBM 360 load file</font><br>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">EBCDIC</font><br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM45-360C.obj<br>
  </font></b>
  </td>
  <td valign="middle" align="center"><font color="#ff0000">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM45-19760719.obj</font></b></td>
</tr>


    
  </tbody>
</table>
<br>
There are other possible scenarios the table doesn't cover for 
compiling stuff with other stuff.&nbsp; Those are left as an exercise 
for the reader, though I don't think they have any relevance <i>vis-à-vis</i> bootstrapping.<br>
<br>
Rather than tediously walking you through all of the steps required to 
carry out this complicated bootstrapping scheme, a Makefile has provided
 so that you can carry it out in one easy step.&nbsp; If you want to see
 the gory details, just look into the Makefile itself.<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">



  <tbody>
    <tr>
      <th valign="top"><u>Linux</u><u><br>
        </u></th>
      <th valign="top"><u> Mac OS</u><u><br>
        </u></th>
      <th valign="top"><u>Windows</u><u><br>
        </u></th>
    </tr>
    <tr>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
        <blockquote>
          <pre>cd <i>virtualagc</i>/XCOM-I<br>make<br></pre></blockquote>Or:
<blockquote>
  <pre>make CC=clang EXTRA=-w</pre>
</blockquote>
</td><td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:
        <blockquote>
  <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w<br></pre></blockquote>Or:
<blockquote>
  <pre>make CC=gcc EXTRA="-w -std=c99"</pre>
</blockquote>
<blockquote>
        </blockquote>



      </td>
      <td valign="top"><a name="winInsane"></a>Open an MSYS2 command line.&nbsp; Then: &nbsp;<code>
        </code><blockquote>
          <pre><code>cd </code><code><i>virtualagc</i>/XCOM-I</code><code><br></code><code>make RDYNAMIC= EXTRA=-w</code><code> EXT=.exe<br></code></pre></blockquote><code>or<br>
</code>
<blockquote>
  <pre><code>make CC=clang EXTRA="-w" EXT=.exe<br></code><code></code><br></pre></blockquote>Or from a Visual Studio developer command line,<br>
<blockquote>
  <pre>make CC=cl<br></pre>
</blockquote>
<blockquote>
  <pre><code></code></pre>

</blockquote>

</td>
    </tr><tr>
  <th valign="top"><u>Build in Linux, for use in Windows</u></th>
</tr>
<tr>
  <td valign="top">Build for Windows, but test (requires WINE) on Linux. <br>

    <br>

Open a "terminal" (i.e., a command line).&nbsp; Then:<br>

    <blockquote>
  <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe</pre>
    </blockquote>

  </td>
</tr>

  </tbody>
</table>

<br>Having done this, you should see that all of the XPL compilers in 
the table of XPL compilers have now been created, such as XCOM3-360A.obj, and 
if all of the tests comparing them have been passed, you'll see messages
 similar to these:<br>
<blockquote>
  <pre>Bootstrapping XCOM3 -----------------------------------------<br>Files XCOM3-360.obj and XCOM3-360C.obj match within tolerance (2 &lt;= 4 mismatches)<br>Cross-comparison to output of legacy compiler successful<br>Files XCOM3-360.obj and XCOM3-360A.obj match within tolerance (1 &lt;= 4 mismatches)<br>Bootstrap of XCOM3 successful<br>Bootstrapping XCOM45 -----------------------------------------<br>Files XCOM45-360.obj and XCOM45-360C.obj match within tolerance (1 &lt;= 4 mismatches)<br>Cross-comparison to output of legacy compiler successful<br>Files XCOM45-360.obj and XCOM45-360A.obj match within tolerance (1 &lt;= 4 mismatches)<br>Bootstrap of XCOM45 successful<br></pre>
</blockquote>
You may wonder about the messages that some of the files were "within 
tolerance" for the IBM 360 object files.&nbsp; The object files are, of 
course, 
not text files, but rather are non-human-readable binary files.&nbsp; A 
perfect match, of course, would be if the files were the same length, 
and each byte of one file were identical to the corresponding byte of 
the other file.&nbsp; So why would it be okay if 1 or 2 bytes (as in the
 printout above) were different?<br>
<br>
Consider the following selection from the report the XPL compiler printed when generating the object file XCOM45-360C.obj:<br>
<blockquote>
  <pre> XPL COMPILATION---SUNY STONYBROOK---XCOM4.5 VERSION OF  <font color="#ff0000">JULY 19, 1976</font>.  CLOCK TIME = <font color="#ff0000">21:5:40.16</font>.<br><br>TODAY IS AUGUST 12, 2024.  CLOCK TIME = 15:6:40.38.<br><br>   1 I   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT      I  1286<br>   2 I      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */ I  1286<br>   3 I                                                                                I  1286<br>   4 I   /*  XPL PARSING TABLES  */                                                   I  1286<br>   5 I                                                                                I  1286<br>   6 I   DECLARE MAXTL LITERALLY '12' ;                                               I  1286<br>   7 I   DECLARE MAXNTL LITERALLY '26' ;                                              I  1286<br>   8 I   DECLARE STARTSTATE LITERALLY '112' ;                                         I  1286<br>   9 I   DECLARE NT LITERALLY '42' ;                                                  I  1286<br>  10 I   DECLARE NSY LITERALLY '92' ;                                                 I  1286<br>  11 I   DECLARE NSTATES LITERALLY '228' ;                                            I  1286<br>  12 I   DECLARE V(92) CHARACTER INITIAL ( '&lt; DUMMY &gt;', '&lt;', '(', '+', '|',           I  1286<br>⋮<br><br>TOTAL TIME IN COMPILER   0:0:1.51.<br>SET UP TIME              0:0:0.03.<br>ACTUAL COMPILATION TIME  0:0:1.33.<br>POST-COMPILATION TIME    0:0:0.15.<br>COMPILATION RATE: 198451 CARDS PER MINUTE.<br></pre>
</blockquote>
Notice the part I've highlighted in <font color="#ff0000">red</font>.&nbsp;
 The compilation report includes the date and time on which <i>the compiler generating the report</i>
 was compiled, which means that the compilation date and time 
must themselves be embedded in the executable of the XPL compiler ... 
which 
means that the same XPL compiler, if compiled on two different 
occasions, would have different timestamps embedded in its two object 
files.&nbsp; Since a 
timestamp requires 3 bytes for the time and 3 bytes for the date, that 
means that up to 6 bytes may differ simply due to an embedded timestamp.<br>
<br>
That's fine theory, all right, but can we see it happening in 
practice?&nbsp; I.e., were the bytes that were different really part of a timestamp?&nbsp; Here's a spot check:&nbsp; I've
 made hexadecimal dumps of 
the two of the object files that we want to be identical, and then used a
 file-comparison utility to compare
 the hex dumps side-by-side.&nbsp; Here's a screenshot of the <i>only</i> difference found between the two files, with <b>XCOM45-360.obj</b> on the left and <b>XCOM45-360A.obj</b> on the right:<br>

<br>

<img moz-do-not-send="true" src="XCOM45-360-meld.png" alt="" width="1580" height="89"><br>

<br>

In this case, only 3 bytes are different.&nbsp; <b>XCOM45-360.obj</b> was 
built (according to the report it printed out when I made the screenshot above) at time 19:53.37.27, while
<b> XCOM45-360A.obj</b> was built at 17:5:6.24 on the same date.&nbsp; <b>XCOM</b> gets the 
compile time using <a moz-do-not-send="true" href="XPL-I.html#builtin">the XPL built-in function <font color="#663300"><code>TIME_OF_GENERATION</code></font></a>,
 which returns the number of centiseconds since midnight.&nbsp; For 
<b>XCOM45-360.obj</b>, that computes to 
100*(19*3600+60*53+37.27)=7161727=0x6D477F.&nbsp; Similarly, for 
<b>XCOM45-360A.obj</b>, 100*(17*3600+5*60+6.24)=6150624=0x5DD9E0.&nbsp; Both perfectly match the screenshot above.&nbsp; (Incidentally, IBM 
360 programs all store their integer data in <i>big-endian</i> form, so that the most-significant bytes come first in memory.)&nbsp; Q.E.D.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; By the way, <b>XCOM3</b>
 has plenty of quirks specific to it, quite aside from any quirks XPL 
more-generally may have as a computer language.&nbsp; <b>XCOM3-native</b> and <b>XCOM3-360</b> inherit these quirks.&nbsp; I mention this 
just in case you become excited about using <b>XCOM3-native</b> and start writing new XPL programs for it!&nbsp; Here are a few quirks I've noticed:</font><br>
  <font size="-1">
  </font>
  
  <ul><li><font size="-1">It only accepts upper-case for identifiers and keywords ... in spite of the fact that XPL is case-<i>in</i>sensitive and that every speck of XPL source code in <i>A Compiler Generator</i> is printed in lower case! <br>
</font></li><li><font size="-1">It requires an <font color="#663300"><code>EOF</code></font>
 token at the end of the source code. </font><font size="-1"><br>
  </font></li><li><font size="-1">It won't allow you to have two division operations (including <font color="#663300"><code>MOD</code></font> as a division) in the same statement, instead emitting an error message saying that it requires a "busy register".</font></li></ul></blockquote>
<blockquote>
</blockquote>


<blockquote>
</blockquote>
<h1><a name="halsfc"></a>How to Build HAL/S-FC<br>

</h1>

Hopefully you're now convinced that <b>XCOM-I</b> works reasonably correctly, at least in so far as compiling <i>standard</i> XPL programs is concerned.&nbsp; But we'll do one last test, and it's a big one! <br>
<br>
Recall that our motivation in creating <b>XCOM-I</b>
 was to compile XPL/I programs, and in particular to be able to compile 
the original HAL/S compiler for Space Shuttle flight software, which was
 known as <b>HAL/S-FC</b> back in the day, or <b>HALSFC</b> in its modern incarnation.&nbsp; While usage of <b>HALSFC</b> is the subject of <a moz-do-not-send="true" href="HAL.html">a different web page</a>, we'll talk about how to compile <b>HALSFC</b> itself here.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; The dedicated <b>HALSFC</b> web page <i>also</i>
 has compilation instructions, but they're different than the ones 
presented here, because the audience for them is different.&nbsp; Either
 set of instructions will work.&nbsp; The ones here provide more 
flexibility in terms of debugging HAL/S-FC itself.</font><br>
</blockquote>
Once again, a Makefile has been provided that performs the entire 
compilation, as well as compiling a short HAL/S test file, and doing a 
regression test of the HAL/S compiler's outputs vs an earlier build of 
the same test file on my own Linux box.&nbsp; Admittedly, the regression
 test only compiles a very simple HAL/S test program, which looks like 
this:<br>
<blockquote>
  <pre><font color="#663300"><code>DEBUG ¢0¢3¢4¢5¢6¢8¢9¢C¢D¢E¢F H(202)</code><code><br></code><code> </code><code><br></code><code> HELLO: PROGRAM;</code><code><br></code><code>    DECLARE I INTEGER;</code><code><br></code><code>    DECLARE MY_NAME CHARACTER(20) INITIAL('RON BURKEY');</code><code><br></code><code>    DECLARE INTEGER, J;</code><code><br></code><code>    REPLACE PRINTER BY "6";</code><code><br></code><code>    WRITE(PRINTER) 'THE BEGINNING';</code><code><br></code><code>    DO FOR I = 1 TO 5;</code><code><br></code><code>       WRITE(PRINTER) I, 'HELLO, WORLD!';</code><code><br></code><code>       DO FOR J = 2 TO 8 BY 2;</code><code><br></code><code>          WRITE(PRINTER) J, MY_NAME, 'SAYS ISN''T THIS FUN?';</code><code><br></code><code>       END;</code><code><br></code><code>    END;</code><code><br></code><code>    WRITE(6) 'THE END';</code><code><br></code><code> CLOSE HELLO;</code></font><br></pre>
</blockquote>
But a test is a test, right?&nbsp; You may notice that HAL/S bears a 
creepy similarity to XPL/I.&nbsp; The similarity is superficial, and the
 two languages are quite different in reality.<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">




  <tbody>
    <tr>
      <th valign="top"><u>Linux</u><u><br>
        </u></th>
      <th valign="top"><u> Mac OS</u><u><br>
        </u></th>
      <th valign="top"><u>Windows</u><u><br>
        </u></th>
    </tr>
    <tr>
      <td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
        <blockquote>
          </blockquote>
<blockquote>
  <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet regression<br></pre>
</blockquote>

Or:<br>
<blockquote>
  <pre>make -s XEXTRA=--quiet CC=clang EXTRA=-w regression</pre>
</blockquote>


</td><td valign="top">Open a "terminal" (i.e., a command line).&nbsp; Then:
        <blockquote>
  </blockquote>
<blockquote>
  <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet CC=clang EXTRA=-w regression<br></pre>
</blockquote>

Or:
<blockquote>
  <pre>make -s XEXTRA=--quiet CC=gcc EXTRA="-w -std=c99" regression
</pre>
</blockquote>

<blockquote>
        </blockquote>



      </td>
      <td valign="top">Open an MSYS2 command line.&nbsp; Then:
        <blockquote>
          </blockquote>
<blockquote>
  <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet RDYNAMIC= regression<strike><br></strike></pre>
</blockquote>

Or from a Visual Studio developer command line,<br>
<blockquote>
  <pre>make -s XEXTRA=--quiet CC=cl regression<strike><br></strike></pre>
</blockquote>


      </td>
    </tr><tr>
  <th valign="top"><u>Build in Linux, for use in Windows</u></th>
</tr>
<tr>
  <td valign="top">Builds for Windows, but tests (requires WINE) on Linux. <br>


    <br>


Open a "terminal" (i.e., a command line).&nbsp; Then:<br>


    <blockquote>
  </blockquote>
    
<blockquote>
  <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet CC=x86_64-w64-mingw32-gcc EXT=.exe regression<br></pre>
</blockquote>


  </td>
</tr>

  </tbody>
</table>

<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; By the way, <code>XEXTRA</code> is something you can use on a make command line to pass extra options to <b>XCOM-I</b>, while <code>EXTRA</code> can be used to pass extra options to the C compiler.&nbsp; In particular, the <code>--quiet</code> in <code>XEXTRA</code> is a way to eliminate certain informative messages from <b>XCOM-I</b> that (after seeing them a hundred times) I personally no longer find quite so informative and would rather not see any longer.</font><br>
</blockquote>
If everything was found to be successful, you should see messages that terminate with lines similar to these:<br>
<blockquote>
  <pre>⋮<br>Processing regression/HELLO ==========================================<br>Comparing ...<br>Files cA.rpt and pyA.rpt are identical<br>Files ../../ported/FILE1.bin and halmat.bin are identical<br>Files ../../ported/LISTING2.txt and listing2.txt are identical<br>Files pass1-new.rpt and pass1-old.rpt are identical<br>Files halmat.bin and regression/halmat.bin are identical<br>Files litfile.bin and regression/litfile.bin are identical<br>Files listing2.txt and regression/listing2.txt are identical<br>Files COMMON-PASS1-new.out and COMMON-PASS1-old.out are identical<br>Files optmato.bin and regression/optmato.bin are identical<br>Files auxmata.bin and regression/auxmata.bin are identical<br>Files pass2-new.rpt and pass2-old.rpt are identical<br>Object-code cards okay<br>Files COMMON-PASS2-new.out and COMMON-PASS2-old.out are identical<br>Regression test passed.<br></pre>
</blockquote>
You should also find 5 new executable files:<br>
<ol>
  <li><b>PASS1[.exe]</b></li>
  <li><b>FLO</b><b>[.exe]</b></li>
  <li><b>OPT</b><b>[.exe]</b></li>
  <li><b>AUXP</b><b>[.exe]</b></li>
  <li><b>PASS2</b><b>[.exe]</b></li></ol>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; This isn't actually a <i>full</i> build of <b>HAL/S-FC</b>, but merely of the compiler passes needed to run the regression test.&nbsp; You could have gotten the additional passes <b>PASS3</b> and <b>PASS4</b>, along with the BFS versions of the passes (discussed later),&nbsp; namely <b>PASS1B[.exe]</b>, <b>OPTB[.exe]</b>, <b>PASS2B[.exe]</b>, and <b>PASS3B[.exe]</b>, by using the <b>make</b> targets "<font color="#663300"><code>all regression</code></font>" rather than just "<font color="#663300"><code>regression</code></font>" in the instructions above.</font><br>
</blockquote>
These passes of <b>HAL/S-FC</b> are chained together to perform a full compilation of a HAL/S program.&nbsp; For those passes having <i>two</i> programs listed, (<b>xxxx</b> and <b>xxxxB</b>), the B version is used when compiling Backup Flight Software, whereas the non-<b>B</b> version is used for compiling the Primary Flight Software; if there's no <b>B</b> version, then the non-<b>B</b>
 version is used for both primary and backup.&nbsp; I'd note that 
there's something like 700K lines of XPL/I code in this compilation, so 
it's a non-negligible test of the XPL/I compiler ... assuming of course,
 that the HAL/S compiler actually works correctly once installed.<br>
<br>
But again, there's a dedicated <b>HALSFC</b> page covering these topics in more detail, so I'll not discuss them further here.<br>

<h1><a name="xpli"></a>The Peculiarities of Standard XPL and Intermetrics XPL/I</h1>


<p>It is a truth universally acknowledged that there is no satisfactory 
introductory information available concerning programming in XPL.&nbsp; 
Or at least, it <i>would</i> be universally acknowledged if anybody had ever heard of XPL and wanted to use it for anything.&nbsp; <br></p>
<p>The best you can do, generally speaking, is to purchase an out-of-print, used copy of the book <i>A Compiler Generator</i>.&nbsp;
 If you do, you'll find a book that's densely packed with information, 
but that information is the source code for an XPL compiler (written in 
XPL), lots of BNF descriptions of the language, lots of theory on how to
 write a compiler-generator program, and very little of direct interest 
to a programmer who wants to come up to speed quickly on how to write or
 understand a program written in XPL.  Not to mention the fact — though I
 <i>am</i> mentioning it! — that some of the most-critical 
counter-intuitive information is buried in easy-to-miss, 
easy-to-misunderstand comments made in passing, rather than as big, 
bold-face warnings. &nbsp; As a bonus, the book provides an index of
 almost no use at all to a newby XPL programmer.&nbsp; Beyond the book itself, 
most <i>online</i> information about XPL, in my experience, is simple condensing or other rehashing of <i>A Compiler Generator</i>,
 and adds little extra of value in a tutorial sense, since it's almost 
never written by anybody actually working with XPL.&nbsp; With that 
said, you may find some useful online information in a couple of places:<br></p>

<ul>
  <li>&nbsp;<a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel Weaver provides some documentation (in particular, his xpl.pdf) with his XPL-to-C translator program</a>.</li>
  <li>The <a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/ldindex.html">University of Toronto XPL website has a page</a> with a small but useful transcription of some material from <i>A Compiler Generator</i> — albeit with unfortunate HTML formatting that make some of it almost unreadable.</li>
</ul>
<p>And as for Intermetrics XPL/I ... well, from a tutorial perspective, 
it's orders of magnitude worse. From the standpoint of <i>surviving</i> documentation, XPL/I may as well never have existed at all.<br>
</p>

<p>Taking all of that into account, I wish I could provide a 
full tutorial here how to write XPL or XPL/I programs, similar in nature to Michael Ryer's book <i>Programming in HAL/S</i>.&nbsp;
 But there's so little to do, and so much time.&nbsp; No, scratch that, 
the other way around!&nbsp; There's just not enough time, and maybe not 
enough skill.&nbsp; So for now, I'll just 
cover some of the quirks of the language(s) that might be unexpected to 
programmers already skilled in other programming languages.  Send in 
suggestions for improvement, if you like; I'm sure I can use them 
somehow to make the discussion even worse.
</p>

<h2>Character Set and Modern Character Substitutions<br>

</h2>

<p>The most basic characteristic of a language is the character set in 
which the language is expressed.&nbsp; Above all else, we need to 
recognize that IBM 360 computers encoded textual information using 
so-called EBCDIC coding, which defined somewhat-different characters 
than the ASCII coding common today, as well as entirely different 
numerical codes for the characters it did include.<br>
</p>
<p>Neither <i>A Compiler Generator</i> nor Intermetrics
 specifies the character set.&nbsp; I've given it a lot of thought, and 
my conclusion is that the originally-supported character set was:
</p>

<p align="center">&lt;space&gt;<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>0 1 2 3 4 5 6 7 8 9<br>_ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ?  [ ] { }<br>¢ ¬ &lt;eof&gt;<br>
</p>
<p>Here, by &lt;space&gt; I mean a space character, and by &lt;eof&gt; I mean an end-of-file character.<br>
</p>
<p>You'll notice that several characters common today were not originally supported, including:</p>

<p align="center">` ~ ^ \<br>
</p>

<p>Contrariwise, there are three characters (¢, ¬, and &lt;eof&gt;) that
 don't exist at 
all in the 7-bit ASCII character set that's the common core for the 
character sets typically used today when writing software source 
code.&nbsp; The first two are EBCDIC characters, while the third isn't 
even EBCDIC, but merely something which could be encoded on 
punchcards.&nbsp; <b>HAL/S-FC</b> somewhat arbitrarily assigned it the non-existent "EBCDIC" code 0xFE.</p>
<p>Therefore, when working with <b>XCOM-I</b>, we use the fortunately otherwise-unused ASCII characters in place of the unsupported characters:<br>
</p>

<ul>
  <li>The 
ASCII characters ~ and ^ are used interchangeably with ¬, but XCOM-I prefers (and transparently replaces them by) ~.&nbsp; <br>
  </li>
  <li>Similarly, we use the ASCII character ` in preference to ¢.&nbsp; </li>
  <li>Finally, the ASCII \ character is now used in place of &lt;eof&gt;, which was a character that could be punched on the 
punch cards, but had no printable representation. <br>
</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; The &lt;eof&gt; <i>character</i> — not to be confused with the <font color="#663300"><code>EOF</code></font> <i>token</i> that appears at the end of the source code in an XPL or XPL/I program — 
 is an unusual case.&nbsp; It is not a special character in XPL 
programs.&nbsp; However, it is used as a bookkeeping device by HAL/S 
compilers, or at least by <b>HAL/S-FC</b>, in padding that the HAL/S 
compiler automatically appends to a stream of input HAL/S source 
code.&nbsp; Thus we have to have a way of representing it in the XCOM-I 
framework, even though it's not a character anyone would ever have 
occasion to use in either an XPL or HAL/S source-code file, unless that 
file was itself part of a HAL/S compiler!&nbsp; To the best of my 
knowledge, &lt;eof&gt; appears only within a single string variable, <font color="#663300"><code>INPUT_PAD</code></font>, that occurs in the <b>HAL/S-FC</b>
 source-code file STREAM.xpl.&nbsp; See the comments for </font><font size="-1"><font size="-1"><font color="#663300"><code>INPUT_PAD</code></font></font> in STREAM.xpl.</font><br>
  </p>
</blockquote>
<p>These substitutions allow 
us to completely translate the original XPL or XPL/I source code 
back-and-forth between the original EBCDIC and ACII without any loss of 
information, and without insisting that you adopt any specific "locale" 
like ISO-8859-15 or UTF-8 for your computer that's not optimal for your 
other (non-XPL'ing) activities.&nbsp; With that said, I <i>hope</i> that you could use ¢ and ¬ in your XPL/I source code, if you insist on doing so, but I do not guarantee it. <br></p>

<blockquote>
  <p><font size="-1"><b>Aside:</b> All previously-existing XPL or XPL/I 
source code files I've found, or HAL/S source code for that matter, has 
already substituted ~ or ^ for ¬ anyway.  And indeed, some early HAL/S 
documentation suggests this very substitution.  I suspect that's because
 some IBM printers at the time printed ~ in place of </font><font size="-1"><font size="-1">¬</font>.  But whatever the explanation, the substitutions I'm suggesting are not exactly daring in their originality.  As far as the </font><font size="-1">¢
 symbol is concerned, it's not actually used in XPL or XPL/I 
code, as far as I know, but it is used in HAL/S, so we still need to have a reliable way of dealing with it.<br>
</font></p>
</blockquote>

<h2>Case Sensitivity</h2>

<p>XPL programs are <i>not</i> case-sensitive, except in so far as the 
contents of quoted strings are concerned.&nbsp; E.g., lower-case or 
mixed-case symbols are treated as being identical to their upper-case 
correspondents, but quoted strings are case-sensitive.<br></p>
<h2>Source-Code Formatting<br>

</h2>

<p>Input to an XPL or XPL/I program (via the <font color="#663300"><code>INPUT</code></font>
 built-in function) is expected to conform to computer punch-card-like 
conventions.  I.e., input lines are always exactly 80 characters long, 
and <b>XCOM-I</b> enforces this by truncating or right-padding input 
lines as necessary.  If the input lines are longer than 80 columns 
physically — say, because they have punch-card sequence numbers in 
columns 81-88 — the extra columns are stripped off.<br></p>
<p>As for the source-code proper, other than being confined to columns 
1-80, it is entirely free-form.  I.e., line breaks are ignored; several 
statements may exist on the same input card, or conversely, a single 
statement may be split across multiple cards.  Even though XPL <font color="#663300"><code>CHARACTER</code></font> strings are limited to 256 characters, there is seemingly no limit to the length of an XPL statement.<br></p>
<p>There are hints in the error messages of <b>XCOM3</b> (and I believe, in <i>A Compiler Generator</i> text) that <i>some</i>
 contemporary computer systems may have treated column 1 specially, 
perhaps accepting some kind of non-blank control characters there.  If 
so, it was a issue outside <b>XCOMx</b> proper and is irrelevant to <b>XCOM-I</b>.
  However, you do find that legacy XPL source code does often begin in 
column 2 rather than column 1, and I suspect that this hypothetical 
column-sensitivity is the reason for it.<br></p>
<p>Regarding this column-1 ambiguity, however, there is the practical 
question of what to do when a long quoted string is split across 
multiple cards.  Does column 1 belong to the string or not?  In <b>XCOM-I</b>, I take my cue from <b>XCOM3</b> source code in this matter:  In spite of the fact that <b>XCOMx</b>'s source code generally avoids column 1 in all other cases, column 1 <i>does</i> belong to any multi-line quoted strings.<br></p>

<h2>Identifiers</h2>

<p>Identifiers cannot begin with a digit, but otherwise consist of any sequence of upper- or lower-case alphanumeric characters, <i>or</i> any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a legal name for a variable.
</p>
<p>Identifiers cannot exceed 256 characters in length.
</p>

<p></p>
<h2>The Basic XPL Datatypes</h2>

<p>There are only three basic datatypes:<br></p>

<ul>

  <li><font color="#663333"><code>FIXED</code></font> is a 32-bit signed
 integer.&nbsp; (Stored as 2's-complement, in big-endian byte order, vs 
the little-endian byte order used in most personal computers today.)<br></li><li><font color="#663333"><code>CHARACTER</code></font>
 is a variable-width character string, with a string-length limited to 
256 or less.&nbsp; Strings are stored as a 32-bit unsigned integer known
 as a <i>descriptor</i>, paired with a separate area from 1 to 256 bytes
 containing the individual characters of the string, encoded in 
EBCDIC.&nbsp; The descriptor has 8 bits specifying the string length 
(minus 1) and 24-bits providing the starting memory-address of the 
character data.&nbsp; The string descriptor 0x00000000 is a special case, and indicates an empty string.<br>
</li><li><font color="#663333"><code>BIT(<i>n</i>)</code></font>, where <i><font color="#663333"><code>n</code></font></i> is from 1 to 2048, is an <font color="#663333"><code>n</code></font>-bit object.&nbsp; The amount of storage varies by the precision:</li><ul><li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>B(8)</code></font> are stored in memory as single bytes.</li><li><font color="#663333"><code>BIT(9)</code></font> through <font color="#663333"><code>BIT(16)</code></font> are stored as 2-byte "half-words".</li><li><font color="#663333"><code>BIT(17)</code></font> through <font color="#663333"><code>BIT(32)</code></font> are stored as 32-bit words.</li>
  <li><font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> are stored similarly to <font color="#663300"><code>CHARACTER</code></font>
 variables: There's a 32-bit "descriptor", of which 8 bits is the number
 of bytes needed to store all of the bits, minus 1, and 24 bits area 
pointer to elsewhere in memory, where the bytes themselves are stored.  
Thus, a long <font color="#663300"><code>BIT(n)</code></font> like this uses up 4 bytes for the descriptor, plus ⌊(n+7)/8⌋ bytes (5 for n=33 through 256 for n=2048) for the data. </li>
</ul>
</ul>Regarding the <font color="#663300"><code>BIT(<i>n</i>)</code></font> datatypes, you might suppose that since one has gone to all the trouble to define separate datatypes like <font color="#663300"><code>BIT(1)</code></font>, <font color="#663300"><code>BIT(2)</code></font>, ..., <font color="#663300"><code>BIT(8)</code></font>, that there is some distinction between them.&nbsp; That they behave differently in some way.&nbsp; That there's some <i>reason</i>
 for making such a distinction.&nbsp; You would be cruelly mistaken, as I
 was.&nbsp; There is literally no difference between these 8 
datatypes.&nbsp; Nor is there any distinction between the 8 datatypes <font color="#663300"><code>BIT(9)</code></font> through <font color="#663300"><code>BIT(16)</code></font>.&nbsp; Nor is there any distinction between the 16 datatypes <font color="#663300"><code>BIT(17)</code></font> through <font color="#663300"><code>BIT(32)</code></font>.&nbsp; The distinctions between the <font color="#663300"><code>BIT(<i>n</i>) </code></font>datatypes for <font color="#663300"><code><i>n</i>&gt;32</code></font> are left as a thought experiment for the reader.&nbsp; Thus we're left with seemingly ridiculous code, like the following from <b>PASS1</b> of <b>HAL/S-FC</b>:<br>


<blockquote>
  <pre><font color="#663300">DECLARE COMPILING BIT(1);
...<br>IF (COMPILING&amp;"80")^=0 THEN<br>    ...</font><br></pre>
</blockquote>
<p>Or in other words, first you declare <font color="#663300"><code>COMPILING</code></font>
 to have a single bit, and then later you check it to see what the value
 of its 8th bit is!&nbsp; This particular bit of hilarity caused me 
months worth of trouble.<br>
</p>
<p>The storage formats in memory duplicate those that would have been 
expected on an IBM System/360 computer.&nbsp; While the storage formats are 
not significant in abstract terms, they'll be seen to be <i>quite</i> significant in dealing with certain aspects of <b>HAL/S-FC</b>'s source code, such as its so-called "virtual memory" system, and indeed I think it would be impossible to run <b>HAL/S-FC</b> unless these underlying IBM 360 storage formats were used.<br></p>
You'll notice that there is no floating-point datatype, a fact which will be discussed in some detail later. <br>
<br>

The three basic datatypes can also be incorporated into single-dimension arrays. 
Multi-dimensional arrays are not allowed.&nbsp; There is no maximum 
array length beyond the available memory.&nbsp; Array indices start at 
0.&nbsp; Indices (or "subscripts") are enclosed in parentheses, as in <font color="#663300"><code>A(3)</code></font> or <font color="#663300"><code>B(N)</code></font>.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> It's easy to become confused and to imagine (incorrectly!) that you can treat a <font color="#663333"><code>CHARACTER</code></font> variable (as opposed to an array of <font color="#663333"><code>CHARACTER</code></font>
 variables) as an array itself, in order to access its individual 
characters.&nbsp; You cannot!&nbsp; In fact, the XPL language does not 
provide <i>any</i> syntactical means to access individual characters of a
 string.&nbsp; For that, you must rely on built-in functions provided by
 the runtime library.&nbsp; The most-direct method is to use the <font color="#663300"><code>BYTE</code></font> function, which can either retrieve the EBCDIC numerical encoding of an individual character in a <font color="#663333"><code>CHARACTER</code></font> variable, or else to store a new EBCDIC numerical value at a given position in a <font color="#663333"><code>CHARACTER</code></font> variable.&nbsp; Thus if we had a <font color="#663333"><code>CHARACTER</code></font> variable <font color="#663300"><code>C</code></font> which held the value 'HELLO!', then <font color="#663300"><code>BYTE(C, 3)</code></font> would return 211 (the EBCDIC encoding for the letter 'L'), while the assignment statement "<font color="#663300"><code>BYTE(C, 3) = 198;</code></font>" would change the contents of <font color="#663300"><code>C</code></font>
 to 'HELFO' since 198 is the EBCDIC code for the letter 'F'.&nbsp; That 
sounds cumbersome, since very few of us have memorized the EBCDIC table,
 but it's really not.&nbsp; You generally don't have to look up the 
EBCDIC encoding for anything, because you would actually have programmed
 operations such as this as "<font color="#663300"><code>BYTE(C, 3) = BYTE('F');</code></font>".&nbsp; Another, less-generally-useful method would be to use the built-in <font color="#663300"><code>SUBSTR</code></font> function to retrieve a specific character position as a new <font color="#663300"><code>CHARACTER</code></font> object of length 1.<br></font></blockquote><font size="-1">
    </font>The <font color="#663333"><code>BIT(N)</code></font> datatype is actually quite problematic.&nbsp; It would be reasonable to assume that since <font color="#663333"><code>BIT(N)</code></font>
 seems to represent support for collections of bits, then XPL should 
provide some syntactical sugar for reading the values of these bits or 
modifying them.&nbsp; For <font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>, you'd be somewhat correct, in that XPL largely treats these as being interchangeable with integers (i.e., <font color="#663333"><code>FIXED</code></font>), and automatically converts them back and forth between <font color="#663333"><code>FIXED</code></font>.&nbsp; The runtime library's built-in logical-shift-left and logical-shift-right functions (<font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font>) work just as easily with them as with the <font color="#663333"><code>FIXED</code></font>, as do the logical operators <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> (<font color="#663300"><code>~</code></font>), and the relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>=</code></font>, <font color="#663300"><code>!=</code></font>, <font color="#663300"><code>&gt;=</code></font>, and <font color="#663300"><code>&lt;=</code></font>.&nbsp; Swell!<br>
<br>
But once you advance to <font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>, you are cruelly disappointed. &nbsp; XPL provides <i>no</i> built-in methods of working with this data <i>qua</i> bits, beyond the ability to initialize <font color="#663333"><code>BIT(N)</code></font>
 variables with data when they're declared.&nbsp; (More on that 
later.)&nbsp; As far as actually using this data for anything, there are
 no built-in means to do anything at all with that data.&nbsp; While you
 <i>can</i> manipulate the data by cobbling together various 
runtime-library memory-access functions, <i>A Compiler Generator</i> gives none of the 
technical information about the storage format that would allow you to 
do so, in so far as I was able to discover.<b>&nbsp; </b>What do I mean about cobbling together memory-access functions?&nbsp; Well, suppose that you want to access bit 43 of a <font color="#663300"><code>BIT(86)</code></font> variable called <font color="#663300"><code>B</code></font>.&nbsp; First, you must know where the data for <font color="#663300"><code>B</code></font>
 is located in memory.&nbsp; There's a function that can tell you 
that.&nbsp; Then you must know which byte in that block contains bit 
43.&nbsp; There's no function that tells you that, but if you <i>do</i> 
know it somehow then there's a function that gives you the value of a 
byte at that address.&nbsp; Then you must know which bit in the byte 
corresponds to bit 43.&nbsp; Again, there's no function for that, but if
 you know it, then you can use library functions like <font color="#663300"><code>SHL</code></font> or <font color="#663300"><code>SHR</code></font>, probably in conjunction with a logical operator like <font color="#663300"><code>&amp;</code></font>,
 to isolate the value of that bit.&nbsp; If you wanted to change the 
value of that bit, different but similar awfulness is involved.<br>
<br>
But doing any of that requires that you have intimate knowledge of how such <font color="#663333"><code>BIT</code></font>
 data is packed into memory.&nbsp; It's hard to write unambiguously 
about these matters, but I'll try to do so using the following 
concepts:&nbsp; An <i>n</i>-bit value, when written out in human-readable form has a <i>leftmost</i> bit and a <i>rightmost</i> bit; meanwhile, a block of <i>m</i> bytes in memory has a byte that's at the <i>lowest</i> address, a byte at the <i>highest</i> address, and within each byte has a <i>most-significant</i> bit and a <i>least-significant</i> bit.&nbsp; With those ideas in mind, here's how XPL packs <font color="#663333"><code>BIT</code></font> data into memory:<br>
<ul>
  <li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>:  The rightmost bit corresponds to the least-significant bit in the byte at the highest address.</li>
  <li><font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>:  The leftmost bit corresponds to the most-significant bit in the byte at the lowest address.</li>
</ul>
Or to put it concisely if ambiguously, short bit strings are right justified, while long bit strings are left justified.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Since I say that the 
bit-packing is undocumented, what's my justification for claiming that 
what I said just above is true?&nbsp; The short answer is 
trial-and-error!&nbsp; The longer answer is that one of the intermediate
 milestones in trying to get <b>XCOM-I</b> to the point of being able to compile the original source code for <b>HAL/S-FC</b> was first to be able to compile <b>XCOM3</b>
 and run it with a verifiably correct result.&nbsp; (Recall "insane bootstrapping" from earlier.)&nbsp; But I couldn't get 
it to work!&nbsp; After messing with it for days on end, I eventually 
got the answer in a dream, and then experimented with a couple of 
different bit-packing schemes before finally getting <b>XCOM3</b> to run properly.&nbsp; The packing scheme I describe above is the one that worked.</font><br>
</blockquote>
<font size="-1"></font>
<blockquote><font size="-1">
    <b>Aside:</b> If all that wasn't bad enough, there's also a trap waiting for you if you're already used to doing bit manipulations 
with logical operators and shifts in other computer languages.&nbsp; This trap is in the behavior of 
conditional tests in XPL's <font color="#663300"><code>IF</code></font> and <font color="#663300"><code>DO WHILE</code></font> statements.&nbsp; Conditional tests in these statements depend only on the <i>least significant</i> bit; i.e., it as if any conditional test involves an extra "<font color="#663300"><code>&amp; 1</code></font>" operation that you can't see.&nbsp; Thus if you wanted to detect (say) that bit 3 of the <font color="#663300"><code>BIT(5)</code></font> variable <font color="#663300"><code>A</code></font> was set, a statement like "<code><font color="#663300">IF A &amp; 8 THEN ...;</font></code>" wouldn't help you at all, since the implicit </font><font size="-1"> "<font color="#663300"><code>&amp; 1</code></font>" in the conditional would cause the test always to fail!&nbsp; You would instead need to use a shift-right operation, such as </font><font size="-1"><font size="-1">"<code><font color="#663300">IF SHR(A, 3) THEN ...;</font></code>". </font></font><font size="-1"><font size="-1"><br>
    </font></font></blockquote>


But enough of these measly <font color="#663333"><code>BIT</code></font>-based frustrations!<br>
<br>
Variables in general are <i>supposedly</i> strictly typed, and every 
variable used 
must have an associated declaration statement.&nbsp; This is a 
particularly comical assertion when you consider the effect that I call <i>subscripting sloppiness</i>.&nbsp; Suppose you had the 
following brief example of a program:<br>

<blockquote>
  <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
</blockquote>

What is this little example supposed to do?&nbsp; First, it declares 3 variables of the <font color="#663333"><code>fixed</code></font> datatype; <font color="#663333"><code>fixed</code></font> means that <font color="#663333"><code>x</code></font>, <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font> are 32-bit signed integers.&nbsp; It then proceeds to use <font color="#663333"><code>x</code></font>
 <i>as if</i> it were a three-element array, though <font color="#663333"><code>x</code></font> wasn't declared that 
way, assigning values to each of its elements.&nbsp; The program simply assumes that <font color="#663333"><code>x(0)</code></font> corresponds to <font color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font> corresponds to <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>x(2)</code></font> corresponds to <font color="#663333"><code>z</code></font>.&nbsp; Finally, the program "prints out" both the elements of <font color="#663333"><code>x</code></font> (as an array) and the values of <font color="#663333"><code>x</code></font> (as a non-array), <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those two lines of printout are identical.&nbsp; In case you're wondering, we <i>could</i> have used <font color="#663300"><code>z(-1)</code></font> as an equivalent to <font color="#663300"><code>y</code></font>, or <font color="#663300"><code>z(-2)</code></font> as <font color="#663300"><code>x</code></font>.&nbsp; For that matter, we could have used this feature to read or write areas of memory in which no 
variables at all had been declared.&nbsp; Or to a certain extent, if we had declared 
variables of some other datatype than <font color="#663333"><code>FIXED</code></font>, we could have used this same trick to access them as if they were <font color="#663333"><code>FIXED</code></font>.<br>
<br>
Subscripting sloppiness indeed!<br>
<br>
Here are a few examples of declarations of variables, both scalar and array:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
</blockquote>

These are pretty self-explanatory in most ways, so I won't dissect them 
for you in detail.&nbsp; What's perhaps most confusing is that the three
 arrays declared here (<font color="#663300"><code>FS</code></font>, <font color="#663300"><code>CS</code></font>, and <font color="#663300"><code>BS</code></font>) each have <i>eleven</i>
 elements in them, because the number 10 in their declarations is not 
the number of elements, but rather the highest legal index.&nbsp; As 
mentioned above, indices start at 0, so the total number of elements in 
each is 11. <br>
<blockquote><font size="-1"><b>Aside:</b> Standard XPL, as in <i>A Compiler Generator</i>, doesn't allow expressions when expressing array sizes, whereas
 XPL/I does allow them.&nbsp; For example, the following is fine in 
XPL/I but is a no-no in XPL:<br>
  </font>
  <blockquote>
    <pre><font size="-1">DECLARE BUFFER(3600-1) BIT(8);<br></font></pre>
  </blockquote>
  <font size="-1">This example will be continued in the next section, 
where it will make a little more sense, but this is actually the kind of
 thing you might want to do.</font><br>
</blockquote>


There are additional attributes which can be applied to such declarations, of which the most important is probably <code><font color="#663300">INITIAL</font></code>.&nbsp; This attribute allows you to supply an initial value for the variable, such as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED INITIAL(22), F2 FIXED INITIAL("22"), F3 FIXED INITIAL("(8) 22");<br>DECLARE C CHARACTER INITIAL('Hello!');<br>DECLARE B BIT(5) INITIAL("(1) 10100");<br>DECLARE FS(10) FIXED INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);</font><br></pre>
</blockquote>
It's important to understand that the initializer has its affect only at
 compile-time, and is not applied at run-time.&nbsp; That means that if 
you declare variables within a <font color="#663300"><code>PROCEDURE</code></font>, they're <i>not reinitialized</i> each time the <font color="#663300"><code>PROCEDURE</code></font> is executed.<br>
<br>
You may have been confused by the initializers shown above for the variables <font color="#663300"><code>F2</code></font>, <font color="#663300"><code>F3</code></font>, and <font color="#663300"><code>B</code></font>,
 since they naively appear to be strings instead of numbers; but the 
naive interpretation is wrong.&nbsp; Which brings up the nature of <i>literals</i> in XPL:<br>
<ul>
  <li><code><font color="#663300">CHARACTER</font></code> literals — 
i.e., text strings — are enclosed in single-quote (') characters.  If a 
single-quote itself must appear within the string, you use two 
single-quotes in succession.  For example: <font color="#663300"><code>'I am the ''king'' of the world!'</code></font>.</li>
  <li>Integer literals for <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(N)</code></font> have one of several forms:</li>
  <ul>
    <li>A sequence of decimal digits is interpreted as a non-negative 
number in base-10 in the usual way.  Note that a leading minus sign (-) 
or plus sign (+) is <i>not</i> part of a numeric literal!  In XPL, minus signs are only <i>operators</i>, and thus something like <font color="#663300"><code>-10</code></font>
 is not a literal for the number -10, but is instead the minus operator 
followed by the literal for the number 10.  In most cases this is a 
distinction without significance, because <b>XCOM-I</b> (or the original <b>XCOMx</b>)
 automatically tries to perform all computations that are possible at 
compile time.  Nevertheless, this distinction does cause some 
arithmetically-satisfactory expressions to be syntactically illegal in 
XPL.  For example, the expression <font color="#663300"><code>5 + -5</code></font> isn't legal in XPL, and would need to be <font color="#663300"><code>5 + (-5)</code></font>
 instead.&nbsp; The plus sign is also only an operator, but unlike the 
minus sign (which can be either a binary or a unary operator), the plus 
sign is only a binary operator.&nbsp; So even an expression like "<font color="#663300"><code>(+5)</code></font>" would be illegal.<br>
</li>
    <li>A sequence of hexadecimal digits enclosed in double-quote (") 
characters represents a hexadecimal number.  Spaces are ignored within 
literals like this, and hence can be added at will for improved human 
readability.</li>
    <li>If a double-quoted string is preceded (within the quotes) by a 
parenthesized decimal number, then that number indicates the number of 
bits represented by each digit.  <b>XCOM-I</b> supports only the following cases:</li>
    <ul>
      <li>"(1) ..." (with digits 0-1 and spaces) is a binary number.</li>
      <li>"(2) ..." (with digits 0-3 and spaces) is a base-4 number.</li>
      <li>"(3) ..." (with digits 0-7 and spaces) is an octal number.</li>
    </ul>
  </ul>
</ul>

These numeric literals are the only syntactical reason that the double-quote character (") appears in XPL source code.<br>
<br>
Another important attribute is <font color="#663300"><code>LITERALLY</code></font>. It's not strictly related to declaration of variables, even though appearing in <font color="#663300"><code>DECLARE</code></font> statements and so it's discussed in the next section instead.<br>
<h2>
  <a name="basedManagement"></a>XPL/I ARRAY and BASED Data ... and an Exception<br>

</h2>


XPL/I provides a separate kind of statement which can declare arrays, which syntactically differs only in that the keyword <font color="#663300"><code>ARRAY</code></font> is used in place of the keyword <font color="#663300"><code>DECLARE</code></font>, and in that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT</code></font>, and not for <font color="#663300"><code>CHARACTER</code></font>.<br>
<blockquote><font size="-1"><b>Aside:</b> For the original XPL/I compiler, there was a distinction in the way <font color="#663300"><code>ARRAY</code></font> variables were stored in memory vs <font color="#663300"><code>DECLARE</code></font>
 variables.&nbsp; The distinction was that a pointer was stored in the 
variable and the data for the array was stored elsewhere, much as a 
string descriptor is used for character values.&nbsp; That was 
apparently a trick get around limitations on IBM 360 memory-segment 
sizes.&nbsp;
 At the present time, I don't see this distinction as being 
operationally significant, so <b>XCOM-I</b>
 treats the two keywords identically.&nbsp; This is subject to change, 
if I discover my thinking was in error.&nbsp; As, unfortunately, I often
 do. </font><br>
</blockquote>

More significantly, XPL/I adds an additional kind of datatype that it calls a <font color="#663300"><code>BASED</code></font> variable.&nbsp; These are basically <i>pointers</i> to arrays of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; Note that I said "pointers to arrays" rather than "arrays of pointers".&nbsp; By changing the address stored in the <font color="#663300"><code>BASED</code></font>
 variable's pointer, you can instantly interpret an entirely different 
chunk of memory as the array.&nbsp; Moreover, besides the basic types 
just mentioned, the <font color="#663300"><code>BASED</code></font> variable can point to an array of "records", where each "record" is a collection of the basic 
datatypes.&nbsp; I.e., a record can hold any combination of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font> fields, or arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
 mechanism, XPL/I can thus mimic both pointers and primitive types of 
structures, neither of which is available in XPL proper.&nbsp; I say 
that the structures are "primitive", because <font color="#663300"><code>BASED</code></font> variables cannot themselves be fields of <font color="#663300"><code>BASED</code></font> variables, hence only structures that are a single-level deep are available.&nbsp; <br>
<br>
Here are a couple of examples of declarations of <font color="#663300"><code>BASED</code></font> variables:<br>
<blockquote>
  <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
</blockquote>

Although <font color="#663300"><code>BASED</code></font> variables are always (or almost always) arrays, you'll note that the declarations of <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font>
 don't indicate any dimensional information.&nbsp; That's because no 
memory for them, other than for the pointer, is allocated at 
compile-time.&nbsp; Space is instead explicitly allocated at runtime by 
user code.&nbsp; Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array entry, but not of the <i>number of elements</i> in the array.&nbsp; <br>
<blockquote>
<div align="center"><b>
    <font size="-1"><a name="DopeVectors"></a>"Dope Vectors"<br>
      <br>
    </font></b></div>
<font size="-1">When I said that a <font color="#663300"><code>BASED</code></font> is a "pointer to an array", I was glossing over the fact that to be useful a <font color="#663300"><code>BASED</code></font> must track a lot more information about the <font color="#663300"><code>BASED</code></font> than just its data's location in memory.&nbsp; In fact, a <font color="#663300"><code>BASED</code></font> is stored as a 28-byte structure <i>plus</i>
 the separately-positioned data for the array.&nbsp; The 28-byte 
structure is referred to as a "dope vector". &nbsp; In other words, if 
you had a <font color="#663300"><code>BASED</code></font> called (say) <font color="#663300"><code>MYBASED</code></font> and you executed the built-in function <font color="#663300"><code>ADDR(MYBASED)</code></font>, it would return the address of the dope vector for <font color="#663300"><code>MYBASED</code></font>.&nbsp; As usual, the <b>HAL/S-FC</b>
 documentation and source code do not actually provide any useful facts 
about this setup, but various factoids can be inferred from <b>HAL/S-FC</b>
 source code, to a greater or lesser degree of confidence, and here are 
my feeble inferences about the fields of dope vectors.&nbsp; The fields 
with <font color="#009900">green</font> highlighting are those of 
conceivable interest to an application programmer, though all of them 
are managed entirely transparently in most cases.<br>

  </font><ol>
    </ol>
<ul>

  <li><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 0:&nbsp; </font><code>FIXED</code></font> pointer giving the address of the actual data.</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 4:&nbsp; </font></font></font><code>BIT(16)</code></font> giving the size in bytes of each record.</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 6:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> <font color="#009900">gives the number of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(≥32)</code></font> fields in each <font color="#663300"><code>BASED RECORD</code></font>, or 1 if it's a <font color="#663300"><code>BASED CHARACTER</code></font> or <font color="#663300"><code>BASED </code><code>BIT(≥32)</code></font>, or 0 otherwise.  The point is that it's the number of "string descriptors" associated with each element of the <font color="#663300"><code>BASED</code></font> array.  This information is used by </font><font color="#663300"><code>COMPACTIFY</code></font>.  (<a moz-do-not-send="true" href="#compactify">See below</a>.)  While I don't fully understand the calculations being performed, I'd venture the opinion that for <font color="#663300"><code>COMPACTIFY</code></font> to use this information efficiently, it's necessary for the XPL/I compiler to rearrange the fields of <font color="#009900"><font color="#663300"><code>BASED RECORD</code></font></font> from their declared order in such a way that all of string-descriptor fields come first in the record. <b>XCOM-I</b> does indeed perform this rearrangement.<br>
</font></li>
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 8:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font> giving the total number of array entries for which space has been <i>allocated</i>.</font></li>
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 12:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font> giving the total number of array entries actually <i>used</i> so far.</font></li>
  
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 16:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font></font><font size="-1">.&nbsp; The dope vectors for all <font color="#663300"><code>BASED</code></font> variables for which memory has been allocated form a linked list.&nbsp; The global variable <font color="#663300"><code>FIRSTRECORD</code></font>
 gives the address of the first dope vector on the list, and this field 
at offset 16 in the dope vector points to the next dope vector, or 0 if 
there is no next one (or if space hasn't been allocated).&nbsp; The 
ordering is TBD, since I haven't traced through the code in all of its 
gory detail, but I believe they are ordered according to <i>decreasing</i> address fields (i.e., the field at offset 0), which at least initially is also the order in which the <font color="#663300"><code>RECORD_CONST</code></font> or <font color="#663300"><code>ALLOCATE_SPACE</code></font> macros (see below) were executed to allocate memory for them.<br>
    </font></li>

  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 20:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font><font size="-1">.  It appears to me that this field supplies some properties of the <font color="#663300"><code>BASED</code></font> in the form of bit fields. It is laid out as follows:</font></li>
  <ul>
    <li><font size="-1">Bit 24 indicates the <font color="#663300"><code>BASED</code></font> is "constant", which appears to mean that you cannot incrementally grow it.  (The macro <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font> is used to increase the size of the specified <font color="#663300"><code><i>based</i></code></font> by 1 record, an operation which fails if the <font color="#663300"><code><i>based</i></code></font> is "constant".)</font></li>

      
    <li><font size="-1">Bit 25 indicates the <font color="#663300"><code>BASED</code></font> is "unmoveable".  If a <font color="#663300"><code><i>based</i></code></font> is "unmovable", it means that an operation like <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font>
 (see above) will succeed only if there is enough free space immediately
 following the allocated memory that can be "stolen".  Whereas if it's 
not unmovable, then the <font color="#663300"><code><i>based</i></code></font> may migrate in its entirety to a newly-allocated block elsewhere and the space it originally occupied may thus be freed.</font></li>
  </ul>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 24:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> of purpose TBD.  It is referred to as "global factor".</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 26:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> is referred to as "group factor".  As far as I can see, all uses of this are commented out in <b>HAL/S-FC</b>, so perhaps it ended up being unused.<br>
</font></li>
</ul>

<ol>

  
</ol>
<font size="-1">

The <b>XCOM-I</b> implementation mimics this dope-vector structure, though only the fields I've highlighted in <font color="#009900">green</font> are significant in <b>XCOM-I</b> ... which is fortunate, since they're the only ones I imagine I understand somewhat.<br>

  <br>

With that discussion in mind, in understanding some of the things that need to happen with <font color="#663300"><code>BASED</code></font> variables in actual XPL/I source code (and in particular, in <b>HAL/S-FC</b>), let's consider various space-management macros and/or procedures used:<br>

  </font><ul>
    <li><font size="-1" color="#663300"><code>RECORD_ALLOC(<i>based</i>)</code></font><font size="-1">, used in expressions, returns the number of records allocated in <font color="#663300"><code>BASED</code></font> variable <font color="#663300"><code><i>based</i></code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_USED(<i>based</i>)</code></font><font size="-1">,
 normally used on the left-hand-side in assignments, sets the number of 
records used so far in based.  Its most-common usage is <font color="#663300"><code>RECORD_USED(<i>based</i>)=RECORD_ALLOC(<i>based</i>)</code></font>,
 but it can also be used with something other than that on the 
right-hand side to truncate the array or to skip past the lowest 
indexes.  And it can be used in expressions or conditionals, though that
 happens relatively seldom.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_TOP(<i>based</i>)</code></font><font size="-1">, as you might expect, simply returns <font color="#663300"><code>RECORD_USED(<i>based</i>)-1</code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font><font size="-1"> allocates enough space for <i><font color="#663300"><code>based</code></font></i> to insure that it contains at least <font color="#663300"><code><i>top</i>+1</code></font> records in total.  It will fail if we already have <font color="#663300"><code>RECORD_ALLOC(<i>based</i>)&gt;0</code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>NEXT_ELEMENT(based)</code></font><font size="-1"> increments <font color="#663300"><code>RECORD_USED(<i>based</i>)</code></font>
 by 1, stealing the space from adjacent free memory or else reallocating
 and moving the entire array if necessary to do so.  This can only be 
used if space for <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>ALLOCATE_SPACE</code></font>, and will instead cause an abend if <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>RECORD_CONSTANT</code></font> (see below).</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_FREE(based)</code></font><font size="-1"> frees the data for <i><font color="#663300"><code>based</code></font></i>, returning the allocated space to the free pool.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_SEAL(<i>based</i>)</code>, <code>RECORD_UNSEAL(<i>based</i>)</code></font><font size="-1">:  Enables or disables the "constant" attribute of the <i><font color="#663300"><code>based</code></font></i>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_CONSTANT(<i>based</i>, <i>top</i>, <i>moveable</i>)</code></font><font size="-1"> Like <font color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font>, but additionally enables the "constant" property, and optionally enables the "unmovable" property.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_WIDTH(based)</code></font><font size="-1"> returns the record width of the <i><font color="#663300"><code>based</code></font></i>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_LINK()</code></font><font size="-1"> prepares the data for transferring <font color="#663300"><code>COMMON</code></font> memory to the next program loaded.</font></li>
  </ul><font size="-1">
  </font>
</blockquote>

User code that initially allocates free memory — let's say 25 records to start with —  for a <font color="#663300"><code>BASED</code></font> variable is <i>typically</i> a two-step process that looks something like this:<br>
<blockquote>
  <pre><font color="#663300">BASED MYVARIABLE FIXED;<br>...<br>RECORD_CONSTANT(MYVARIABLE, 25, MOVEABLE); /* OR UNMOVEABLE */<br>RECORD_USED(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>) = RECORD_ALLOC(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>);</font><br></pre>
</blockquote>
Or, if you knew that you were going to need more elements later, you might allocate a bit extra, for example:<br>
<blockquote>
  <pre><font color="#663300">BASED MYBASED FIXED;<br>...<br>ALLOCATE_SPACE(</font><font color="#663300"><font color="#663300">MYBASED</font>, 30);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYBASED</font></font>) = 25;</font></pre>
</blockquote>

Having allocated the space for it, you can now use <font color="#663300"><code>MYBASED</code></font> just like any other array of <font color="#663300"><code>FIXED</code></font>, such as in assignments like "<font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(27) = 6;</code></font>" or "<font color="#663300"><code>X = </code></font><font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(N) + 12;</code></font>".&nbsp; <br>
<br>
To actually increase the number of elements later, you'd do something like this:<br>
<blockquote>
  <pre><font color="#663300">NEXT_RECORD(MYBASED);</font><br></pre>
</blockquote>
This will increment <font color="#663300"><code>RECORD_USED(MYBASED)</code></font> by 1 — if possible while still keeping it below <font color="#663300"><code>RECORD_ALLOC(MYBASED)</code></font> — or else will reallocate and possibly move <font color="#663300"><code>MYBASED</code></font> into a larger space, if possible.<br>
<br>
In a more-complex case, we might have a <font color="#663300"><code>BASED RECORD</code></font> variable:<br>
<blockquote>
  <pre><font color="#663300">BASED MYNEWBASED RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(9) FIXED,<br>END;<br>...<br>RECORD_CONSTANT(</font><font color="#663300"><font color="#663300">MYNEWBASED</font>, 30, MOVEABLE);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYNEWBASED</font></font>) = 25;</font></pre>
</blockquote>

Accessing <font color="#663300"><code>MYNEWBASE</code></font> requires the dotted style often used these days for 
accessing fields of structures or classes.&nbsp; Some examples include:<br>
<blockquote>
  <pre><font color="#663300">MYNEWBASED(6).F = 12;<br>MYNEWBASED(10).C = 'XPL is where it is at!';<br>MYNEWBASED(20).A(6) = 15;<br>X = MYNEWBASED(6).F;</font><br></pre>
</blockquote>
and so on.<br>
<div align="center"><b><font size="-1">The Exception<br>
    </font></b></div>
<blockquote><font size="-1">There is one — count 'em, <i>one</i>! — exception I've found to the <i>documented</i> behavior I've described above.&nbsp; This undocumented use is seen in the <font color="#663300"><code>IND_STACK</code></font> variable found in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp; </font><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font> is declared using the following bastardized mash-up of a <font color="#663300"><code>DECLARE</code></font> statement and a <font color="#663300"><code>BASED</code></font> statement:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">   DECLARE IND_STACK(STACK_SIZE) RECORD:<br>         I_CONST        FIXED,<br>         I_INX_CON      FIXED, <br>         I_STRUCT_CON   FIXED,<br>         ...<br>         I_LIVREMT      BIT(8),<br>         I_NAMEVAR      BIT(8),<br>         I_STRUCT_WALK  BIT(8),<br>         I_AIADONE      BIT(8),<br>      END;</font><br></pre>
  </blockquote>
  <font size="-1">Unlike a </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font>
 declaration, in which specifying an array size at compile time is 
illegal, or as IR-182-1 states, "ignored if present", the array size is 
indeed found in this declaration.&nbsp; Nor is there any runtime 
adjustment to the size, as would be expected with a </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font></font>.&nbsp; Nonetheless, </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font></font> is subsequently accessed by the dotted, structure-type notation used only by </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables. <br>
    <br>
Rather than implement an entirely new but undocumented class of structure objects to handle this single instance, <b>XCOM-I</b> implements this case as if it were a </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> declaration followed by an appropriate <font color="#663300"><code>RECORD_CONSTANT</code></font> operation.&nbsp; </font><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font> is one of the very few objects stored in <a moz-do-not-send="true" href="#MemoryModel">region 7 of the XPL memory model</a>, and by far the largest of them.<br>
  </font></blockquote>

<h2>LITERALLY and Macros</h2>
Another attribute that can appear in <font color="#663300"><code>DECLARE</code></font> statements is the <font color="#663300"><code>LITERALLY</code></font> attribute.&nbsp; Here's an example:<br>
<blockquote>
  <pre><font color="#663300">DECLARE ARRAYTOP LITERALLY '255';<br>DECLARE MYARRAY(ARRAYTOP) FIXED;</font><br></pre>
</blockquote>
Notice that <font color="#663300"><code>ARRAYTOP</code></font> has no 
datatype assigned to it.&nbsp; That's because its declaration is not 
actually the declaration of a variable called "ARRAYTOP", but rather of a
 macro of that name.&nbsp; Wherever the identifier <font color="#663300"><code>ARRAYTOP</code></font> is encountered subsequently, it's simply replaced literally by the string <font color="#663300"><code>255</code></font>, now unquoted:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYARRAY(255) FIXED;</font><br></pre>
</blockquote>
This clarifies an example of a commonly-desirable declaration I gave in 
the preceding section, which in this section would be expressed as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE RECSIZE LITERALLY '3600';<br>DECLARE BUFFER(RECSIZE-1) BIT(8);</font><br></pre>
</blockquote>

As noted in the preceding section, standard XPL's grammar wouldn't allow an expression (like <font color="#663300"><code>RECSIZE-1</code></font>) in that context, so this particular convenience in making declarations is only available in XPL/I.<br>
<br>
Macro expansions — not macro <i>declarations</i> (I hope!) — can be nested, so you can do things like this if you want:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DEVICE LITERALLY '6', OUT LITERALLY 'OUTPUT(DEVICE)';<br>OUT = 'My message';</font><br></pre>
</blockquote>
This expands to<br>
<blockquote>
  <pre><font color="#663300">OUTPUT(6) = 'My message';</font><br></pre>
</blockquote>
Macros can expand to portions of statements, as the ones above have, or to multiple statements, such as<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYBLOCK LITERALLY 'DO; X=1; Y=X+3; END';<br>...<br>IF X=7 THEN;<br>    MYBLOCK;</font><br></pre>
</blockquote>
which expands to:<br>
<blockquote>
  <pre><font color="#663300">IF X=7 THEN;<br>    DO; X=1; Y=X+3; END;</font><br></pre>
</blockquote>
Macros can also have arguments.&nbsp; Consider the following:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYMAC(2) LITERALLY '%1% = %2%';</font><br></pre>
</blockquote>
This declaration means that <font color="#663300"><code>MYMAC</code></font> has 2 arguments, and that when the macro is expanded, the first argument will replace <font color="#663300"><code>%1%</code></font> and the second argument will replace <font color="#663300"><code>%2%</code></font>.&nbsp; Thus "<font color="#663300"><code>MYMAC(X, 3 * Y)</code></font>" expands to "<font color="#663300"><code>X = 3 * Y</code></font>".<br>
<blockquote><font size="-1"><b>Warning:</b>&nbsp; As with macros in any other computer language, this can quickly get out of hand.&nbsp; <b>XCOM-I</b>,
 for example, won't detect recursive, endlessly-expanding macros.&nbsp; 
There's also no guarantee when multiple macros are in play that <b>XCOM-I</b> will necessarily expand macros in the same order that <b>XCOMx</b> would have.&nbsp; Neither <i>A Compiler Generator</i> nor Intermetrics documentation makes any mention of what that ordering should be.<br>
    <br>
    <b>Warning:</b>&nbsp; The scope of macro definitions is also 
different in XPL vs XPL/I.&nbsp; In XPL, macro definitions don't respect
 any nested scopes they appear in; i.e., any macro definition will 
simply remain in effect until the end of the source code.&nbsp; In 
XPL/I, macro definitions remain in effect only until the end of the 
procedure in which they're defined, including embedded procedures.&nbsp;
 In neither case does a macro definition have any effect on source code 
prior to it.<br>
  </font></blockquote>
<h2>Perplexing Multiple Assignments</h2>

<p>XPL allows multiple variables to be assigned the same value in a single assignment statement, with a syntax like:<br>
</p>
<blockquote>
  <pre><font color="#663300">X1, X2, ..., XN = Y;</font><br></pre>
</blockquote>
<p>According to <i>A Compiler Generator</i> (p. 137), these assignments are performed in right-to-left order.&nbsp; In other words, it <i>should</i> be equivalent to:<br>
</p>
<blockquote>
  <pre><font color="#663300">XN = Y;<br>.<br>.<br>.<br>X1 = Y;</font><br></pre>
</blockquote>
<p>In most cases, the ordering of these assignments is of no significance, and in fact I've found no legacy <i>standard</i> XPL programs in which the ordering matters.&nbsp; However, there are instances in XPL/I code, specifically in <b>PASS1</b> of <b>HAL/S-FC</b> in which the order matters a lot.&nbsp; That's when you have assignments of the form:<br>
</p>
<blockquote>
  <pre><font color="#663300">Y(I), I = J;</font><br></pre>
</blockquote>
<p>because obviously<br>
</p>
<blockquote>
  <pre><font color="#663300">I = J;<br>Y(I) = J;</font><br></pre>
</blockquote>
<p>is a lot different than<br>
</p>
<blockquote>
  <pre><font color="#663300">Y(I) = J;<br>I = J;</font><br></pre>
</blockquote>
<p><i>Unfortunately</i>, in the cases I've encountered, the XPL/I code 
seems to rely on the latter interpretation.&nbsp; I.e., it seems to 
believe that the assignments are performed in left-to-right order, in 
direct contradiction to <i>A Compiler Generator</i>.&nbsp; What's going on here?<br>
</p>
<p>Of course, we have no way of knowing what Intermetrics <b>XCOM</b> did with this, but as far as <i>A Compiler Generator</i>'s
 <b>XCOM3</b>, it appears (thanks to Dan Weaver for this explanation) that while
 the assignments are indeed performed in a right-to-left manner as 
documented, the peculiarities of the IBM 360 object-code generation in 
<b>XCOM3</b>, shove the index <font color="#663300"><code>I</code></font>
 into a CPU register and reuse it without change throughout both 
assignments.&nbsp; So seemingly by accident, the net result is that the 
assignments <i>appear</i> to have been done in a left-to-right 
order.&nbsp; I would also note that there is an example in <i>A Compiler 
Generator</i> (Fig. 6.18.1) that shows assembly code generated for the XPL 
expression<br>
</p>
<blockquote>
  <pre><font color="#663300">I, J, K = 2;</font><br></pre>
</blockquote>
<p>
</p>

<p>which supports the documented right-to-left order, namely,<br>
</p>
<blockquote>
  <pre><font color="#663300">LA	1,2(0,0)	[This gets a 2]<br>STC	1,1346(0,11)	[This sticks it into K]<br>STH	1,1344(0,11)	[This sticks it into J]<br>ST	1,1340(0,11)	[This sticks it into I]</font><br></pre>
</blockquote>
<p><i>Vis-à-vis</i> Dan's explanation, it doesn't appear to me to be a reliable design choice in <b>XCOMx</b>:&nbsp; what if there are more than 2 assignments on the 
left-hand side, and if they don't all use the same index <font color="#663300"><code>I</code></font>?&nbsp; What would the order appear to be then?&nbsp; Well, perhaps <b>XCOMx</b> does something else in that situation.<br>
</p>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; When I wrote this, perhaps I didn't have a working <b>XCOM3</b> yet, or perhaps it did not occur to me that I could just use <b>XCOM3</b>
 and compile any test cases I like, so that I could see what the 
assembly code did.&nbsp; Well, I realize it now.&nbsp; I still haven't 
done it, but perhaps I should.&nbsp; Some day.</font><br>
</blockquote>
<p>
</p>

<p>To sum it all up:<br>
</p>
<blockquote><font size="-1"><b>Important Note</b>:&nbsp; <b>XCOM-I</b> <i>ignores</i> the statement in <i>A Compiler Generator</i>
 that assignments are performed in a right-to-left manner.&nbsp; Rather,
 it performs them in a left-to-right manner, and any indices of arrays
 are computed at the moment the assignment is performed.&nbsp; I'm 
keeping my fingers crossed that this doesn't explode in my face.&nbsp; 
If it does, I would be tempted to just fix the XPL source code that was 
doing it, rather than to fix <b>XCOM-I</b>.&nbsp; We'll see.</font><br>
</blockquote>
<h2>Logical Expressions</h2>


<p>XPL's logical operators are <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>~</code></font> (<font color="#663300"><code>¬</code></font>, <font color="#663300"><code>^</code></font>), for "and", "or", and "not", respectively.  The documentation in <i>A Compiler Generator</i>
 is maddeningly unclear as to what these operators do.  True, table 
6.8.1 calls them "logical and", "logical or", and "logical complement", 
but the word "logical" isn't defined ... just as my sloppy usage of the 
word "logical" at the beginning of this paragraph makes no distinction. 
Which leaves open a few loopholes that have to be closed up. The issues 
which we must understand are:<br></p>
<ul>
  <li>Are these operations bitwise or narrowly "logical".  I.e., do they
 operate in parallel on each bit position in a numerical value, or do 
they simply produce bipolar results of 1 (true) or 0 (false)?</li>
  <li>Do these operations short circuit?  E.g., if we have an expression of the form (say) <font color="#663300"><code><i>expression1</i>&amp;<i>expression2</i></code></font>, and <i><font color="#663300"><code>expression1</code></font></i> evaluates to 0, is <i><font color="#663300"><code>expression2</code></font></i> even evaluated?</li>
</ul>
<p>In case you're not in the mood for a technical discussion of the 
matter, I'll give you the short answer up front, and having read that, 
you can proceed to the long discussion if you want:<br></p>
<ul>
  <li>The logical operations are indeed bitwise.</li>
  <li>Under some limited circumstances, the original <b>XCOM</b> may 
have short-circuited evaluation of logical operations, even though 
there's no short-circuiting observed in the examples I've constructed.  <b>XCOM-I</b> does not at present attempt any short-circuiting.<br></li>
</ul>
<p>As for how I came up with this "information", there are several 
places we can look for guidance in guessing the answers.  For one thing,
 according to <i>A Compiler Generator</i>'s account, the XPL language was derived from the 
PL/I language, so we can look at PL/I documentation and hope that it 
applies to XPL.  Of course, we can look at the source code for <i>A Compiler Generator</i>'s XPL compiler (<b>XCOM3</b>) as listed in the book, and see if there are any hints there.  Or we can even examine the IBM 360 object code that <b>XCOMx</b>
 generates for these operators.   (All the while wondering how things 
came to this, that we have to resort to lame measures like consulting 
object code to figure out the basic features of the language?)<br></p>
<p>As far as PL/I is concerned, <a moz-do-not-send="true" href="https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf">IBM's PL/I Language Reference</a> (2017) tells us on p. 66 that for the <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> operators, "bit operations are performed on a bit-by-bit basis".  As far as object code produced by <b>XCOM</b> is concerned, <i>A Compiler Generator</i> (p. 150) shows an example in which object code for the expression "<font color="#663300"><code>SHL(K,1) &amp; SHR(I,J)</code></font>" is produced, and we do find that it simply uses the IBM 360 <font color="#663300"><code>NR</code></font> ("And Logical") instruction:<br></p>
<blockquote>
  <p align="left"><img moz-do-not-send="true" src="shortCircuit.jpg" alt="" width="768" height="123"></p>
</blockquote>
<p>Although I had to consult more than one IBM assembly-language manual 
to find the answer to the seemingly-simple question of what <font color="#663300"><code>NR</code></font> does, <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf">IBM's z/Architecture Principles of Operation</a> (p. A-8) does tell us that the <font color="#663300"><code>NR</code></font> (and its cousins <font color="#663300"><code>N</code></font>, <font color="#663300"><code>NC</code></font>, and <font color="#663300"><code>NI</code></font>) are indeed bitwise operations.<br></p>
<blockquote><font size="-1"><b>Aside:</b>  <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf#page=940">Figure B-2, "Instructions Arranged by Mnemonic"</a> of the latter document is very helpful in trying to decipher such listings of IBM 360 object code.<br>
  </font></blockquote>
<p>Short-circuiting is a natural consideration for strictly bipolar 
operands and operators, but is a bit trickier to consider once we've 
concluded that the logical operators operate bitwise rather than in a 
bipolar fashion.  Certainly the object-code example from <i>A Compiler Generator</i> that was mentioned in the preceding paragraph shows no signs at all of short circuiting:  Both of the operands of the <font color="#663300"><code>&amp;</code></font>
 operator in that example are evaluated, with no attempt at checking the
 value of the first operation before proceeding to the second one.  On 
the other hand, that example of object-code generation by <b>XCOMx</b> happens to be for an assignment statement rather than for the conditional expression of an <font color="#663300"><code>IF</code></font>, <font color="#663300"><code>DO WHILE</code></font>, or <font color="#663300"><code>DO UNTIL</code></font>.
   Perhaps the evaluation of a conditional expression might be very 
different in those contexts.  One reason to believe that it might be 
different is that the final result of a conditional expression is masked
 to just the least-significant bit, and thus (eventually) is indeed a 
bipolar value; i.e., even if all of the bits were involved in the 
computation, all but one of them is discarded in the end, so perhaps the
 extra bits are discarded at the beginning rather than at the end of the
 computation, even though it's more work to do so.  Moreover, the PL/I 
Language Reference document mentioned earlier does cover short-circuit 
evaluation (see p. 245), and it says that short-circuiting is <i>only</i> in the context of the conditional of an <font color="#663300"><code>IF</code></font>
 statement (versus assignment statements).  Plus, even then the 
short-circuiting occurs only in certain special circumstances, such as 
the leading operand being a <font color="#663300"><code>BIT(1)</code></font>
 literal or constant variable, which leads one to believe that the value
 of the leading operand has to be determined to be 0 or 1 at 
compile-time rather than at run-time for the short-circuiting to occur.<br></p>
<p>Unfortunately, the example of object-code generation in <i>A Compiler Generator</i> doesn't show us how an <font color="#663300"><code>IF</code></font> statement would compile.  But <a moz-do-not-send="true" href="#compilingXCOM">as we saw earlier</a>, we have been able to use <b>XCOM-I</b> to create a working copy of <i>A Compiler Generators</i>'s <b>XCOM3</b>, so we can make our own example of <font color="#663300"><code>IF</code></font>, compile it with <b>XCOM3</b> and see!  Imagine we have the following ridiculous little XPL program:<br></p>
<blockquote>
  <pre><font color="#663300"> DECLARE I FIXED;<br> DO I = 1 TO 10;<br>     IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br> DO I = 1 TO 10;<br>     IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br>EOF<br></font></pre>
</blockquote>Compiling this silly program with <b>XCOM3</b>, and pulling just the relevant portion of the <b>XCOM3</b>'s report gives us the following IBM 360 object code for the conditional expressions of the <font color="#663300"><code>IF</code></font> statements:<br>
<pre><font color="#663300">  20 |    IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';                           |  1314 C7 = 10.<br>                                                                      1314: CODE = L    1,1340(0,11)<br>                                                                      1318: CODE = M    0,1340(0,11)<br>                                                                      1322: CODE = L    2,1340(0,11)<br>                                                                      1326: CODE = L    3,1340(0,11)<br>                                                                      1330: CODE = MR   2,2<br>                                                                      1332: CODE = LA   2,100(0,0)<br>                                                                      1336: CODE = SR   2,3<br>                                                                      1338: CODE = NR   1,2<br>                                                                      1340: CODE = N    1,164(0,11)<br>                                                                      ...<br> 24 |    IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';                                 |  1400<br>                                                                      1400: CODE = L    1,1340(0,11)<br>                                                                      1404: CODE = M    0,1340(0,11)<br>                                                                      1408: CODE = LA   2,100(0,0)<br>                                                                      1412: CODE = SR   2,1<br>                                                                      1414: CODE = N    2,1300(0,1048571)<br>                                                                      1418: CODE = N    2,164(0,11)<br>                                                                      ...<br><br></font></pre>
<p>Not shown above is that the symbol table tells us variable <font color="#663300"><code>I</code></font>
 is stored at address 1340(11), which is why all of the 1340(0,11)'s 
appear above.  I don't understand IBM 360 assembly language too well, but what I <i>think</i> the code probably does is:<br></p>
<ul>
  <li>The first <font color="#663300"><code>IF</code></font>:</li>
  <ul>
    <li>1314 through 1318:  Compute the left-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li>
    <li>1322 through 1336:  Compute the right-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>100-I**</code></font>. </li>
    <li>1338: Perform a bitwise-AND of the two operands.</li>
    <li>1340: Mask off all but the least-significant bit.<br></li>
  </ul>
  <li>The second <font color="#663300"><code>IF</code></font>:</li>
  <ul>
<li>1400-1412:  Compute the <i>right</i>-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li><li>1414: Perform a bitwise-AND with 0.  Admittedly, I'm not quite sure <i>why</i> it would be 0 it's AND'ing with, but it's certainly AND'ing with something.</li><li>1418: Mask off all but the least-significant bit.</li>
  </ul>
</ul>
<p>But whether or not my interpretation is 100% correct, at least in 
this example there's no evidence of short-circuiting.  The 2nd <font color="#663300"><code>IF</code></font>
 in particular is pretty shocking.  Perhaps there's supposed to be some 
subsequent optimization I'm not aware of that would have cleaned it up.<br></p>

<h2><a name="common"></a>COMMON Memory</h2>

XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font> memory, not present in XPL.&nbsp; The notion behind <font color="#663300"><code>COMMON</code></font>
 memory is that a very large application program like <b>HAL/S-FC</b> won't be 
loaded entirely in memory at once, but will instead be run as a sequence
 of "passes".&nbsp; Since <font color="#663300"><code>COMMON</code></font> memory is not supported in standard XPL, compiling a program with <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font> switch will disable the <font color="#663300"><code>COMMON</code></font> memory features described in this sections.<br>
<br>
Thus, a program like <b>HAL/S-FC</b> isn't a single application program, but rather a set of 
them:&nbsp; <b>PASS1</b>, <b>FLO</b>, <b>OPT</b>, <b>AUX</b>, <b>PASS2</b>, <b>PASS3</b>, and <b>PASS4</b>.&nbsp; Each of
 these applications is loaded, run, and unloaded from memory, in succession.<br>
<br>
But!&nbsp; Each of these application programs may receive some kind of 
input data or state data from the preceding application program, and 
transmit output data or state data to the next application program in 
succession.&nbsp; In XPL/I's visualization, <i>some</i> of that data is 
passed in files.&nbsp; But other data is instead just assumed to
 remain in computer memory, unchanged from whatever the preceding 
application has left behind.&nbsp; The term XPL/I applies to this 
leftover memory is <font color="#663300"><code>COMMON</code></font> memory.&nbsp; It's formalized when you explicitly declare variables as being in <font color="#663300"><code>COMMON</code></font>.&nbsp; Variables declared to be in <font color="#663300"><code>COMMON</code></font>
 are not initialized by an XPL/I program, except for the very first program in a chain of programs, but are simply assumed to 
already contain the data needed.&nbsp; On the other hand, variables <i>not</i> declared <font color="#663300"><code>COMMON</code></font>
 are up for grabs, and no assumption can be made about their initial 
contents other than whatever initialization their declarations 
explicitly provide.<br>
<br>
Syntactically, <font color="#663300"><code>COMMON</code></font> data is declared in XPL/I by three methods:<br>
<ul>
  <li>Using the keyword <font color="#663300"><code>COMMON</code></font> in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON ARRAY</code></font> in place of the keyword <font color="#663300"><code>ARRAY</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON BASED</code></font> in place of the keyword <font color="#663300"><code>BASED</code></font>.</li>
</ul>
<p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font> variables cannot declared in <font color="#663300"><code>COMMON</code></font>, though <font color="#663300"><code>CHARACTER</code></font> variables can appear as fields in <font color="#663300"><code>COMMON BASED RECORD</code></font> variables. <br></p>
<p>Each cooperating application running in succession needs to declare <font color="#663300"><code>COMMON</code></font>
 in exactly the same way, using exactly the same ordering of variables 
and the same datatypes, at the same addresses.&nbsp; When <a moz-do-not-send="true" href="#basedManagement">"dope vectors" of <b>BASED</b> variables</a> were discussed earlier, it was mentioned that <b>BASED</b>
 variables could be set as "constant" or "unmoveable", and this 
necessity for remaining at the same location when successor programs are
 executed is part of the reason for this feature.<br>
</p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; If <b>BASED</b>
 variables were always manipulated by an XPL/I program as intended by the original compiler design — 
i.e., allowing SPACELIB to manipulate them via their dope vectors — 
there would be no reason for these restrictions on moveability.&nbsp; 
However, the "virtual memory" system employed by <b>HAL/S-FC</b>, as implemented by the files HALINCL/VMEM<i>x</i>.xpl,
 bypasses the dope-vector system.&nbsp; Specifically, "pages" of memory 
managed by the virtual-memory system are tracked only by an array of 
addresses (rather than dope vectors).&nbsp; But SPACELIB manages dope 
vectors, and has no cognizance of arrays of addresses whose 
interpretation exists only in the mind of a programmer.&nbsp; It is 
therefore necessary to make sure that the virtual-memory system's pages 
of memory never move.&nbsp; One might ask the programmer why they didn't
 use arrays of dope vectors rather than arrays of addresses?&nbsp; But 
that might be interpreted as being rude.&nbsp; On the other hand, I've 
known enough engineers to be pretty sure they'd think that since it 
worked for them, it was good enough.</font><br>
</blockquote>

<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; Speaking of the relationship between <font color="#663300"><code>BASED</code></font> variables and <font color="#663300"><code>COMMON</code></font> memory, it's important to note the following points:<br>
    </font></p>
  <ul>
    <li><font size="-1">For </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables appearing in </font><font size="-1"><font size="-1"><font color="#663300"><code>COMMON</code></font></font>, space is allocated for them via <font color="#663300"><code>RECORD_CONSTANT</code></font> or <font color="#663300"><code>ALLOCATE_SPACE</code></font> <i>only</i>
 in the first of the chained programs that needs to use them.&nbsp; 
Subsequent programs in the chain use them as-is, without allocation.</font></li>
    <li><font size="-1">Memory for </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables <i>not</i> appearing in </font><font size="-1"><font size="-1"><font color="#663300"><code>COMMON</code></font></font> must be explicitly freed via <font color="#663300"><code>RECORD_FREE</code></font>
 prior to exiting whatever program of the chain allocated their 
memory.&nbsp; If this is not done, then the memory-management system 
(Intermetrics SPACELIB) will abort the program with an error and fail to
 prepare the <font color="#663300"><code>COMMON</code></font> data for use by the next program in the chain.<br>
      </font></li>
  </ul>
</blockquote>
<p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font color="#663300"><code>COMMON</code></font>
 data from one application to another using actual memory.  Rather, each XPL/I application program compiled by <b>XCOM-I</b> can optionally (depending on its command-line options) load a <i>file</i> containing data into its <font color="#663300"><code>COMMON</code></font> areas of memory; and similarly, it automatically writes out its <font color="#663300"><code>COMMON</code></font> areas of memory into a file upon termination.  By using the <font color="#663300"><code>--commoni</code></font> and <font color="#663300"><code>--commono</code></font> command-line switches of the application, a close degree of control can be exercised over which previously-saved <font color="#663300"><code>COMMON</code></font> blocks, if any, are passed to which application programs.&nbsp; The command-line options are needed because by <i>default</i>, an executable produced by <b>XCOM-I</b> does not read in a <font color="#663300"><code>COMMON</code></font>
 file at startup, and outputs a file literally called "COMMON.out" upon 
termination.&nbsp; The command-line options override either or both of 
those defaults.<br>
</p>

<p><font color="#663300"><code>COMMON</code></font> files are in a human-readable format.&nbsp; See the comments for the <font color="#663300"><code>writeEntryCommon</code></font>
 function in the runtime-library file runtimeC.c if you have any 
interest in the file format.&nbsp; It's actually pretty useful for 
debugging certain kinds of problems.<br>
</p>

<blockquote>
</blockquote>
<h2><a name="MemoryModel"></a>Memory Model for a Compiled XPL Program<br>


</h2>

<table width="100%" cellspacing="10" cellpadding="0">
  <tbody>
    <tr>
      <td valign="top">
<p>The theoretical memory space available at runtime for a compiled XPL program is 2<sup>24</sup>=16,777,216
 bytes in size, although the Wikipedia article on IBM System/360 tells 
us that the actual physical maximum was only 8 MB.&nbsp; In the C object
 code generated by XCOM-I, this is represented by the byte array called <font color="#663300"><code>memory</code></font>.</p>
<p>
For the original XPL and XPL/I compilers, the lowest portion and highest
 portion of this (theoretical) 16 MB space was dedicated to the 
executable code for the program and the data used by it.&nbsp; The 
middle of the area was used for the program's data.&nbsp; But in the <b>XCOM-I</b>
 framework, all of the program code is stored elsewhere, thus the entire
 16MB space can be dedicated just for the variables actually <font color="#663300"><code>DECLARE</code></font>'d
 in the XPL source code ... plus those few elements of data which the 
operating system needs to communicate to the program, such as run-time 
program options, and a few other items I'll talk about in a moment.<br></p>

<p>The memory nevertheless still needs to be partitioned into blocks 
dedicated to specific types of data, in order to facilitate management 
of dynamic data like <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT</code></font><font color="#663300"><code>(n&gt;32)</code></font> strings and <font color="#663300"><code>BASED</code></font>
 variables.&nbsp; I try to follow the same partitioning scheme as used 
by the original compilers, at least roughly.&nbsp; The broad outline of 
this partitioning scheme is seen in the diagram to the right.<b>&nbsp; <br></b></p>
<p>Regions 4 and 6 naturally did not exist in XPL, since <font color="#663300"><code>BASED</code></font> variables are an XPL/I extension to standard XPL.&nbsp; So when <b>XCOM-I</b> is run with the <font color="#663300"><code>--xpl</code></font> command-line switch, those regions both have fixed sizes of 0.<br></p>
<p>Mostly, the boundaries of these memory regions are established at compile-time, by which I mean they're established by <b>XCOM-I</b>
 and don't change thereafter.  The exceptions are the boundaries between
 regions 5, 6, and 7.  As you may recall, at program startup, <font color="#663300"><code>BASED</code></font> variables have already been <font color="#663300"><code>DECLARE</code></font>'d and <b>XCOM-I</b>
 has thus made space for their dope vectors (region 4), but considered 
as arrays their sizes are 0.  At program start, region 6 is empty.  But 
memory region 6 grows <i>downward</i> when <font color="#663300"><code>BASED</code></font>
 variables are allocated memory at runtime, simultaneously shrinking the
 free-string memory region 5.  String data meanwhile occupies the space 
from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> in region 5, which means that the space between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available both for growing the string data upward (thus increasing <font color="#663300"><code>FREEPOINT</code></font>) or growing the <font color="#663300"><code>BASED</code></font> data downward (thus decreasing <font color="#663300"><code>FREELIMIT</code></font>).<br></p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; It would seem reasonable, at least to me, that if </font><font size="-1"><font color="#663300"><code>BASED</code></font> allocations proceed downward in memory, then the indices of the </font><font size="-1"><font color="#663300"><code>BASED</code></font> should also proceed downward as well.&nbsp; I mean that if we had a decoration such as <font color="#663300"><code>BASED MYBASED</code></font>, then <font color="#663300"><code>MYBASED(0)</code></font> would be at a higher address than </font><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(1)</code></font></font>, which would be at a higher address than </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(2)</code></font></font></font>, and so on.&nbsp; If that were the case, then growing </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED</code></font></font></font>
 after its initial allocation would be more efficient (if it happened to
 border on unallocated space), since it just involves snatching an 
unallocate chunk of memory rather than moving the entire array.&nbsp; 
However, if I am reading the code in SPACELIB correctly this does not 
appear to be the case:&nbsp; Indices of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables seem to increase upward in memory, just as they do in any other XPL/I array.&nbsp; </font><br>
</blockquote>Region 7 is a bit trickier to explain.&nbsp; It is an 
area dedicated to data which <b>XCOM-I</b> wants to use for XPL objects 
it creates at compile time that need to be accessible to the XPL program
 as normal XPL variables, but that need to be exempt from the normal 
memory-management 
procedures applied to regions 5 and 6.&nbsp; These are items which the 
original XPL compilers would have stored in regions 1 through 6, but 
that the different implementation of <b>XCOM-I</b> would have made difficult.&nbsp; <b>XCOM-I</b> allocates this area and the objects in it at compile-time.&nbsp; Though shown as beginning at <font color="#663300"><code>0xFFE000</code></font>, that's misleading.&nbsp; The <font color="#663300"><code>0xFFE000</code></font> limit is the default, and is appropriate for compiling <b>HAL/S-FC</b>, but in fact is controlled by <b>XCOM-I</b>'s <font color="#663300"><code>--reserved=<i>N</i></code></font>
 (default 8192) command-line option.&nbsp; There will be compile-time 
messages if the size of the reserved memory needs to be increased.&nbsp;
 It's important to note that all XPL programs sharing the same <font color="#663300"><code>COMMON</code></font> memory need to have the same size for region 7.&nbsp; Specifically, all passes of <b>HAL/S-FC</b> need to have the same size of reserved memory, and that's why this particular default value for it was chosen.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; In fact, the use of 
reserved memory has proven to be extremely rare.&nbsp; The only 
instances of use, to date, have been in <b>PASS2</b> and <b>PASS4</b> of <b>HAL/S-FC</b>, each of which stores a single object declared in a previously-unencountered, idiosyncratic way.</font><br>
</blockquote>
<br>
<blockquote>
</blockquote>


</td>
      <td valign="middle">
        <table width="100%" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Memory Layout</b></font></caption>

  <tbody>
    <tr>
  <th valign="bottom"><font size="-1">Addresses<br>
    </font></th>
  <th valign="bottom"><font size="-1">Description<br>
    </font></th>
  <th valign="bottom"><font size="-1">Region Number<br>
    </font></th>
</tr>

<tr>
  <td valign="top" align="right"><font color="#663300"><code><font size="-1">0xFFFFFF<br>
<br>
<br>
0xFFE000<br>
</font></code></font></td>
  <td valign="middle" align="center"><font size="-1"><br>Reserved memory<br>
      <br>
    </font></td>
  <td valign="middle" align="center">7<br>
  </td>
</tr>
<tr>
            <td valign="top" align="right"><br>
<br>
<br>
<br>
<br>
<br>
<br>
              <font color="#663300"><code></code></font></td>
            <td valign="middle" align="center"><font size="-1"><br>
                <br>
Data pointed to by "dope vectors" of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font><br>
                <br>
                <br>
              </font></td><td valign="middle" align="center">6<br>
</td>

          </tr>
<tr>
  <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">FREELIMIT</font></code></font></td>
  <td valign="middle" align="center"><font size="-1"><br>
512-byte zone<br>
      <br>
    </font></td>
  <td valign="middle" align="center"><font size="-1">5z</font><br>
  </td>
</tr>
<tr>
      <td valign="top" align="right"><font color="#663300"><code><font size="-1"><br>
                  <br>
                  <br>
                  <br>
FREEPOINT<br>
                  <br>
<br>
<br>
FREEBASE</font><br>
              </code></font></td>
<td valign="middle" align="center"><br>
          <font size="-1"><font size="-1">Data pointed to by "string descriptors" of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code></font><br>
              <br>
            </font></font>
      </td><td valign="middle" align="center">5<br>
</td>

    </tr>
    
    
    <tr>
  <td valign="middle" align="center"><font size="-1"><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
BASED</code></font></font> dope vectors for non-<font color="#663300"><code>COMMON</code></font><br>
      <br>
    </font></td><td valign="middle" align="center">4<br>
</td>

</tr>
<tr>
  <td valign="bottom" align="right"><font size="-1"><font color="#663300"><code>DESCRIPTOR</code></font><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code><font color="#000000"> string descriptors<br>
        <br>
      </font></font></font></font></td><td valign="middle" align="center">3<br>
</td>

</tr>
<tr>
      <td valign="bottom" align="right"><br>
</td>
<td valign="middle" align="center"><font size="-1"><br>
            </font><font color="#663300"><font size="-1" color="#000000"><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(</code><code>≤32)</code></font> , and <font color="#663300"><code>BASED</code></font> dope vectors for</font></font></font></font></font><font size="-1"><font color="#663300"><font color="#000000"> non-<font color="#663300"><code>COMMON</code></font></font></font></font><font size="-1"><br>
            <br>
          </font>
      </td><td valign="middle" align="center">2<br>
</td>

    </tr>
    <tr>
            <td valign="top"><br>
            </td>
            <td valign="middle" align="center"><font color="#663300"><code><br>
</code></font><font color="#663300"><font size="-1" color="#000000"><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(</code><code>≤32)</code></font> , and <font color="#663300"><code>BASED</code></font> dope vectors for </font><code>COMMON</code></font></font><font color="#663300"><code></code></font></font><code><br>
                  <br>
                </code></font></td><td valign="middle" align="center">1<br>
</td>

          </tr>
<tr>
      <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">0x000000</font></code></font></td>
<td valign="middle" align="center"><br>
<font size="-1"><font color="#663300"><code><font color="#663300"><font size="-1" color="#000000">Data supplied by <font color="#663300"><code>MONITOR(13)</code></font> and <font color="#663300"><code>MONITOR(23)<br>
        <br>
</code></font></font></font>
    
    </code></font>
            
          </font>
      </td><td valign="middle" align="center">0<br>
</td>

    </tr>
    
    
    
    
    
  </tbody>
        </table>
        </td></tr></tbody></table>
<h2><a name="compactify"></a>Understanding COMPACTIFY</h2>

<p>At runtime, changes to sizes of <font color="#663300"><code>BASED</code></font>
 arrays may cause those arrays to move around within memory region 6 
(see the preceding section).  Depending on the type of changes, this can
 cause "holes" of unused memory to develop in memory region 6.  
Similarly, operations on <font color="#663300"><code>CHARACTER</code></font> variables such as <font color="#663300"><code>INPUT</code></font> or string concatenation (<font color="#663300"><code>||</code></font>) can cause holes of unused memory to develop in memory region 5.  As long as <font color="#663300"><code>FREEPOINT</code></font> is comfortably less than <font color="#663300"><code>FREELIMIT</code></font>,
 these holes don't cause any problem and can just be ignored.  However, 
it may eventually become necessary to repack these memory regions to 
consolidate the free space and eliminate the holes.  <br></p>
<p>As far as memory region 6 is concerned, that's handled transparently by the tools already discussed in <a moz-do-not-send="true" href="#basedManagement">the section on <font color="#663300"><code>BASED</code></font> variables</a> earlier, and won't be discussed here.  The <font color="#663333"><code>COMPACTIFY</code></font>
 procedure which handles this for memory region 5, unfortunately, does 
require some clarification, even though you typically don't need to 
explicitly call <font color="#663300"><code></code></font><font color="#663333"><code>COMPACTIFY</code></font> yourself, and can assume it will just be called automatically whenever needed.<br></p>
<p>Most importantly, while <font color="#663333"><code>COMPACTIFY</code></font> doesn't handle memory management of <font color="#663300"><code>BASED</code></font> variables, the existence of based variables <i>does</i> affect how <font color="#663333"><code>COMPACTIFY</code></font> operates, with the result that different versions of <font color="#663333"><code>COMPACTIFY</code></font> must be used for XPL code than for XPL/I code.  But there's a quirk in XPL's implementation:  While <font color="#663333"><code>COMPACTIFY</code></font> is considered a "built-in" function of the XPL runtime library, in point of fact it's <i>not</i> present in the XPL (or XPL/I) runtime library, and must instead be explicitly provided in the form of XPL source code.<br></p>
<p>Fortunately, that doesn't entail any effort on your part, since <b>XCOM-I</b>
 can usually figure out what to do on its own.  But still, it may be 
helpful to understand what's going one behind the scenes, for those 
cases in which you need to intervene.  The <b>XCOM-I</b> approach to the inclusion of <font color="#663333"><code>COMPACTIFY</code></font>
 is that prior to loading any of the XPL or XPL/I source-code files you 
explicitly specify, it automatically preloads a "library file", which is
 an XPL or XPL/I source-code file containing <i>at least</i> the source code for <font color="#663333"><code>COMPACTIFY</code></font>.  The library file it chooses is governed by the following rules:<br></p>
<ol>
  <li>By default, it chooses SPACELIB.xpl, which is a duplicate of the 
Intermetrics file of the same name provided with the XPL/I source code 
for the <b>HAL/S-FC</b> program.  It should be good for compiling all XPL/I source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--xpl</code></font>
 is used, the default library changes to XPL.LIBRARY.xpl.  This a 
duplicate of the library of the same name provided with the source code 
of <b>XCOM3</b> program.  It should be good for compiling all standard XPL source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--lib-file=<i>FILENAME</i></code></font> is used, then <font color="#663300"><code><i>FILENAME</i></code></font> is used in place of the default library file.  This gives you the option of using some other version of <font color="#663333"><code>COMPACTIFY</code></font>, perhaps experimenting with it yourself.  If used along with an <font color="#663300"><code>--xpl</code></font> switch, then <font color="#663300"><code>--lib-file</code></font> must <i>follow</i> <font color="#663300"><code>--xpl</code></font> on the command line.<br></li>
</ol>
That's all you really <i>need</i> to know, and perhaps more than you needed.&nbsp; Unfortunately, <i>I</i> need to know more about it, in order to make it work in <b>XCOM-I</b>, and here's as good a place as any to write down some of that need-to-know info!<br>
<br>
The principal difficulty is that while XPL.LIBRARY.xpl works immediately
 for XPL programs, as-is, as long as the memory partitioning described in
 the preceding section is compatible <i>enough</i> with <i>A Compiler Generator</i>, the same cannot be said of SPACELIB.xpl for XPL/I programs.<br>
<br>
In brief, here's how the XPL <font color="#663333"><code>COMPACTIFY</code></font>
 of XPL.LIBRARY.xpl works.&nbsp; All of the "string descriptors" 
(providing the addresses and sizes of the character strings in region 5 
which need to be repacked) are found, contiguously, in memory region 3, 
which they completely fill.&nbsp; Because of this convenient 
arrangement, all of the string descriptors can all be accessed as if 
they were a single <font color="#663300"><code>FIXED</code></font> array.&nbsp; Standard XPL's built-in <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font>
 respectively give the location and size of this array of string 
descriptors.&nbsp; Repacking region 5 is a relatively-simple matter of 
sorting <font color="#663300"><code>DESCRIPTOR</code></font> array by 
address, using the sorted array to find the "holes", then moving the 
string data downward in region 5 to eliminate the holes, and finally 
updating the original descriptors in the <font color="#663300"><code>DESCRIPTOR</code></font> array to preserve the strings but to change the addresses.<br>
<br>
The only mild complication in the description above is that the <font color="#663300"><code>DESCRIPTOR</code></font> array can't be sorted <i>in place</i>.&nbsp; Rather, a separate scratch array is needed to help out the process:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);</font><br></pre>
</blockquote>
This <font color="#663300"><code>DX</code></font> array is set up to contain the indices into the <font color="#663300"><code>DESCRIPTOR</code></font> array, and it's <font color="#663300"><code>DX</code></font> that's sorted rather than <font color="#663300"><code>DESCRIPTOR</code></font>.&nbsp; This is undoubtedly a good strategy, although it limits the total number of <font color="#663300"><code>DECLARE</code></font>'d <font color="#663300"><code>CHARACTER</code></font>
 variables to 500.&nbsp; On the other hand, the limit of 500 is 
completely arbitrary, and if you have enough memory (we do!) there's no 
reason it couldn't be increased as high as 64K.&nbsp; And by the simple 
expedient of declaring <font color="#663300"><code>DX</code></font> as <font color="#663300"><code>FIXED</code></font> rather than <font color="#663300"><code>BIT(16)</code></font>, the limit could be made much higher.<br>
<br>
Unfortunately, the relatively-simple processing fails for XPL/I code — or at least, for any XPL/I code having <font color="#663300"><code>BASED</code></font> variables containing <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT(≥32)</code></font>
 data — because no longer are all of the string descriptors nicely lined
 up for us in memory region 3.&nbsp; Rather, many of them are smeared 
all over memory region 6.&nbsp; Nor is a limit of 500 strings remotely 
adequate for compiling programs like <b>HAL/S-FC</b>.&nbsp; Here is what I understand of the differences between how the XPL/I <font color="#663333"><code>COMPACTIFY</code></font> has to operate, as compared to the description I just gave of the XPL <font color="#663333"><code>COMPACTIFY</code></font>:<br>
<ul>
  <li>While the built-ins called <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font> still exist, and still provide exactly the same info about memory region 3, they are no longer relevant to <font color="#663333"><code>COMPACTIFY</code></font>.</li>
  <li><font color="#663300"><code>DX</code></font> is now a <font color="#663300"><code>BASED FIXED</code></font>,
 because it contains pointers to the string descriptors (i.e. it 
contains memory addresses of the string descriptors) rather than just 
indices into region 3.</li>
  <li><font color="#663300"><code>DX_SIZE</code></font> gives the number of elements of <font color="#663300"><code>DX</code></font>, but as it's nowhere <font color="#663300"><code>DECLARE</code></font>'d in the library, I suppose it must be an undocumented XPL/I built-in.</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">  I'd venture the guess that </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> is initially set and space for </font><font size="-1"><font color="#663300"><code>DX</code></font> is initially allocate by the XPL/I compiler to handle the string descriptors which are </font><font size="-1"><font color="#663300"><code>DECLARE</code></font>'d and therefore known at compile time.  At runtime, SPACELIB would then take over the task of maintaining </font><font size="-1"><font color="#663300"><code>DX</code></font> and </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> to handle additional string descriptors that come into existence (or leave it) when </font><font size="-1"><font color="#663300"><code>BASED</code></font> variables containing them grow (or shrink).</font><br></p>
</blockquote>


More TBD<br>
<h2>Structure of an XPL Program vs XPL/I<br>

</h2>


<p>An XPL program consists of any sequence of XPL <i>statements</i>, followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp; In particular:<br></p>
<ul>
  <li>Declarations of variables can be intermixed with active statements such as assignments.</li>
  <li>Active code can exist at the global level, outside of any <font color="#663300"><code>PROCEDURE</code></font>s. <br></li>
</ul>

<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, which
 was called XCOM, performed a single pass.&nbsp; It required that the 
declaration of any particular identifier as an object (such as a 
variable) had to precede the use of that identifier, although there were
 provisions for making a forward declaration for a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font>, so that the </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> could be used before it was defined.&nbsp; <b>XCOM-I</b> relaxes this requirement.<br></font></p></blockquote><font size="-1"></font>
<p>Each of the sample programs I've encountered in standard XPL so far has been contained in a single <i>relatively</i>-small file.  For example, <b>ANALYZER</b> has a little over 1500 lines of source code, while <b>XCOM</b> has a little over 4200 lines.   <br></p>
<p>In contrast, the XPL/I source code for Intermetrics's HAL/S compiler <b>HAL/S-FC</b>
 has over 120,000 lines of source code spread across over 600 files, 
though any individual pass of the compiler has no more than around 
35,000 lines.  This huge size, along with the huge difference from 
programs in standard XPL, necessitates different methods for managing 
that source-code base, and some of those methods are reflected by 
compiler directives embedded within the source code.  Insofar as <b>HAL/S-FC</b>
 and its related applications are concerned, the top-level source-code 
file  (##DRIVER.xpl) for each application always contains all of the 
necessary directives for compiling the other source-code files needed, 
in the correct order, so in using XCOM-I to compile these applications 
you don't need to worry about any file other than ##DRIVER.xpl itself.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> Well, the comment about ##DRIVER.xpl 
isn't exactly right.  Any XPL or XPL/I program will expect that there's a
 separate "library file" containing source code for the <font color="#663300"><code>COMPACTIFY</code></font>
 procedure, but the XPL/I source code for the program won't explicitly 
include the library file.  That's the compiler's responsibility.<br><b></b></font></p>
<p><font size="-1"><b>Aside:</b> Due to the lack of relevant 
Intermetrics documentation, what I'm about to describe is not only 
speculative on my part, but also represents certain pragmatic 
compromises that I don't believe literally existed in Intermetrics' XPL 
compiler or development procedures.  But if it will work for us using <b>XCOM-I</b> on <b>HAL/S-FC</b> and if there are no other lurking XPL/I programs that we need to worry about, why complain?</font><br></p>

</blockquote>
Compiler directives in XPL/I are comments or comment-like constructions 
which aren't documented in <i>A Compiler Generator</i> and have no other obvious 
purpose.&nbsp; The specifics are covered by the subsections below.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/?<i>c</i> ... XPL/I source code ... ?/</code></font></h4>
This type of compiler directive is a conditional inclusion of source 
code, similar to the C language's <font color="#663300"><code>#if <i>c</i></code></font>.&nbsp; Here, <font color="#663300"><i><code>c</code></i></font>
 is supposed to be an upper-case alphabetical letter that represents the
 particular condition that needs to be "true".&nbsp; All conditions, <font color="#663300"><code>A</code></font> through <font color="#663300"><code>Z</code></font>, are by default "false".&nbsp; You make condition <font color="#663300"><i><code>c</code></i></font> "true" by using <b>XCOM-I</b>'s <font color="#663300"><code>--cond=<i>c</i></code></font> command-line switch.<br>
<br>
Interpretations of the possible conditions are entirely at the user's 
disposal; i.e., they vary by the particular source-code being compiled 
by <b>XCOM-I</b>.&nbsp; In the particular case of the XPL/I source code for the <b>HAL/S-FC</b> program, there are 4 
possible conditions <font color="#663300"><i><code>c</code></i></font>, plus 2 additional ones I invented personally:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Preprocessor Conditionals</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">XCOM-I Command-Line Switch<br>
      </th>
      <th valign="top">Interpretation<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=P</code></font><br>
      </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Primary Flight Software (PASS).</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=B</code></font> </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Backup Flight Software (BFS).<br>
        <b>Note:</b>&nbsp; Either <font color="#663300"><code>--cond=P</code></font> or <font color="#663300"><code>--cond=B</code></font> must be used, but not both at the same time.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=A</code></font></td>
      <td valign="top">Produce debugging output related to memory management of <font color="#663300"><code>BASED</code></font> variables.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=C</code></font></td>
      <td valign="top">Produces debugging output related to actions by the <font color="#663300"><code>COMPACTIFY</code></font> procedure.</td>
    </tr><tr>
  <td valign="middle" align="center"><font color="#663300"><code>--cond=V</code></font><br>
  </td>
  <td valign="top">For code specific to the Virtual AGC Project.&nbsp; 
This is my own innovation, and of course was not used in any legacy 
code.&nbsp; It is used in those few cases (2 at the present count) in 
which legacy code is appropriate for modern usage, or XCOM-I has some 
bug which cannot be overcome, and thus the legacy code needs to be 
replaced to make the program that's being compiled usable.<br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center"><font color="#663300"><code>--cond=W</code></font><br>
  </td>
  <td valign="top">The opposite of <font color="#663300"><code>--cond=V</code></font>.<br>
  </td>
</tr>

  </tbody>
</table>
<br>
<ul></ul>
<blockquote>
  <p><font size="-1"><b>Aside:</b> This implies that you don't just compile <b>HAL/S-FC</b> <i>once</i> to get a HAL/S compiler that works for all HAL/S programs.  Rather, you compile <b>HAL/S-FC</b> <i>twice</i>,
 once to get a version of the HAL/S compiler that works for the primary 
flight software, and once to get a version of the compiler that works 
for the backup flight software.</font></p>
</blockquote>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/%INCLUDE <i>module</i> %/</code></font></h4>
This type of compiler directive inserts an entire XPL/I source-code file, <i>module</i>.xpl, at the current point.&nbsp; It is used for importing <font color="#663300"><code>COMMON</code></font>-block
 declarations or macros which are used identically by all source-code 
files.&nbsp; By default, the included module is taken from the folder 
../HALINCL/.&nbsp; As far as I know this covers every use in <b>HAL/S-FC</b> source code.&nbsp; However, if necessary, <b>XCOM-I</b> has a command-line option (<font color="#663300"><code>--include=<i>folder</i></code></font>) which can be used to change the folder containing the modules.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/* ...comment... <i>$%module</i> */</code></font></h4>
This is a variant of the<font color="#663300"><code> /%INCLUDE <i>module</i> ...comment... %/</code></font>
 directive, which acts the same way, and for which my comments are otherwise the same.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/**MERGE <i>module</i> <i>procedure</i> */</code></font></h4>
This is yet another directive for including an XPL/I source-code file in
 the current XPL/I source-code file, but it differs from the other 
include-directives described above in that instead of importing 
definitions used in common by multiple source-code files, it instead is 
typically used for importing the source code for a single <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; As above, <i>module</i>.xpl is the source-code file to include, while <i>procedure</i> is the name of the <font color="#663300"><code>PROCEDURE</code></font> contained in that file.&nbsp; In point of fact, <b>XCOM-I</b> simply ignores the procedure name.<br>
<blockquote><font size="-1"><b>Aside:</b> Procedure names don't match 
the filenames, usually, because the naming conventions for System/360 
files were severely limited vs identifiers in XPL.&nbsp; Thus the 
filenames were normalized, truncated forms of the procedure names.</font><br>
</blockquote>
Also, <i>module</i>.xpl is expected to be within the same folder as the 
source-code file being compiled; no other folders are searched for it, 
and there are no command-line switches to alter this behavior.<br>
<blockquote>
</blockquote>

<h2>PROCEDUREs, RETURNs, and Their Peculiarities<br>

</h2>

<p>In a view from a height, an XPL program consists of <font color="#663333"><code>PROCEDURE</code></font> definitions and of code that uses those definitions.<br></p>
<p>A procedure definition looks something like this:<br></p>
<blockquote>
  <pre><font color="#663300"><i>label</i>:<br>PROCEDURE(... <i>parameter list</i> ...) <i>ReturnType</i>;<br>	DECLARE ... <i>for the parameters</i> ...;<br>	DECLARE ... <i>for local variables</i> ...;<br><br>	... <i>code</i> ...;<br>END <i>label</i>;</font><br></pre>
</blockquote>

<p><font color="#663333"><font color="#000000">A lot of this is optional.  Thus while the initial <font color="#663300"><code><i>label</i>:</code></font> is required (since it's the name of the procedure), the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><code><i>label</i></code></font></font></font>
 at the end of the definition is optional, and is really there only for 
readability purposes.  If the procedure needs no parameters, then the <font color="#663300"><i><code>parameter list</code></i></font>, <i>including</i> its enclosing parentheses, is omitted.  If the procedure returns no value, then <font color="#663300"><i><code>ReturnType</code></i></font> is omitted; if present, it is one of the basic non-subscripted datatypes <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(<i>n</i>)</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.  Each parameter in the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><i><code>parameter list</code></i></font></font></font>
 must have a declaration within the body of the procedure, and while 
those declarations don't technically have to precede the declarations of
 the local variables as shown above, it was apparently customary to do 
so.</font></font></p><font color="#663333"><code>PROCEDURE</code></font> definitions in the source code can be nested, to any desired depth.  <font color="#663333"><code>PROCEDURE</code></font> definitions and <font color="#663300"><code>DO...END</code></font>
 blocks provide the program with a hierarchical structure of 
"scopes".&nbsp; The hierarchical structure is provided by the 
parent/child relationships among the scopes.  Variables are accessible 
within the scope in which they're declared, along with any descendant scopes.  If a
 variable is declared in more than one scope of the hierarchy, the one 
in the innermost enclosing scope is the one that is applicable.  <br>
<br>
In standard XPL, variables can be declared only at the global level or in a <font color="#663300"><code>PROCEDURE</code></font>, and not within <font color="#663300"><code>DO...END</code></font> blocks.&nbsp; <br>
<br>
In XPL/I, variable (and <font color="#663300"><code>PROCEDURE</code></font>) definitions can be declared anywhere, even within <font color="#663300"><code>DO...END</code></font> blocks.&nbsp; <b>XCOM-I</b> mimics the XPL/I usage, since it's compatible with standard XPL.&nbsp; But there's a trap!&nbsp; Or at least, it's a trap for <i>me</i>, and by projection, I assume it's a trap for you as well.&nbsp; The trap is that you'd suppose the scope of a variable or <font color="#663300"><code>PROCEDURE</code></font> was the <font color="#663300"><code>DO...END</code></font> block in which it was declared.&nbsp; Not so!&nbsp; The scope is the entire enclosing <font color="#663300"><code>PROCEDURE</code></font>
 and its descendants.&nbsp; So beware.&nbsp; Fortunately, such 
abominations are very rare, and only a handful appear in the entire <b>HAL/S-FC</b> source-code base.&nbsp; Here's an example from the <font color="#663300"><code>DUMP_SDF PROCEDURE</code></font> of <b>PASS4</b> of the compiler, cleaned up a little for readability.&nbsp; Observe the declaration and usage of the variable <font color="#663300"><code>SYM_DATA_CELL_ADDR</code></font> within the two distinct <font color="#663300"><code>DO...END</code></font> blocks:<br>
<blockquote>
  <pre>            IF NODE_B(3) &gt; 0 THEN <font color="#009900">DO; <br> 	       /* IN CASE OF SYMBOL XREF EXTENSION CELL, SAVE ADDR OF SYM DATA CELL */<br>               DECLARE <font color="#ff0000">SYM_DATA_CELL_ADDR</font> FIXED; <br>               <font color="#ff0000">SYM_DATA_CELL_ADDR</font>= COREWORD(ADDR(NODE_F)); <br>               CALL PRINT_XREF_DATA(SHR(NODE_B(3),1));<br>            END</font>; <br><br>            IF ASIP_FLAG &amp; (SCLASS=1 | SCLASS=2 &amp; NAME_FLAG) THEN <font color="#3333ff">DO;<br> 	       /* RESTORE NODE_F TO SYM_DATA_CELL_ADDR BEFORE GETTING AUXILIARY INFO. */<br>               COREWORD(ADDR(NODE_F))  = <font color="#ff0000">SYM_DATA_CELL_ADDR</font>;<br>               IF STYPE=16 &amp; ^NAME_FLAG THEN<br>                  CALL FORMAT_NAME_TERM_CELLS(I,NODE_F(-2));<br>               ELSE OUTPUT = X10||'INITIAL(NAME('|| <br>                  FORMAT_VAR_REF_CELL(NODE_F(-2)) || '))';<br>            END</font>; <br></pre>
</blockquote>
A <font color="#663333"><code>PROCEDURE</code></font> may be invoked in two different ways.&nbsp; If it returns a value via a <font color="#663300"><code>RETURN</code></font>
 statement, it can be used in an arithmetical expression or a string 
expression.&nbsp; If it doesn't return a value, or if it does return a 
value and you simply want to ignore the value, a <font color="#663333"><code>CALL</code></font> statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font>
 but to discard any returned value.&nbsp; But don't be deceived!&nbsp; 
Cases in which these rules are simply ignored exist in legacy code, and 
we'll talk a little bit more about that below.<br>

<p><b>Important:</b>&nbsp; All variables local to a <font color="#663333"><code>PROCEDURE</code></font> definition retain their values after the <font color="#663333"><code>PROCEDURE</code></font> returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font> is re-executed, those local variables retain the values they previously had in the prior invocation of the <font color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values of those local variables, though retained, are inaccessible to code outside of the <font color="#663333"><code>PROCEDURE</code></font>,
 because the namespaces of the local variables prevent it. (In C code, this 
would be the same thing as saying that every local variable of every 
function is automatically declared as <font color="#663333"><code>static</code></font>.)
</p>
<p><b><i>Very</i> important:</b> Any (or even all) <i>parameter</i>s at the trailing end of the calling list of a <font color="#663333"><code>PROCEDURE</code></font> can be omitted from when calling the <font color="#663333"><code>PROCEDURE</code></font>, and if omitted, they too retain the same values as the last time the <font color="#663333"><code>PROCEDURE</code></font> was invoked <i>or</i> the values previously assigned to those parameters from within the <font color="#663333"><code>PROCEDURE</code></font> itself!&nbsp; (In essence, this is like saying that parameters of a <font color="#663333"><code>PROCEDURE</code></font> are not passed to the <font color="#663333"><code>PROCEDURE</code></font>, but rather that they are just aliases for some set of global variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp; That's so weird that we need to see an example.&nbsp; Consider the following XPL <font color="#663333"><code>PROCEDURE</code></font> definition, and <font color="#663333"><code>CALL</code></font>s to it:
</p>
<blockquote>
  <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
</blockquote>
<p>The five calls successively print out the following:
</p>
<blockquote>
  <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
</blockquote>
<p><font color="#663333"><code>PROCEDURE</code></font>s cannot be recursive, either directly or indirectly.<br></p>
<p>Taking these facts altogether, <b>XCOM-I</b> implements both parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s essentially as global variables in they way they are stored:&nbsp; i.e., each parameter and each local variable of each <font color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i>
 address (in the global memory model), assigned at compile time and 
unchanging thereafter.&nbsp; The compiler enforces the logical scoping 
of these variables by means of their namespace.&nbsp; There will be more
 on this when the concept of "mangling" of identifiers is discussed.<br></p>
<p>Regarding the <font color="#663300"><code>RETURN</code></font> statement, <i>A Compiler Generator</i> explains that it is used to exit from a <font color="#663333"><code>PROCEDURE</code></font>
 and optionally to return a value.  Furthermore, the calling code can 
either use that return value or else ignore it.  Which makes perfect 
sense.  But  as usual, there are some documented and undocumented 
peculiarities to the <font color="#663300"><code>RETURN</code></font> statement as well:<br></p>
<ul>
  <li><i>A Compiler Generator</i> explains (p. 146) that calling code can <i>use</i> returned values from <font color="#663300"><code>PROCEDURE</code></font>s even if the <font color="#663300"><code>PROCEDURE</code></font> has no <font color="#663300"><code>RETURN</code></font> statement, or the <font color="#663300"><code>RETURN</code></font>
 statement specifies no value.  In this case, we are told, the return 
value is simply some unpredictable value from some unspecified 
System/360 register.  Which is rotten, of course, but so what?  This is 
never going to happen, right?  Wrong!  Actual XPL code does this from 
time to time.  <b>XCOM-I</b>, on the other hand, <i>always</i> returns a well-defined value from a <font color="#663300"><code>PROCEDURE</code></font>, whether or not there are any <font color="#663300"><code>RETURN</code></font> statements specifying a return value; the returned value in this case is 0 if <font color="#663300"><code>FIXED</code></font>, a <font color="#663300"><code>BIT</code></font> value of the appropriate width evaluating to 0, or else the empty string for a <font color="#663300"><code>CHARACTER</code></font>.</li>
  <li><i>A Compiler Generator</i> (probably!) does not mention that <font color="#663300"><code>RETURN</code></font>
 statements may exist at the global level, outside of the scope of any 
procedure, and may return a value when they do.  But they can.  <b>XCOM-I</b>
 treats these as exits from the program back to the operating system, 
with the returned value being the program's exit code.  It thus expects 
the return value to be a program status code.</li></ul>
<h2>Blocks and Loops</h2>

<p>Compound statements in XPL are groupings of simple statements (such 
as assignments or if-then-else statements) enclosed within a <font color="#663300"><code>DO ... END</code></font> block:<br></p>
<blockquote>
  <pre><font color="#663300">DO ...;<br>    ... simple statements ...<br>END;</font><br></pre>
</blockquote>
<p>There are five different kinds of <font color="#663300"><code>DO ... END</code></font> blocks.  First, there is a stand-alone simple grouping as shown above.<br>
</p>


<p>Then there are 3 different kinds of loops:</p>
<pre><font color="#663300">DO <i>COUNTER</i> = <i>START</i> TO <i>END</i> [BY <i>STEP</i>];<br>    ... simple statements ...<br>END;<br><br></font><font color="#663300">DO WHILE <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
<br><font color="#663300">DO UNTIL <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
</pre>

<p>Note that <font color="#663300"><code>DO UNTIL</code></font> is new in XPL/I and is not present in standard XPL.<br></p>
<p>In these loops, <i><font color="#663300"><code>COUNTER</code></font></i>, <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and the optional <i><font color="#663300"><code>STEP</code></font></i> are all integers.  <i><font color="#663300"><code>STEP</code></font></i> defaults to 1, but must be <i>positive</i>.  <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and <i><font color="#663300"><code>STEP</code></font></i>
 may be expressions, but if so they are evaluated only a single time, at
 the start of the loop, and are not reevaluated thereafter.  <i><font color="#663300"><code>CONDITION</code></font></i>,
 on the other hand, is an expression evaluated on each loop; it is 
treated as "true" if its least-significant bit is 1, or "false" if its 
least-significant bit is 0.&nbsp; When I say they are "integers", I don't mean that they are necessarily <font color="#663300"><code>FIXED</code></font>; they could also be <font color="#663300"><code>BIT(</code><code>≤32)</code></font>, which evaluate to integers.<br>
</p>
<p>The fifth kind of <font color="#663300"><code>DO ... END</code></font> block is:<br></p>
<blockquote>
  <pre><font color="#663300">DO CASE EXPRESSION;<br>    STATEMENT0;<br>    STATEMENT1;<br>    STATEMENT2;<br>    ...<br>END;</font><br></pre>
</blockquote>
<p>The <i><font color="#663300"><code>EXPRESSION</code></font></i> must also evaluate to an integer.  If 0, then <i><font color="#663300"><code>STATEMENT0</code></font></i> is executed; if 1, then <i><font color="#663300"><code>STATEMENT1</code></font></i>
 is executed; and so on.  At most, a single statement is executed, and 
there is no "fall through" from one statement to the next.  If the <i><font color="#663300"><code>EXPRESSION</code></font></i>
 is negative or beyond the number of available statements, <i>A Compiler Generator</i>
tells us that "a random jump is executed".  In <b>XCOM-I</b>, no statement is 
executed under those circumstances, and control passes to the next 
statement after the <font color="#663300"><code>END</code></font>.<br></p>
<h2><font size="+3"><code>ESCAPE</code></font> and <font size="+3"><code>REPEAT</code></font><br>

</h2>


<p>The <font color="#663300"><code>ESCAPE</code></font> and <font color="#663300"><code>REPEAT</code></font>
 keywords appear to be undocumented XPL/I features not present in 
standard XPL.  Unfortunately, from the available material I can't think 
of any way to be <i>sure</i> what they do, so I can only speculate.<br></p>
<p><font color="#663300"><code>ESCAPE</code></font> appears in two different forms:<br></p>
<ul>
  <li><font color="#663300"><code><font color="#663300"><code>ESCAPE;</code></font> <br></code></font></li>
  <li><font color="#663300"><code>ESCAPE <i>LABEL</i>;</code></font> <font color="#663300"><code></code></font></li>
</ul>
<p>It should be noted that the HAL/S language has the keyword <code><font color="#663300">EXIT</font></code>, which also has these two forms.  (<a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/Programming%20in%20HAL_S%20Sept%201978.pdf#page=96">See Ryer, p. 5-12</a>.)  <code><font color="#663300">EXIT</font></code> has the following behavior in HAL/S:<br></p>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>EXIT</code></font>;</code></font> — Exits from the innermost enclosing <font color="#663300"><code>DO ... END</code></font> block.  I.e., it's essentially a <font color="#663300"><code>GO TO</code></font> to just after the closest enclosing <font color="#663300"><code>END</code></font>.</li>
  <li><font color="#663300"><code>EXIT <i>LABEL</i>;</code></font> — Exits from an enclosing <font color="#663300"><code>DO ... END</code></font> that isn't necessarily the innermost one, but rather the one which instead has the specified <i><font color="#663300"><code>LABEL</code></font></i> attached to it.  By "attached to it", I mean that they're directly adjacent, as in "<font color="#663300"><code><i>LABEL</i>: DO ...</code></font>".<font color="#663300"><code></code></font></li>
</ul>
<p>Until a more-plausible explanation comes along, my assumption is that <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> in XPL/I has the same behavior as HAL/S's <font color="#663300"><code>EXIT</code></font>.<br></p>
<p>For example, consider the following XPL/I code:<br></p>
<blockquote><font color="#663300"><code>...</code><code></code></font><br>
  <font color="#663300"><code></code><code>MYBLOCK: </code><code></code></font><br>
  <font color="#663300"><code></code><code>DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ESCAPE; /* Escape #1 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESCAPE MYBLOCK; /* Escape #2 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; END;</code><code></code></font><br>
  <font color="#cc0000"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Escape #1 comes here! */</code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code></font><br>
  <font color="#663300"><code>END;</code></font><br>
  <font color="#cc0000"><code></code><code>/* Escape #2 comes here! */</code></font><br>
  <font color="#663300"><code>...</code></font><br>
  <font color="#663300"><code></code></font></blockquote>
<font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> also appears in those same two forms:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font> <br></code></font></li><li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> </li>
</ul>
And again, there's a <font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font></code></font>
 keyword in HAL/S as well.&nbsp; In this case, though, from examining 
the actual usage in HAL/S-FC source code, I believe that while the 
keyword has a <i>similar</i> behavior in HAL/S and XPL/I, there is 
nevertheless a distinction between them.&nbsp; Here's what I believe the
 behavior is in XPL/I:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font></code><font color="#000000"> </font></font>— "Repeats" the smallest enclosing <font color="#663300"><code>DO ... END</code></font>.  In case the smallest enclosing <font color="#663300"><code>DO ... END </code></font>is a loop — <font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font> — saying that it "repeats" has a pretty clear meaning: XPL/I <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> is like a Python or C <font color="#663300"><code>continue</code></font> statement.  On the other hand, if the immediately-enclosing <font color="#663300"><code>DO ... END</code></font> is <i>not</i> a loop, the expected behavior is less clear; nor are there any instances of <font color="#663300"><code>REPEAT</code></font> in non-loops in legacy XPL/I code from which we might get a clue.&nbsp; <b>XCOM-I</b> implements <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
 without a label simply as a jump to the beginning of the block, which 
means that you could form an infinite loop if there were no other code 
(like <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code>GO TO</code></font>) to exit the loop.</li>
<li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> — Breaks out of inner loops as needed, until reaching an enclosing <font color="#663300"><code>DO ... END</code></font> loop that has the attached <i><font color="#663300"><code>LABEL</code></font></i>. <i>That's</i> the block that it repeats.</li>
</ul><ul>
</ul>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The way my XPL/I implementation is different from HAL/S is that in HAL/S, <font color="#663300"><code>REPEAT</code></font> (without a label) goes to the beginning of the innermost enclosing <i>loop</i> (<font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font>) rather than the innermost enclosing <font color="#663300"><code>DO ... END</code></font>.&nbsp; Which makes sense, since that's what you'd normally want.<br>
  </font></blockquote>
<b>Note:</b>&nbsp; Neither <font color="#663300"><code>ESCAPE</code></font> nor <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> accepts a label attached to an arbitrary statement.&nbsp; It must be a label attached to a <font color="#663300"><code>DO ... END</code></font> block, and it must at some level enclose the <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> statement itself.<br>
<h2>Counter Value After Normal Loop Termination<br>


</h2>


<font color="#663300"><code></code></font>For XPL code such as<br>
<blockquote>
  <pre><font color="#663300">DO I = 1 to 100;<br>    ...<br>END;</font><br></pre>
</blockquote>
it appears to be undocumented what value <font color="#663300"><code>I</code></font>
 holds after the loop ends.&nbsp; Not all computer languages handle this
 in the same way.&nbsp; My considered opinion is that the loop counter 
holds the value at which the condition for continuation fails: in this 
example, 101.&nbsp; Or, if the loop is broken prematurely (as with <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> from the preceding section), then the value the counter held when the <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> occurred is retained.<br>
<blockquote><font size="-1"><b>Aside:</b></font>&nbsp; This would match the behavior of C.&nbsp; Whereas in Python, for 
example, the counter for an equivalent loop would have the value 100 
rather than 101 after normal termination of the loop.<br>
</blockquote>
<h2>Order of Evaluation of Procedure Operands</h2>
<p>In an XPL string-concatenation expression like this one,<br>
</p>
<blockquote>
  <pre>EXPRESSION1 || EXPRESSION2<br></pre>
</blockquote>
<p>while I've found no documentation concerning it, XPL/I expects the operands to be evaluated in left-to-right order.&nbsp; I.e., <code>EXPRESSION1</code> is evaluated first, then <code>EXPRESSION2</code>
 is evaluated, and then they are concatenated.&nbsp; Normally this 
ordering doesn't matter, but it matters if as a side-effect of <code>EXPRESSION1</code> some values needed to compute <code>EXPRESSION2</code> are altered, or vice-versa.&nbsp; I know that this is the expectation because I have found code in <b>PASS2</b> of <b>HAL/S-FC</b> that does not work as needed if a right-to-left order of evaluation is used.<br>
</p>
<p><i>Presumably,</i> the left-to-right ordering should be enforced on <i>all</i> calls to procedures, and possibly all operator expressions, rather than just this string-concatenation example.&nbsp; <b>XCOM-I</b>
 already enforces left-to-right order in calls to all XPL procedures, 
but prior to this finding it did not enforce an ordering on parameter 
evaluation in calls to runtime-library functions.&nbsp; Frankly, it had 
never occurred to me that a C compiler might evaluate such arguments in 
right-to-left order.&nbsp; But some do, under some circumstances, and 
can do so because the C standard apparently does not specify the 
ordering.<br>
</p>
<p>As it stands presently:<br>
</p>
<ul>
  <li><b>XCOM-I</b> enforces left-to-right evaluation of arguments of XPL procedures.</li>
  <li><b>XCOM-I</b> enforces left-to-right evaluation of operands for operator expressions (such as <code>op1||op2</code> or <code>op1+op2</code>).</li>
  <li><b>XCOM-I</b> does not presently enforce any particular order of evaluation on other runtime-library functions (such as <code>SUBSTR</code> or <code>SHL</code>), but may be changed to do so in the future if problems become apparent.<br>
  </li>
</ul>
<p>In <i>A Compiler Generator</i>, Fig. 6.18.1 depicts the assembly code
 generated for a sample XPL program having several library-function 
calls with 2 or 3 parameters.&nbsp; In those examples, the code for the 
arguments is always in left-to-right order.<br>
</p>
<blockquote><font size="-1"><b>The example:</b>&nbsp; Look at this line in <b>HAL/S-FC</b>'s PASS2.PROCS/OBJECTGE.xpl:<br>
  </font>
  <blockquote>
    <pre><font size="-1">S2=GENERATE_OPERANDS || TAG_NAME;                                07411000<br></font></pre>
  </blockquote>
</blockquote>
<blockquote>
  <p><font size="-1">Here, <code>GENERATE_OPERANDS</code> is a <code>PROCEDURE</code>, and calling it has the side-effect of setting the <code>TAG_NAME</code> appropriately.&nbsp; </font><font size="-1"><font size="-1"><code>GENERATE_OPERANDS</code></font> therefore must be executed before <code>TAG_NAME</code> is used.&nbsp; (And it does no good to argue that </font><font size="-1"><font size="-1"><code>TAG_NAME</code></font> is merely string descriptor rather than a string so that it doesn't "evaluate" anything, since when </font><font size="-1"><font size="-1"><font size="-1"><code>GENERATE_OPERANDS</code></font></font> modifies the string it modifies the string descriptor too.)&nbsp; In <b>XCOM-I</b>, the string-concatenation operator<code></code> is implemented as a function, <code>xsCat</code>, so the two string operands are the two function parameters.&nbsp; I found that <b>clang</b> evaluated the function parameters left-to-right in a test program I created, while <b>gcc</b> evaluated them right-to-left.&nbsp; Whether they do that consistently or not, I don't know, but if they <i>ever</i> do it right-to-left it's a problem!&nbsp; If the ordering were not forced by <b>XCOM-I</b> to be correct, <b>clang</b> would print assembly code in <b>PASS2</b> correctly, such as<br>
    </font></p>
  <blockquote>
    <pre><font size="-1">00000 E8F3 0000                              LHI    R0,0()              TIME: 0.25; @0HELLO<br></font></pre>
  </blockquote>
  <p><font size="-1">while <b>gcc</b> would print it incorrectly, such as<br>
    </font></p>
  <blockquote>
    <pre><font size="-1">00000 E8F3 0000                              LHI    R0,0()              @0HELLO<br></font></pre>
  </blockquote>
  <font size="-1">The printout that includes the <code>TIME</code> must be the correct one, because otherwise the elaborate XPL procedure that constructs the time (<code>EXECUTION_TIME</code>) would have no effect at all.<br>
  </font></blockquote>
<blockquote>
</blockquote>

<h1><a name="programOptions"></a>Program Options</h1>

<p>As far as I've been able to determine, the standard XPL of <i>A Compiler Generator</i> did not support program options presented at program-start time.&nbsp; The submonitor program provided with <b>XCOM3</b> did have some such program options, but they were consumed only by the submonitor and were not passed to the XPL program.<br>
</p>
<p>In XPL/I, on the other hand, the XPL program could indeed accept a 
rich set of options, from a JCL object known as the "PARM field".&nbsp; 
One of the XPL built-in functions, the <font color="#663300"><code>MONITOR</code></font> function, was provided to access submonitor services, but <i>A Compiler Generator</i>
 left it basically undefined, presumably since any functionality it 
provided would be highly program-specific.&nbsp; In XPL/I, on the other 
hand, the <font color="#663300"><code>MONITOR</code></font> function is indeed defined with a rich set of features, and in particular, <font color="#663300"><code>MONITOR(13)</code></font>
 passes the submonitor the name of an "options processor", and the 
submonitor returns a set of program options (as interpreted by the 
selected options processor) back to the XPL/I program.<br>
</p>
<p>In <b>HAL/S-FC</b>, there are three different options processors 
defined, "COMPOPT" for pass 1 of the compiler, "LISTOPT" for pass 4 of 
the compiler, and "MONOPT" for the submonitor.&nbsp; At the present 
time, the <b>XCOM-I</b> runtime library supports these three options 
processors, and none other.&nbsp; Since the particular program options 
supported are specific to <b>HAL/S-FC</b>, they won't be covered here, but are covered in great detail on <a moz-do-not-send="true" href="HAL.html">the <b>HALSFC</b> page</a>.<br>
</p>
Besides the program options passed to the XPL program at startup, there 
were position-dependent options ("control toggles") which could be 
inserted directly into the XPL program within its comments.&nbsp; <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">Early documentation</a> indicates that control toggles could appear also appear in the PARM field.&nbsp; <i><b>XCOM-I</b></i><i> does not support either of these features. </i><br>

<br>

Control toggles are 
two-character strings which normally would be embedded in program 
comments.&nbsp; Generally speaking, program comments are ignored by 
compilers.&nbsp; But when these particular two-character strings are 
found within a program comment of an XPL program, they are used to 
enable certain program features from the point they appear until a 
countermanding control toggle is found.&nbsp; The control toggles I'm aware of that were supported by one or another version of <b>XCOMx</b> are listed below.&nbsp; Not all of them are necessarily suitable for command-line usage anyway; for example, the action of "<font color="#663300"><code>$|</code></font>"
 depends on its particular punch-card column in which it appears.&nbsp; The list below has been merged 
from <i>A Compiler Generator</i> (p. 148), IR-182-1 (section 13.4), and <b>XCOM45 </b>
source code:<br>

<ul>

  <li><font color="#663300"><code>$B</code></font> — Interlist code bytes in hexadecimal.</li>
  <li><font color="#663300"><code>$D</code></font> — Print compilation statistics and symbol table at the end of compilation (initially enabled).</li>
  <li><font color="#663300"><code>$E</code></font> — Interlist emitted code (assembly format) and data.</li>
  <li><font color="#663300"><code>$I</code></font> — Print Impact 
summary, indicating variables outside the scope of any procedure which 
were referenced, plus procedures called.&nbsp; (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$L</code></font> — List the compiled program (listing is initially enabled).</li>
  <li><font color="#663300"><code>$M</code></font> — List program without auxiliary information (speeds compilation by minimizing string storage usage).</li>
  <li><font color="#663300"><code>$N</code></font> — Produce a warning message if a procedure is called with fewer actual than formal parameters.</li>
  <li><font color="#663300"><code>$Q</code></font> — This toggle seems to have been available for a while and then discontinued.&nbsp; It <i>may</i> have caused compilation to terminate after processing the library file.<br>
  </li>
  <li><font color="#663300"><code>$R</code></font> — Collect cross-reference data for each symbol (based on statement numbers) and print with symbol table. (Default = On.)<br>
  </li>
  <li><font color="#663300"><code>$S</code></font> — Dump symbol table at the end of each procedure, if any local data is declared. (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$T</code></font> — Begin tracing execution of XCOM at this point, during compilation.</li>
  <li><font color="#663300"><code>$U</code></font> — Terminate tracing of XCOM.</li>
  <li><font color="#663300"><code>$V</code></font> — Expand variable 
cross reference to include names of procedures referencing data and 
names of procedures calling other procedures.&nbsp; (Default = Off.)</li>
  <li><font color="#663300"><code>$X</code></font> — Do not abort compilation when ceiling on count of severe errors has been exceeded.<br>
  </li>
  <li><font color="#663300"><code>$Y</code></font> — Use <font color="#663300"><code>'|'</code></font> as margin marker rather than <font color="#663300"><code>'I'</code></font>.<br>
  </li>
  <li><font color="#663300"><code>$Z</code></font> — Allow the compiled program to execute in spite of severe errors.</li>
  <li><font color="#663300"><code>$|</code></font> — Set margin.&nbsp; 
The portion of succeeding cards starting from the column containing the |
 will be ignored.&nbsp; Note that this can only be used to make the card
 width <i>shorter</i> than 80 columns.<br>
  </li>
</ul>Although <b>XCOM-I</b> doesn't support control toggles in the PARM field, there is a command-line option that can be made 
to serve the same purpose:&nbsp; 
The <font color="#663300"><code>--extra=<i>N</i>,'<i>STRING</i>'</code></font> option causes the <font color="#663300"><code><i>STRING</i></code></font> to be returned to the XPL program upon the first invocation of <font color="#663300"><code>INPUT(<i>N</i>)</code></font>; subsequent invocations of <font color="#663300"><code>INPUT(<i>N</i>)</code></font> get data from the file attached to input <font color="#663300"><code><i>N</i></code></font>.&nbsp; So for example, if you wanted to use the control toggle <font color="#663300"><code>$E</code></font>, but didn't want to modify your XPL source code to add it into a comment, you could use the command-line option <font color="#663300"><code>--extra=0,'/* $E */'</code></font>.<br>

<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; </font><font size="-1">Again, to be clear, <b>XCOM-I</b>
 itself has no cognizance whatever of control toggles.&nbsp; Control 
toggles, if available, are provided to and used by legacy versions of <b>XCOMx</b> which <b>XCOM-I</b> may have compiled for you!</font>
</blockquote>





If you're writing <i>new</i> XPL or XPL/I programs, of course, then you still may want your own custom command-line options for it.&nbsp; <a moz-do-not-send="true" href="#builtin">The built-in library function</a> <font color="#663300"><code>PARM_FIELD</code></font> returns a string containing the value of the <font color="#663300"><code>--parm</code></font> command-line switch as-is.  You can therefore just write XPL code to parse <font color="#663300"><code>PARM_FIELD</code></font>. <br>
<blockquote>
</blockquote>

<font color="#663300"><code></code></font>
<ul>

</ul>

<h1><a name="builtin"></a>Built-In Runtime-Library Functions</h1>

<p>Standard XPL has a variety of so-called "built-ins", comprising 
runtime-library functions callable from XPL code.  Some of these 
bullt-ins can appear on either the right-hand or left-hand side of 
assignments, and some have to be <font color="#663300"><code>CALL</code></font>'d like user-defined <font color="#663300"><code>PROCEDURE</code></font>s.
 XPL/I has roughly the same built-ins, plus-or-minus a few, mostly (but 
not entirely) defined to have the same functionality.  The compiler 
recognizes these built-ins, and there is no need for them to be declared
 in any way prior to use.  Since these built-ins were mostly written 
originally in IBM System/360 basic assembly language, the runtime 
library supplied with <b>XCOM-I</b> has been entirely written in C, without any
 reference to the original runtime-library source code.<br></p>
<p>The list below is from <i>A Compiler Generator</i> (p. 140-142), with some alterations 
due to XPL/I, and some hopefully-helpful notes from me.  The parameter 
descriptions in the list below identify the datatypes of parameters by 
the following convention:<br></p>
<ul>
  <li><font color="#663300"><code>FIXED</code></font> — <code><font color="#663300">NE</font></code><font color="#663300"><code><sub>x</sub></code></font></li>
  <li><font color="#663300"><code>CHARACTER</code></font> descriptor — <font color="#663300"><code></code><code>DE<sub>x</sub></code></font></li>
  <li>Symbolic name of a variable, with or without a subscript — <font color="#663300"><code></code><code>V</code></font></li></ul>
<p>I suppose I should make it clear that the <b>XCOM-I</b> environment 
is not precisely like that envisaged in the original XPL language as 
confined to an IBM 360 runtime environment, and as such, built-in 
functions don't work exactly the same way either.  What's described here
 is how <i>the </i><i><b>XCOM-I</b></i><i> runtime library's functions </i>corresponding to the original built-in functions work.<br></p>
<ul>

</ul>

<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Built-Ins</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Library Function<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ABS(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the absolute value of <font color="#663300"><code>NE</code></font>.&nbsp;
 (Note: "80000000", the maximum negative number, has no representable 
absolute value and returns "7FFFFFFF", the maximum positive number.)<br>
      </td>
      <td valign="middle">(XPL/I only.)<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ADDR(V)</code></font></td>
      <td valign="middle">A function with numeric value which is the (at most) 24-bit absolute address of the variable (subscripted or not) <font color="#663300"><code>V</code></font>.&nbsp; Mostly used in conjunction with <font color="#663300"><code>COREWORD</code></font> or <font color="#663300"><code>COREBYTE</code></font>.<br>
      </td>
      <td valign="middle">If the variable has a subscript, then the 
returned address is that of a specific array element, rather than of the
 beginning of the array.&nbsp; For a <font color="#663300"><code>CHARACTER</code></font> or long <code><font color="#663300">BIT</font></code> string (i.e., for <font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> datatypes), the returned address is that of the <i>descriptor</i>
 for the variable, and if you want to find the actual data, you then 
must first fetch the value of the descriptor and then massage it 
further.&nbsp; For XPL/I's <font color="#663300"><code>BASED</code></font> variables (see IR-182-1 p. 13-3), using the unsubscribed name of the variable for <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> will return the address in memory where the pointer to the <font color="#663300"><code>BASED</code></font> variable's data is stored; whereas adding the subscript <font color="#663300"><code>(0)</code></font> to <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> returns the address of the variable's data itself.<br>
<br>
There are two exceptional cases, due to the fact that unlike the original XPL compilers, program code in <b>XCOM-I</b>
 exists in a separate memory space outside of the simulated XPL memory 
in which variable exist.&nbsp; Therefore, attempts to use <font color="#663300"><code>ADDR(V)</code></font>
 to find addresses in code space, such as addresses of XPL built-ins or 
of program labels, have to be treated very differently than addresses of
 variables, if sensible results are to be obtained.<br>
<br>
Insofar as addresses of runtime-library functions are concerned, the only case I'm aware of is <font color="#663300"><code>ADDR(DESCRIPTOR)</code></font>.&nbsp; In this case, <font color="#663300"><code>ADDR</code></font> returns the address immediately following <a moz-do-not-send="true" href="#common"><font color="#663300"><code>COMMON</code></font> memory</a>.&nbsp; The reason for this <i>ad hoc</i> behavior is that the XPL/I memory-management system (SPACELIB) uses the location of the built-in variable <font color="#663300"><code>DESCRIPTOR</code></font> (see below) to determine the cutoff between <font color="#663300"><code>COMMON</code></font> (in low memory) and non-<font color="#663300"><code>COMMON</code></font>
 (in higher memory).&nbsp; But I realized this fact too late in the 
development process, after I had made decisions about implementation and
 memory layout that were incompatible with the interpretation of <font color="#663300"><code>DESCRIPTOR</code></font> as a normal variable with the desired properties.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp;&nbsp; It isn't <i>terribly</i>
 difficult to undo the incompatible design decisions I mentioned, and 
sometime in the future I may do so.&nbsp; Technically, I think it's 
mainly a matter of swapping <a moz-do-not-send="true" href="#MemoryModel">memory regions 2 and 3</a>.&nbsp; Again technically, it is necessary for <a moz-do-not-send="true" href="#basedManagement">the dope vectors of all BASED variables</a> to reside in the lowest 64K of memory, so it would have the effect of reducing the possible number of non-<font color="#663300"><code>COMMON BASED</code></font> variables; fortunately, if existing XPL/I code is any guide, that's a pretty-negligible problem.<br>
</font></blockquote>Insofar as program labels are concerned, as far as I
 know, there's no mechanism in XPL itself for using the memory address 
of a program label.&nbsp; Consequently, the only reason for finding the 
address of an XPL program label is that assembly language (in a <font color="#663300"><code>CALL INLINE</code></font>) wants either to branch to that address, or else to somehow use the data in another <font color="#663300"><code>CALL INLINE</code></font> at that address.&nbsp; But this notion is based on various assumptions that are false in <b>XCOM-I</b>. &nbsp; Nevertheless, in spite of that fact, we still need some uniform method of handling such "addresses" that allows <font color="#663300"><code>ADDR</code></font> and <font color="#663300"><code>CALL INLINE</code></font> to interact smoothly.&nbsp; <br>
<br>
<b>XCOM-I</b> handles addresses of XPL labels as follows:&nbsp; The labels in any <font color="#663300"><code>PROCEDURE</code></font> are assigned a predictable sequence of unique <i>negative</i>
 addresses.&nbsp; Thus the first label encountered has the address -1, 
the second has address -2, and so on.&nbsp; The addresses are local to 
the <font color="#663300"><code>PROCEDURE</code></font>, and restart at -1 in each <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; <font color="#663300"><code>ADDR</code></font> returns these negative addresses.&nbsp; C implementations of the branch instructions in <font color="#663300"><code>CALL INLINE</code></font> statements can exploit that by having a jump table of a form similar to:<br>
<blockquote>
  <pre>switch (address) {<br>  case -1: goto LABEL1;<br>  case -2: goto LABEL2;<br>  ...<br>}<br></pre>
</blockquote>
Admittedly, this is not a terribly-efficient solution, but C has no 
practical computed-goto other than this, as far as I'm aware. <br>
<blockquote><font size="-1">
  </font></blockquote>

</td></tr><tr><td valign="middle" align="center"><font color="#663300"><code>BYTE(DE,NE)<br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> 8 bits of the string described <font color="#663300"><code>DE</code></font>.<br>
      </td>
      <td valign="middle">By "string", <i>A Compiler Generator</i> means either <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT</code></font> data.&nbsp; As far as <font color="#663300"><code>BIT</code></font> data is concerned, this function works for any data-width; i.e., for <font color="#663300"><code>BIT(1)</code></font> through <font color="#663300"><code>BIT(2048)</code></font>, and not just for "long" <font color="#663300"><code>BIT</code></font> string.&nbsp; However, there's some difference between how <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT</code></font> data is treated.&nbsp; <font color="#663300"><code>BIT</code></font> data is retrieved from memory as-is, whereas <font color="#663300"><code>CHARACTER</code></font>
 data is transparently translated between EBCDIC encoding (in memory) vs
 ASCII encoding (for manipulation) by the software.&nbsp; The latter 
behavior is specific to <b>XCOM-I</b>, and wouldn't have been needed by the original <b>XCOM</b>, since back then, all <font color="#663300"><code>CHARACTER</code></font>
 data was encoded in EBCDIC all the time, whether or not it resided in 
"memory".&nbsp; Moreover, if you try to do so, it is possible to fool <b>XCOM-I</b>'s <font color="#663300"><code>BYTE</code></font>
 function into thinking an area of memory is a different datatype than 
it really is, thus defeating the translation mechanism ... so please 
don't try to do that.<br>
        <br>
Note that <font color="#663300"><code>BYTE</code></font> can appear 
either in an expression (such as on the right-hand side of an assignment), in which case it returns a value as just 
described, or else on the left-hand side of an assignment, in which case
 it modifies the value stored in memory.&nbsp; <i>A Compiler Generator</i> recommends not using <font color="#663300"><code>BYTE</code></font> on the left-hand side of an assigment, due to the possibility of unintended consequences.<br>
        <br>
The documentation does not explain what's supposed to happen if <font color="#663300"><code>NE</code><code>&lt;0</code></font> or <font color="#663300"><code>NE</code><code>&gt;=len(</code><code>DE</code><code>)</code></font>.&nbsp; Alas, that's not a theoretical question, because such uses of <font color="#663300"><code>BYTE</code></font> really appear in legacy XPL code.&nbsp; Given the sloppy subscripting accepted by XPL, my guess is that <font color="#663300"><code>BYTE</code></font> just grabs whatever happens to reside wherever <font color="#663300"><code>NE</code></font>
 leads it.&nbsp; Unlike the usual sloppy subscripting in XPL code, this 
would almost certainly be a mistake by the programmer, because the 
location of string data in memory is dynamically assigned and liable to 
change during the course of execution, so the programmer can't really 
know reliable what lies beyond the bounds of a string.&nbsp; Thus my 
guess is that when <font color="#663300"><code>NE</code></font> is out 
of bounds for the string size, it's probably a mistake on the part of 
the program that was never detected because it never produced any error 
messages.<br>
        <blockquote><font size="-1"><b>Aside:</b> For example, it happens in the <font color="#663300"><code>SCAN</code></font> procedure of <b>XCOM</b>, in the vicinity of line 835 at this writing,<br>
          </font>
          <blockquote>
            <pre><font size="-1" color="#663300">CP = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>DO WHILE BYTE(TEXT, CP) = BYTE(' ') &amp; CP &lt;= TEXT_LIMIT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>   CP = CP + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>END;&nbsp;&nbsp;</font><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></pre>
          </blockquote>
          <font size="-1">where <font color="#663300"><code>TEXT</code></font> happens to be a string with <font color="#663300"><code>LEN(TEXT)=1</code></font> containing a single blank space, and <font color="#663300"><code>TEXT_LIMIT=0</code></font>.&nbsp; Here, <font color="#663300"><code>BYTE(TEXT,CP)</code></font> is out of bounds on the very first iteration of the loop.&nbsp; In C, if the operands of the <font color="#663300"><code>&amp;</code></font> operator were reversed, then <font color="#663300"><code>BYTE(TEXT,CP)</code></font> would never be executed, and the problem would be avoided.&nbsp; But <i>if</i>
 that kind of optimization of conditionals is a feature of XPL, it's not
 a feature that's mentioned anywhere to my knowledge, and <b>XCOM-I</b> does not attempt it.</font><br>
        </blockquote>
Whether or not that's a true in interpretation, in <b>XCOM-I</b> the <font color="#663300"><code>BYTE</code></font> function returns a value of 0 (corresponding to an EBCDIC <font color="#663300"><code>NUL</code></font>) if <font color="#663300"><code>NE</code></font> is out of bounds, or else silently does nothing at all if on the left-hand side of an assignment.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE)<br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>BYTE(DE,0)</code></font></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>CLOCK_TRAP<br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.</td>
      <td valign="middle">And it's not supported in <b>XCOM-I</b> either.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COMPACTIFY<br>
          </code></font></td>
      <td valign="middle">A procedure called automatically to repack the free storage 
area for string data when it is exhausted. Calls can be triggered by <font color="#663300"><code>||</code></font>, <font color="#663300"><code>INPUT</code></font>, number-to-string conversions, or an explicit call:<br>
        <blockquote><font color="#663300"><code>CALL COMPACTIFY;<br>
            </code></font></blockquote>
        <font color="#663300"><code></code></font>The variables <font color="#663300"><code>FREEBASE</code></font>, <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>FREEPOINT</code></font>, <font color="#663300"><code>DESCRIPTOR</code></font>, and <font color="#663300"><code>NDESCRIPT</code></font> are used by <font color="#663300"><code>COMPACTIFY</code></font>.<br>
        <font color="#663300"><code></code></font></td>
      <td valign="middle">The "free-storage area" is where the data for <font color="#663300"><code>CHARACTER</code></font> and long <font color="#663300"><code>BIT</code></font>-string
 variables is stored.&nbsp; As a program which involves string variables
 executes, the strings tend to change size and move around in the 
free-storage area, thus causing unused "holes" in memory to 
develop.&nbsp; <font color="#663300"><code>COMPACTIFY</code></font> repacks the area so as to remove the holes.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; While long <font color="#663300"><code>BIT</code></font>-strings (&gt;32 bits) are technically similar to <font color="#663300"><code>CHARACTER</code></font>
 strings, they differ in the fact that the amount of storage they 
require is determined at compile-time and does not change after 
that.&nbsp; The original </font><font size="-1"><i>A Compiler Generator</i> and Intermetrics compilers therefore 
stored them outside of the free-storage area — or at least in the very 
lowest addresses of the free-string area </font><font size="-1"><font size="-1">—</font>
 in order to save any execution time that would otherwise have been 
wasted during allocation of memory or garbage allocation.&nbsp; <b>XCOM-I</b>
 is not so picky, since even the most feeble modern computer will be 
approximately 14.3926 gazillion times faster than an IBM 360 was.&nbsp; <b>XCOM-I</b>
 thus saves (me) a little effort by grouping the long bit strings with 
the character strings in memory, at an immeasurably-small cost in 
execution time.</font><br>
</blockquote>
XPL/I's <font color="#663300"><code>BASED</code></font> variables are stored in a separate memory region and do not participate in garbage collection by <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; <a moz-do-not-send="true" href="#MemoryModel">See the earlier discussion of this</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREBYTE(NE)<br>
          </code></font></td>
      <td valign="middle">A byte array identical to the IBM System/360 
memory.&nbsp; The subscript is the absolute byte address of the byte 
selected.&nbsp; <font color="#663300"><code>COREBYTE</code></font> may be used on either side of the replacement operator (i.e., <font color="#663300"><code>=</code></font>).<br>
      </td>
      <td valign="middle">The function returns a <font color="#663300"><code>FIXED</code></font>
 value, if used in an expression, but only the least-significant 8 bits 
contain the value.&nbsp; Similarly, if used on the left-hand side of an 
assignment, it receives a <font color="#663300"><code>FIXED</code></font> value from the right-hand side, but only stores the least-significant 8 bits at the specified memory address.&nbsp; The <b>XCOM-I</b> version of this function performs no EBCDIC translation as <font color="#663300"><code>BYTE</code></font> (see above) does, so it does not expect the data in memory to be <font color="#663300"><code>CHARACTER</code></font> data.&nbsp; Whether this will turn out to be an issue remains to be seen.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREWORD(NE)<br>
          </code></font></td>
      <td valign="middle">Like <font color="#663300"><code>COREBYTE</code></font>, except the subscript corresponds to the word address in memory.&nbsp; Thus an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code></font>.<br>
      </td>
      <td valign="middle">Since XPL has only a 24-bit address space, only the least-significant 3 bytes of the "4-byte word address" <font color="#663300"><code>NE</code></font> are used.&nbsp; According to IR-182-1 (p. 13-3), this function <i>differs</i> in XPL/I as follows:<br>
        <blockquote><font size="-1">According to "<i>A COMPILER GENERATOR</i>", <font color="#663300"><code>NE</code></font> is a word index, or word-aligned address. However, in the Intermetrics version, <font color="#663300"><code>NE</code></font> must be a byte address, and the user must himself guarantee that the lower-most two bits are 0's (full word aligned).</font><br>
        </blockquote>
I <i>think</i> that what's being implied by this cryptic comment is that <i>A Compiler Generator</i>'s <font color="#663300"><code>COREWORD</code></font> in XPL worked like this:<br>
        <ul>
          <li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(2) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li>and so on.</li>
        </ul>
        <p>whereas Intermetrics's <font color="#663300"><code>COREWORD</code></font> in XPL/I worked like this:<br></p>
        <ul>
<li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(2)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(3)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(4)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(5)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(6)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(7)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(8) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(9)</code></font> is illegal.</li>
<li>and so on.</li>
        </ul>
        <p>To my way of thinking, <i>A Compiler Generator</i>'s description doesn't say 
what IR-182-1 says it says, and unfortunately, <i>A Compiler Generator</i>'s clarification 
that "an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code><font color="#000000">", does not in fact clarify it very much either.<br></font></font></p>
        <p><font color="#663300"><font color="#000000"><b>XCOM-I</b> 
conforms to the latter (Intermetrics) usage, with the exception that 
addresses like 1, 2, 3, 5, 6, 7, 9, ... are perfectly fine:  </font></font><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(1)</code></font> through <font color="#663300"><code>COREBYTE(4)</code></font>, and so on.  Which conforms just fine to the description in <i>A Compiler Generator</i> as well, if not necessarily to <i>A Compiler Generator</i>'s actual usage.<br></p>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In point of fact, </font><font size="-1"><font color="#663300"><code>COREWORD</code></font>
 is not used in any software written in standard XPL that's available to
 me, so I cannot determine empirically which of these choices (if 
either) is correct.&nbsp; If it is somehow discovered later that 
<b>XCOM3</b> really does need to behave in the manner Intermetrics claimed that it did, then <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font>
 command-line switch will be extended to select between the two 
behaviors.&nbsp; But I don't intend to waste any effort implementing 
that until/unless I have enough evidence to justify it.&nbsp; For now, 
it's a moot point.</font><br>
        </blockquote>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE<br>
          </code></font></td>
      <td valign="middle">A function with the numeric value of the date, coded as<br>
        <blockquote>(day of year) + 1000 * (year - 1900)<br>
        </blockquote>
      </td>
      <td valign="middle"><i>A Compiler Generator</i> doesn't inform us of anything so mundane as the time zone to which the <font color="#663300"><code>DATE</code></font> and <font color="#663300"><code>TIME</code></font> built-ins relate, at least not in the text of the book.&nbsp; <b><br>
</b><br>
I have been told that <i>A Compiler Generator</i> would have use local time here.&nbsp; The
 submonitor function supplying this value would appear to be called <font color="#663300"><code>GETIME</code></font>, and identical versions of <font color="#663300"><code>GETIME</code></font> are used by the <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>
 submonitors, so if <i>A Compiler Generator</i> used local time, then all other legacy 
compilers available at present did so as well.&nbsp; Exactly how <font color="#663300"><code>GETIME</code></font> works isn't clear to me.&nbsp; But if what I understand from looking at the <i>IBM System/360 Operating System MFT Supervisor</i>
 manual is correct, the IBM 360 seems to have had no conception of UTC 
at all, or for that matter, of local timezones either; it simply knew 
whatever time and date the operator&nbsp; manually input into the system
 at each power-up, and what the operator was supposed to input was the <i>local</i> time and date.<br>
<br>
Consequently, the <font color="#663300"><code>DATE</code></font> and <font color="#663300"><code>TIME</code></font> built-ins return the local date and time, according to whatever locale your computer is set for.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>DATE</code></font> during compilation of the program being run.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>DATE</code></font> above.
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DESCRIPTOR(NE)<br>
          </code></font></td>
      <td valign="middle">The description of the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> string as a numeric value.<br>
      </td>
      <td valign="middle">This cryptic description is 
referring to the fact that in the way memory is allocated for the 
variables declared by <b>XCOM</b>, the 32-bit string descriptors for all <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT(n)</code></font> (<font color="#663300"><code>n</code></font>&gt;32) variables appear consecutively in memory.&nbsp; By symbolically labeling the very first of those descriptors as <font color="#663300"><code>DESCRIPTOR</code></font>, and treating <font color="#663300"><code>DESCRIPTOR</code></font> as of the <font color="#663300"><code>FIXED</code></font> datatype, <font color="#663300"><code>DESCRIPTOR</code></font>
 becomes an easily-accessible array of all the string descriptors.&nbsp;
 This is useful, for example, for memory-management procedures like <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; The number of elements of the array is given by the built-in <font color="#663300"><code>NDESCRIPT</code></font> (see below).<br>
</td></tr><tr><td valign="middle" align="center"><font color="#663300"><code>EXIT</code><code><br>
          </code></font></td>
      <td valign="middle">A procedure<br>
        <blockquote><font color="#663300"><code>CALL EXIT;</code></font><br>
        </blockquote>
which causes an abnormal exit form XPL execution. <br>
      </td>
      <td valign="middle">In fact, <b>XCOM-I</b> models this a C-language <font color="#663300"><code>exit(1)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FILE(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">An array-valued pseudovariable for manipulation of random-access bulk storage.&nbsp; Examples of its use are<br>
        <blockquote><font color="#663300"><code>DECLARE BUFF(3600) BIT(8);</code><code><br>
            </code><code>BUFF = FILE(I, J);</code><code><br>
            </code><code>FILE(I-1, J) = BUFF;</code></font><br>
        </blockquote>
One record is transferred into or out of the buffer array by the 
assignments shown above.&nbsp; FILE cannot appear on both sides of the 
same assignment.&nbsp; <br>
      </td>
      <td valign="middle"><a name="file"></a>I've actually truncated <i>A Compiler Generator</i>'s 
description of <font color="#663300"><code>FILE</code></font>, because it is so long and so much of it is specific to IBM 
System/360, while being quite irrelevant to us.&nbsp; The key facts are 
these:<br>
        <ul>
          <li>"Random access files" may be attached to the running program.&nbsp; <br></li>
          <li>Once attached, they are identified by a "device number" that ranges from 1 to 9.&nbsp; <br></li>
          <li>Each attached random-access file may be for input-only, output-only, or both.&nbsp; <br></li>
          <li>Each of the attached files consists of records of a fixed size.</li>
          <li>Different files may have different record sizes.</li>
          <li>These random-access files, and the associated <font color="#663300"><code>FILE</code></font> operations, are <i>completely distinct</i> from the "sequential files" (numbered 0 through 9) accessed via the <font color="#663300"><code>INPUT</code></font> and <font color="#663300"><code>OUTPUT</code></font> functions (see below).</li>
<li>Record sizes <i>typically</i> do not change during program execution.  (But see the continued comments below.)</li>
        </ul>
By default, no random-access files are attached to programs.&nbsp; 
Originally (back in 1970), they were attached at runtime via Job Control
 Language (JCL) <font color="#663300"><code>DD</code></font> 
cards.&nbsp; But with programs compiled via XCOM-I, files are attached 
at program startup by using the program's command-line switches.&nbsp; 
The relevant switch is <font color="#663300"><code>--raf</code></font>, and multiple instances can be used on the same command line.<br>
        <blockquote><font color="#663300"><code>--raf=<i>I,R,N,F</i></code></font><br>
        </blockquote>
The parameters of the <font color="#663300"><code>--raf</code></font> switch are:<br>
        <ul>
          <li><font color="#663300"><code>I</code></font> is either a 
literal I (for "input"), a literal O (for "output"), or a literal B (for
 "both input and output").  Note that for O, an empty file will always 
be created by the program; for B, if there's an existing file of the 
specified name, then it will be used, but an empty file will be created 
otherwise.</li>
          <li><font color="#663300"><code>R</code></font> is the record 
size associated with the file.  3600 and 7200 are typical values, but 
not the only ones in use.  They must match the expectations of the 
program's XPL code for using the data.</li>
          <li><font color="#663300"><code>N</code></font> is the device number, from 1 through 9, to which the file should be attached.</li>
          <li><font color="#663300"><code>F</code></font> is the relative or absolute path to the file.</li>
        </ul>
        
<p>In spite of what I said above, the XPL/I documentation (IR-182-1, p. 
13-5) does describe one way to change the record size of a random-access
 file once the program has begun operation, and that is via a call to <font color="#663300"><code>MONITOR(4,R,N)</code></font> (see below), where <font color="#663300"><code>R</code></font> and <font color="#663300"><code>N</code></font> have the same meanings as for <font color="#663300"><code>--raf</code></font>.  It also tells us that such a call must precede the first use of <font color="#663300"><code>FILE(N)</code></font>.  <b>XCOM-I</b>
 relaxes this restriction, though it seems that the original restriction
 should be treated as very good advice to follow.  Note, by the way, 
that the call to <font color="#663300"><code>MONITOR(4,R,N)</code></font>
 has no way to distinguish between input files and output files, so its 
record-size manipulation is applied simultaneously to input file <font color="#663300"><code>N</code></font> and output file <font color="#663300"><code>N</code></font>, if they differ.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEBASE</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the top of constant strings and thus the bottom of the repackable area.<br>
      </td>
      <td valign="middle">In <b>XCOM-I</b>, this is implemented as a function rather than a variable, and is not directly modifiable by user code.&nbsp; <br>
        <br>
What the description from the original documentation is trying to say is that most kinds of variables — such as <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(1)</code></font> types, or descriptors for <font color="#663300"><code>CHARACTER</code></font> or long <font color="#663300"><code>BIT</code></font>-string types, or arrays thereof, or pointers to <font color="#663300"><code>BASED</code></font>
 variables — are stored in memory at low addresses determined at compile
 time, and remain unchanged in address thereafter.&nbsp; In contrast, 
data for <font color="#663300"><code>CHARACTER</code></font> variables can grow or shrink or move at runtime.&nbsp; <font color="#663300"><code>FREEBASE </code></font>is the boundary between those regions of memory.<br>
        <br>
In <b>XCOM-I</b>, data allocated at runtime via the <font color="#663300"><code>MONITOR(6,...)</code></font> or <font color="#663300"><code>MONITOR(19,...)</code></font> function (see below), sometimes for storing data of for <font color="#663300"><code>BASED</code></font> variables,  also appears above the <font color="#663300"><code>FREEBASE</code></font> boundary.<font color="#663300"><code></code></font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREELIMIT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the last usable byte in the string-data area. <br>
      </td>
      <td valign="middle">I believe that the description lies, and that <font color="#663300"><code>FREELIMIT</code></font> is the first unusable byte beyond the string-data area, rather than the last usable byte in it.<br>
<br>
In XPL, all memory beyond <font color="#663300"><code>FREELIMIT</code></font> is unused by the program.&nbsp; In XPL/I, the data for <font color="#663300"><code>BASED</code></font> variables is stored at <font color="#663300"><code>FREELIMIT</code></font> and above.&nbsp; However, the memory-management technique for is to push <font color="#663300"><code>FREELIMIT</code></font> <i>downward</i> in order to make room for <font color="#663300"><code>BASED</code></font> variables.&nbsp; So for either XPL or XPL/I, the <i>initial</i> value of <font color="#663300"><code>FREELIMIT</code></font> is the highest memory location used by the program.&nbsp; XCOM-I sets the initial value of <font color="#663300"><code>FREELIMIT</code></font> at <font color="#663300"><code>"FFFC00"</code></font> (i.e., 1024 bytes below the top of physical memory), in order to leave a small amount of space for <font color="#663300"><code>COMPACTIFY</code></font> to use as scratch memory.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEPOINT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the next free byte in the string-data area.&nbsp; When <font color="#663300"><code>FREEPOINT</code></font> passes <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>COMPACTIFY</code></font> must be called.<br>
      </td>
      <td valign="middle">In other words, at any given time, only the memory region between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available for dynamically-allocating new free memory for <font color="#663300"><code>BASED</code></font> variables or <font color="#663300"><code>CHARACTER</code></font> variables.&nbsp; as the program continues to execute, dynamic memory allocation and subsequent memory-freeing may cause <font color="#663300"><code>FREEPOINT</code></font> to steadily creep upward, and the area from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> to become increasingly fully of unusable holes.&nbsp; Eventually, <font color="#663300"><code>COMPACTIFY</code></font> will be <i>automatically</i> called, repacking the data to eliminate the holes, and moving <font color="#663300"><code>FREEPOINT</code></font> downward in memory once again.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INLINE(NE<sub>1</sub>,...)<br>
          </code></font></td>
      <td valign="middle">Inserts arbitrary IBM System/360 machine code directly into the instruction stream.<br>
      </td>
      <td valign="middle">The applicability of the original 
functionality has change drastically in the 55 years (as of this 
writing) since <i>A Compiler Generator</i> was written.&nbsp; <b>XCOM-I</b>
 provides three different mechanisms for supporting direct insertion of 
inline non-XPL code, none of which are identical to those in <i>A Compiler Generator</i>.&nbsp; Thankfully, no available legacy <i>standard</i> XPL program I've encountered contains any <font color="#663300"><code>CALL INLINE</code></font> statements, so the difficulties presented by them are limited to XPL/I code such as <b>HAL/S-FC</b>.<br>
<br>
<b>Support mechanism 1:&nbsp; insertion of C code</b><br>
        <br>
        You can use <br>
        <blockquote><font color="#663300"><code>CALL INLINE('<i>C-language source code</i>');</code></font><br>
        </blockquote>
to insert an arbitrary 
string of C-language source code directly into the instruction stream.&nbsp; If
 the string contains newline characters (<font color="#663300"><code>'\n'</code></font>), then a single <font color="#663300"><code>INLINE</code></font>
 can insert multiple lines of C code.&nbsp; But recall that an XPL 
string can be no longer than 256 characters, so the inserted C code can 
be no longer than 256 characters in any one <font color="#663300"><code>CALL INLINE</code></font> statement.<br>
        <br>
<b>Support mechanism 2:&nbsp; insertion of IBM 360 machine code</b><br>
<br>
<b>XCOM-I</b> will automatically translate IBM 360 machine code to 
C.&nbsp; Full-blown IBM 360 emulation is not provided, but support is 
available for those IBM 360 instructions used in XPL code I have 
personally encountered, which includes the entire source-code base of <b>HAL/S-FC</b>.&nbsp; Instructions that are not (yet) supported cause compilation to abort.<br>
<br>
This feature is not normally enabled.&nbsp; You must use the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--auto-inline</code></font> to enable it.<br>
<br>
<b>Support mechanism 3:&nbsp; other</b><br>
<br>
If <font color="#663300"><code>--auto-inline</code></font> is not 
enabled (see support mechanism 2 above), any CALL INLINE statements not 
caught by support mechanism 1 are commented out by default, but 
"patched" with C code if a "patch file" is available.&nbsp; &nbsp; <a moz-do-not-send="true" href="#hooks">This important but far from automatic mechanism is the topic of a later section</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the next record on input file <font color="#663300"><code>NE</code></font>.<br>
      </td>
      <td valign="middle">I've truncated <i>A Compiler Generator</i>'s rather roundabout description, because I don't find it very informative as-is to more-modern readers.<br>
        <br>
What <i>A Compiler Generator</i> is trying to say is that any given program can have several files attached to it for so-called <i>sequential</i>
 input.&nbsp; You can think of these files as consisting of lines of 
text, and you can read them, one text-line at a time, by using the <font color="#663300"><code>INPUT</code></font> built-in function.&nbsp; For the original <i>A Compiler Generator</i> <b>XCOM</b> (or the Intermetrics version of <b>XCOM</b>), the text in the sequential files would have been encoded in EBCDIC, but for use with <b>XCOM-I</b> they are encoded in ASCII.<br>
        <br>
Because XPL comes from the era and computing environment it did, it 
expects input to be supplied on computer punch cards.&nbsp; As such, it 
expects lines of input to actually be 80 columns wide, even if they need
 to be padded by spaces to do so.&nbsp; Not all XPL programs have 
problems with lines of other lengths have a problem with lines of a 
different length, but some do.&nbsp; Notably, the original <b>XCOM</b> is one of the programs that behaves incorrectly unless it gets its way.&nbsp; Because of that, <b>XCOM-I</b>'s built-in <font color="#663300"><code>INPUT</code></font> function transparently truncates lines to 80 columns or pads them 80 columns as necessary.<br>
        <br>
        <br>
There are up to 9 input files attached to the program, numbered, 0 through 9 — yes, I <i>know</i> that's 10 files, but just keep reading — and you access them via those "device numbers".&nbsp; For example,<br>
        <blockquote><font color="#663300"><code>DECLARE CHARACTER C;</code><code><br>
            </code><code>C = INPUT(5);</code></font><br>
        </blockquote>
reads a single line from sequential file number 5 into the variable <font color="#663300"><code>C</code></font>.<br>
        <blockquote><font size="-1"><b>Important:</b> These "sequential files" and the <font color="#663300"><code>INPUT</code></font> mechanism are completely separate from the "random-access files" described in <font color="#663300"><code>FILE</code></font>'s notes earlier!</font><br>
        </blockquote>
By default, there is a single sequential file attached to the program, though it is attached to <i>both</i> device number 0 and device number 1.&nbsp; The default attached file is <font color="#663300"><code>stdin</code></font>, and thus any text piped into the program via a redirector (<font color="#663300"><code>&lt;</code></font>) on the program's command line will be available on both <font color="#663300"><code>INPUT(0)</code></font> and <font color="#663300"><code>INPUT(1)</code></font>.<br>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering, I don't think that the reason two separate devices are associated with <font color="#663300"><code>stdin</code></font> is very deep or interesting.&nbsp; I imagine it's just kind of symmetric to the fact that <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below) are both attached by default to <font color="#663300"><code>stdout</code></font>.&nbsp; In situations like this I'm tempted to quote Emerson</font> <font size="-1">— "a foolish consistency is the hobgoblin of little minds" — but I suspect the decision was pragmatic rather than foolish.</font><br>
        </blockquote>
There's no explanation or obvious provision in the documentation for what happens when an end-of-file is reached, and <b>XCOM-I</b>
 makes no particular provision for it either.&nbsp; I suppose it must 
depend on the particular program.&nbsp; For example, some XPL programs 
assume that a blank line terminates a file.&nbsp; Other programs may 
look for special patterns, such as the string "EOF".&nbsp; <b>XCOM-I</b> returns an empty string for reads past the end of the file.<br>
        <br>
Additional input files can be attached via the program's command-line switch <font color="#663300"><code>--ddi</code></font>:<br>
        <blockquote><font color="#663300"><code>--ddi=<i>N,F</i></code></font><br>
        </blockquote>
Here, <font color="#663300"><code><i>F</i></code></font> is the pathname to the file, and <font color="#663300"><i><code>N</code></i></font>
 is the device number to which it should be attached.&nbsp; By the way, 
if you want to debug your program once it has been translated by <b>XCOM-I</b>
 to C and then the C has been compiled to an exectuable, I've sometimes 
found piping input into the program via a command-line redirector (<font color="#663300"><code>&lt;</code></font>)
 to be somewhat problematic.&nbsp; It's handy in those situations to 
override the default attachment of stdin to device 0 by using <font color="#663300"><code>--ddi=0,<i>F</i></code></font> instead of piping.&nbsp; <br>
        <br>
There is no way to change the attachments once the program is running, although there are <font color="#663300"><code>MONITOR</code></font> calls (see below) which can close attached files at runtime.<br>
        <br>
In XPL/I, there's an additional alternative, in which <i>Partioned Data Set</i> (PDS) files can be attached for use by <font color="#663300"><code>INPUT</code></font>
 instead of sequential files. A PDS is partitioned into sections, each 
with its own 8-character identifying name (right-padded with blanks if 
necessary).&nbsp; An attempted read past the end of a partition returns 
an empty string.<br>
        <br>
Only one partition of the PDS is available via <font color="#663300"><code>INPUT</code></font> at any given time, but <br>
        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(2, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
(see below) can be used at any time to switch device <font color="#663300"><code><i>N</i></code></font> to the partition whose name is contained in the string called <font color="#663300"><code><i>NAME</i></code></font>.&nbsp; The value returned, <font color="#663300"><code><i>F</i></code></font>, is 0 if the switch was successful, or 1 if there was no such partition.<br>
        <br>
A PDS is thus similar to a <i>folder</i> of sequential files, with the partition names corresponding to filenames within the folder.&nbsp; <br>
        <br>
By default, no there is no PDS attached to programs.&nbsp; However, a 
PDS can be attached for input via the program's command-line switch <font color="#663300"><code>--pdsi</code></font>:<br>
        <blockquote><font color="#663300"><code>--pdsi=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
Because of PDS similarity to folders, that's how they're implemented in <b>XCOM-I</b>. So <font color="#663300"><code><i>F</i></code></font> should be the pathname of a folder, and the partitions should be ASCII text files within the folder.&nbsp; <font color="#663300"><code><i>N</i></code></font>,
 of course, is the device number on which the attachment is to be 
made.&nbsp; However, no specific partition is selected for reading until
 the necessary <font color="#663300"><code>MONITOR(2, <i>N</i>, <i>NAME</i>)</code></font> call has been made.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT</code><code><br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>INPUT(0)</code></font><br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INTERRUPT_TRAP</code><code><br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.<br>
      </td>
      <td valign="middle">Not supported in <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LENGTH(DE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value equal to the number of characters in the string denoted by the parameter.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINE_COUNT</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the number of lines which have been printed on the SYSPRINT file since the last page eject.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; "SYSPRINT" refers to <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below).<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINK</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure performs the functions necessary to exit the current program phase and pass control to the next phase on the <font color="#663300"><code>PROGRAM DD</code></font> sequence, preserving <font color="#663300"><code>COMMON</code></font> data and any other dynamically allocated space which has not been deallocated.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; This refers to the notion 
that a sequence of XPL/I programs is being run via Job Control Language 
(JCL), with each program passing data to the next program in 
sequence.&nbsp; However, this <font color="#663300"><code>LINK</code></font> built-in is specific to the original computing environment, and performs no function in <b>XCOM-I</b>, which has a different mechanism sharing data between program passes.&nbsp; <a moz-do-not-send="true" href="#common">Refer to the extensive discussion concerning <font color="#663300"><code>COMMON</code></font> memory</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR(NE<sub>1</sub>,...)</code><code><br>
          </code></font></td>
      <td valign="middle">Calls the "submonitor".<br>
      </td>
      <td valign="middle">The "submonitor" is a separate program from 
whatever XPL or XPL/I program is being compiled and run, providing some 
kine of system-specific functionality.&nbsp; In so far as <i>A Compiler Generator</i> is 
concerned, the submonitor's functionality and even its calling sequence 
was unknowable, and thus the <i>A Compiler Generator</i> <b>XCOM</b> system simply discarded all calls to the submonitor.<br>
        <br>
Not so with XPL/I: There is an extensive set of functions provided by the submonitor, and the XPL/I program <b>HAL/S-FC</b> uses them extensively as well, so <b>XCOM-I</b>
 needs to support them.&nbsp; Most (I hope!) but not all submonitor 
functions are known from their descriptions in section 13.3 of 
IR-182-1.&nbsp; Besides which, <b>HAL/S-FC</b> source code contains the source code for <font color="#663300"><code>MONITOR</code></font> (written in IBM 360 Basic Assembly Language), from which additional information can be obtained.<br>
        <br>
Because of the complexity of <font color="#663300"><code>MONITOR</code></font>, <a moz-do-not-send="true" href="#monitor">an entire separate section is devoted to explaining it</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR_LINK</code><code><br>
          </code></font></td>
      <td valign="middle">A fixed array which can be used for transmission of information between a program and the submonitor.<br>
      </td>
      <td valign="middle">(See Table 8.4.6 in <i>A Compiler Generator</i>.)&nbsp; I'm not presently aware of any need to implement this in <b>XCOM-I</b>.&nbsp; However, there are <font color="#663300"><code>MONITOR</code></font> functions (see above) whose operations remain a mystery, so there's a possibility that that could change.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>NDESCRIPT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the upper bound in the array <font color="#663300"><code>DESCRIPTOR</code></font> (see above) of the descriptions.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>DESCRIPTOR</code></font> above.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This is the analog of <font color="#663300"><code>INPUT</code></font> (see above) but for outputting textual data rather than inputting it.<br>
      </td>
      <td valign="middle">Most of the comments concerning <font color="#663300"><code>INPUT</code></font> (see above) are directly applicable to <font color="#663300"><code>OUTPUT</code></font>, or else are analogous in a very obvious way, so I'll try to confine my remarks to the clear differences between the two.<br>
        <br>
The most common use of <font color="#663300"><code>OUTPUT</code></font> is to "print" to the "SYSPRINT" device.&nbsp; Unlike the original <b>XCOM</b> computing environment, in which SYSPRINT was an actual printer, in <b>XCOM-I</b> SYSPRINT by default refers to <font color="#663300"><code>stdout</code></font>.&nbsp; And by default, <font color="#663300"><code>stdout</code></font> is attached to both <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font>. But there are differences between the two!&nbsp; Use of <font color="#663300"><code>OUTPUT(0)</code></font> is simpler, and therefore more common, but <font color="#663300"><code>OUTPUT(1)</code></font> is more flexible.&nbsp; Let's start with <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
Output statements via <font color="#663300"><code>OUTPUT(0)</code></font> might look something like this:<br>
        <blockquote><font color="#663300"><code>OUTPUT(0) = 'Hello, world!';</code><code><br>
            </code><code>OUTPUT(0) = 'Hello' || ',' || ' ' || 'world' || '!';</code><code><br>
            </code><code>OUTPUT(0) = 'This is OUTPUT statement number ' || 3;</code><code><br>
            </code><code>OUTPUT(0) = 25;</code></font><br>
        </blockquote>
Thus we can print any character strings or numbers we like, and can concatenate them using the string-concatenation operator (<font color="#663300"><code>||</code></font>), with <b>XCOM-I</b> doing the work of automatically converting numbers to strings where necessary.<br>
        <br>
Each use of <font color="#663300"><code>OUTPUT(0)</code></font> results in another physical line being printed.&nbsp; When printing messages with <font color="#663300"><code>OUTPUT</code></font>,
 since it is expected that the lines are being output to a physical 
printer, the system keeps track of the number of lines being printed, 
and automatically inserts page breaks in the output once a page has been
 filled up.&nbsp; At the tops of pages, a page number and optional 
headings and subheadings are also printed.&nbsp; The headings and 
subheadings, though, are simply whatever has been previously set up, and
 you can't change them or otherwise influence them using <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
With <font color="#663300"><code>OUTPUT(1)</code></font>, on the other 
hand, there's quite a bit of additional functionality.&nbsp; For 
example, it isn't necessarily true that each use of <font color="#663300"><code>OUTPUT(1)</code></font> prints another line.&nbsp; The <i>first</i> character of each <font color="#663300"><code>OUTPUT(1)</code></font> isn't directly printed, but instead is a "carriage-control character" (or "ANSI control character"), as follows:<br>
        <ul>
          <li>'<font color="#663300"><code> </code></font>' (i.e., a space) — Single-space the line and print.  This is the same behavior as <font color="#663300"><code>OUTPUT(0)</code></font>: i.e., any line you print to <font color="#663300"><code>OUTPUT(0)</code></font>, you could instead prefix it with a space character and send it to <font color="#663300"><code>OUTPUT(1)</code></font> instead.</li>
          <li>'<font color="#663300"><code>0</code></font>' — Double-space the line and print.</li>
          <li>'<font color="#663300"><code>-</code></font>' — Triple-space the line and print.</li>
          <li>'<font color="#663300"><code>+</code></font>' — Overstrike
 the preceding line.  In other words, go back to column 1, without 
advancing to the next line, and then print the remainder of the string. 
 Unfortunately, that's behavior suitable for a physical printer, but not
 really for outputting text to <font color="#663300"><code>stdout</code></font>
 on most computers today.&nbsp; Yes, we may be able to emulate it using 
strange maneuvers which most computers aren't set up for, but not in any
 universal, easily-set-up way.&nbsp; So in <b>XCOM-I</b>, the string is instead printed on a new line, almost as if the ANSI control character had been '<font color="#663300"><code> </code></font>'&nbsp; (see above) rather than '<font color="#663300"><code>+</code></font>'.&nbsp; Almost!&nbsp; You see, what these overstruck lines are mostly used for is underlining text.&nbsp; In <b>HAL/S-FC</b>,
 for example, text which has undergone replacement via macro expansion 
is underlined in compiler reports.&nbsp; The temptation is to mimic 
underlining by using underscore characters (_), but when underscore 
characters are printed on a separate line from the text they're 
underlining, they don't really look like underlining, but rather like 
overlining on the succeeding line ... which while it may be better than 
nothing, is absolutely <i>not</i> what you want it to look like!&nbsp; <b>XCOM-I</b>
 thus takes a slightly-different approach:&nbsp; It replaces such 
underscores by carats (^), which in my opinion are more-effective 
visually.&nbsp; For example, where one would have gotten something like <br>
</li></ul>
<blockquote>
  <blockquote>
    <pre><font color="#663300">... <code><u>MYTEXT</u> ...</code></font> </pre>
  </blockquote>
</blockquote>
<blockquote>on a line printer back in the olden times, today with <b>XCOM-I</b> you'll instead see the uglier but still effective<br>
</blockquote>
<blockquote>
  <blockquote>
    <pre><font color="#663300">... MYTEXT ...<br>    ^^^^^^</font><br></pre>
  </blockquote>
</blockquote>
<ul>

          <li>'<font color="#663300"><code>1</code></font>' — Form feed.
  I.e., advance to the top of the next page, regardless of how many 
left-over lines remain on the current page.  In <b>XCOM-I</b>, this is accomplished by embedding the ASCII form-feed character (<font color="#663300"><code>'\l'</code></font>) in the output.</li>
          <li>'<font color="#663300"><code>H</code></font>' — Heading 
line.  This doesn't print anything, but takes the remainder of the line 
and sets it as the heading for subsequent pages.</li>
          <li>'<font color="#663300"><code>2</code></font>' — Subheading
 line.  This doesn't print anything, but takes the remainder of the line
 and sets it as the subheading for subsequent pages.</li>
</ul>

<blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp; What this explanation of </font><font size="-1"><font color="#663300"><code>OUTPUT(1)</code></font> fails to explain is what happens if the string <i>doesn't have</i>
 a first character; i.e., what if it's empty?&nbsp; Well, the obvious 
response would be that that would be an illegal use.&nbsp; Unfortunately
 for us, that obvious fact didn't stop some of the coders of <b>HAL/S-FC</b> from strewing their code — perhaps an exaggeration —  with assignments <font color="#663300"><code>OUTPUT(1) = ''</code></font>, thus forcing us to deal with it.&nbsp; Lacking any particular rationale for what such a thing might mean, <b>XCOM-I</b> treats it as <font color="#663300"><code>OUTPUT(0) = ''</code></font>; i.e., it prints a newline.<br>
  </font></blockquote>
If you experiment with <font color="#663300"><code>OUTPUT(1)</code></font>, and even to a certain extent with <font color="#663300"><code>OUTPUT(0)</code></font>, you may become very confused, because various things won't work as you expect.&nbsp; Or at least, <i>I</i> was very confused at first.&nbsp; To get past this confusion, you need to grasp the following<br>
        <blockquote><b>Very important point</b>:&nbsp; For the computer 
systems most people are familiar with today, when we print a line of 
text, we expect that line of text to end with an implicit advance to the
 next line; i.e., with a "newline" character, often signified in 
programming languages by <font color="#663300"><code>'\n'</code></font>.&nbsp; Whereas in System/360 (and therefore in XPL or XPL/I), the implicit newline occurs <i>prior</i> to the text being printed by the <font color="#663300"><code>OUTPUT</code></font> command.&nbsp; I.e., today we typically ask ourselves "what happens at the <i>end</i> of the line"", whereas for XPL you need to ask "what happens at the <i>beginning</i> of the line?".<br>
        </blockquote>
Similarly to <font color="#663300"><code>INPUT</code></font>, you can attach additional sequential output files (<font color="#663300"><code><i>F</i></code></font>) on device numbers (<font color="#663300"><code><i>N</i></code></font>),<br>

        <blockquote><font color="#663300"><code>--ddo=<i>N,F</i></code></font><br>
        </blockquote>

Or for Partitioned Data Sets,<br>
        <blockquote><font color="#663300"><code>--pdso=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
For selecting partitions of a PDS, you don't use the same <font color="#663300"><code>MONITOR</code></font> call as for <font color="#663300"><code>INPUT</code></font>, but instead use: <br>

        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(1, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
        <font color="#663300"><code>OUTPUT</code></font> commands 
targets for a PDS don't immediately write data to the physical 
PDS.&nbsp; Rather, the data being output is buffered in memory until the
 <font color="#663300"><code>MONITOR(1, <i>N</i>, <i>NAME</i>)</code></font> call occurs, and the data is then written out to the selected partition in its entirety.&nbsp; The return value (<font color="#663300"><code><i>F</i></code></font>)
 is 0 if the partition is new (i.e., if it didn't previously exist in 
the PDS), while it is 1 if the partion previously existed but has now 
been overwritten with entirely new contents.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT</code><code><br>
          </code></font></td>
      <td valign="middle">The same as <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>PARM_FIELD</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a character string which contains the entire parameter specification coded on the <font color="#663300"><code>PARM=</code></font> option on the <font color="#663300"><code>EXEC</code></font> card.&nbsp; If no <font color="#663300"><code>PARM</code></font> is specified, a null string will be returned.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; A program of any 
complexity generally has a number of options selectable at 
runtime.&nbsp; For XPL/I programs like <b>HAL/S-FC</b>, the mechanism for selecting such options was originally a Job Control Language (JCL) card such as:<br>
        <blockquote><font color="#663300"><code>PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font><br>
        </blockquote>
Thus, <font color="#663300"><code>PARM_FIELD</code><code> </code></font>would have had the value <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font> in such a case.<br>
        <br>
In <b>XCOM-I</b>, <font color="#663300"><code>PARM_FIELD</code></font> 
is implemented as a function rather than a variable, but nevertheless 
returns data of the kind described.&nbsp; Of course, there is no JCL 
supplying such parameters, but the compiled program nevertheless has a 
command-line option that does the same job:<br>
        <blockquote><font color="#663300"><code>--parm='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'<br>
</code></font></blockquote>
        <blockquote><b><font color="#663300"><code></code></font></b><font size="-1"><b>Aside:</b>
 Depending on your operating system, some trickery may be involved in 
correctly forming such a command-line option.&nbsp; In Linux or (I 
suppose) Mac OS, the command shell expects the dollar sign (<font color="#663300"><code>$</code></font>)
 to indicate that the value of an environment variable is desired.&nbsp;
 In other words, if the string in the command-line option shown above 
had no quotes, then (for example) <font color="#663300"><code>$I</code></font> would be replaced by the value of the environment-variable <font color="#663300"><code>I</code></font>
 ... probably a blank!&nbsp; And the same thing would happen if the 
option were enclosed in double-quotes.&nbsp; But by using single-quotes,
 we defeat that substitution, and <font color="#663300"><code>$I</code></font> is reported in </font><font size="-1"><font color="#663300"><code>PARM_FIELD</code></font> literally as <font color="#663300"><code>$I</code></font>.&nbsp; Alternate tricks to defeating substitution could include using the backslash (<font color="#663300"><code>'\'</code></font>) escape character in front of all dollar signs (<font color="#663300"><code>$</code></font>).&nbsp; <br>
            <br>
            <b>Aside:</b> It has been decades since I used Windows in 
any serious way, so I don't really know whether there's any similar 
problem with it.&nbsp; Probably not.</font><br>
        </blockquote>
        <font color="#663300"><code></code></font></td>
    </tr>
    <tr>
  <td valign="middle" align="center"><font color="#663300"><code>RECORD_WIDTH(V)</code></font><br>
  </td>
  <td valign="top"><br>
  </td>
  <td valign="middle">(XPL/I only.)&nbsp; IR-182-1 doesn't mention it, but it appears to me that <font color="#663300"><code>RECORD_WIDTH</code></font> is a new built-in in XPL/I which when given the symbolic name of a <font color="#663300"><code>BASED</code></font> variable returns the variable's record size (in bytes).&nbsp; In <b>HAL/S-FC</b>'s XPL/I source code (the only available example of use of <font color="#663300"><code>RECORD_WIDTH</code></font>), I find it used only for a couple of <font color="#663300"><code>BASED RECORD</code></font>
 variables, which makes sense according to the naming, but I have no way
 to tell just from those few examples what the actual applicability 
was.&nbsp; In <b>XCOM-I</b>, it will work for any <font color="#663300"><code>BASED</code></font> variable, <font color="#663300"><code>RECORD</code></font> or not.<br>
  </td>
</tr>
<tr>
      <td valign="middle" align="center"><font color="#663300"><code>SET_LINELIM(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure establishes the number of lines
 which will be printed on the SYSPRINT file before an automatic page 
eject and header line will be printed.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; See <font color="#663300"><code>OUTPUT(NE)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHL(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value given by shifting the value of <font color="#663300"><code>NE<sub>1</sub></code></font> left (logical shift, zeroes appear in the least significant bit position) the number of positions indicated by the value of <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">One point I found confusing for quite a while is that you'd suppose that logical shifts would operate on <font color="#663300"><code>BIT</code></font> variables, and particularly on long-<font color="#663300"><code>BIT</code></font> variables, for which XPL provides no conveniences at all for accessing individual bits.&nbsp; Not so!&nbsp; <font color="#663300"><code>SHL</code></font> operates only on <font color="#663300"><code>FIXED</code></font> values, and can only shift by up to 32 positions.&nbsp; <font color="#663300"><code>BIT</code></font> variables are converted to <font color="#663300"><code>FIXED</code></font> if shift operations on them are needed.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHR(</code></font><font color="#663300"><code><font color="#663300"><code>NE<sub>1</sub>,NE<sub>2</sub></code></font>)</code><code><br>
          </code></font></td>
      <td valign="middle">Logical shift right.&nbsp; <font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font> are used in conjunction with <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> for masking and data packing.<br>
      </td>
      <td valign="middle">But recall that it is preferable to use <font color="#663300"><code>~</code></font> rather than <font color="#663300"><code>¬</code></font> with <b>XCOM-I</b>. </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING(<i>IDENTIFIER</i>)<br>
STRING(<i>INTEGER</i>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function transforms the variable <font color="#663300"><code>NE</code></font> (which should be <font color="#663300"><code>FIXED</code></font> for proper usage) into a <font color="#663300"><code>CHARACTER</code></font> descriptor.&nbsp; <font color="#663300"><code>NE</code></font> should have the form:<br>
        <br>
        <table align="center" cellspacing="2" cellpadding="2" border="1">
          <tbody>
            <tr>
              <th valign="middle" align="center">Length - 1<br>
              </th>
              <th valign="middle" align="center">&nbsp;Data Address<br>
              </th>
            </tr>
            <tr>
              <td valign="middle" align="center">8 bits<br>
              </td>
              <td valign="middle" align="center">24 bits<br>
              </td>
            </tr>
          </tbody>
        </table>
        <br>
      </td>
      <td valign="middle">(XPL/I only.) I admit that the description at 
left is confusing.&nbsp; The whole concept is confusing.&nbsp; Here's my
 take on it:&nbsp; I believe that <font color="#663300"><code>STRING</code></font> is used in one of two situations:<br>
<ul>
  <li>You have an <font color="#663300"><code><i>IDENTIFIER</i></code></font> for a <font color="#663300"><code>CHARACTER</code></font> variable, and you want the string descriptor for the string contained in that variable; or</li>
  <li>By some kind of arithmetical process, a <font color="#663300"><code><i>INTEGER</i></code></font> value has been created that you want to treat as a string descriptor.<br></li>
</ul>
These are respectively equivalent to<br>
<ul>
  <li><font color="#663300"><code>COREWORD(ADDR(IDENTIFIER))</code></font></li>
  <li><font color="#663300"><code>INTEGER</code></font></li>
</ul>
<p><b>XCOM-I</b> implements <font color="#663300"><code>STRING</code></font> using these equivalences, and there is no runtime library function as such that's called <font color="#663300"><code>STRING</code></font>.<br></p>
<p>To make things a bit more confusing, <font color="#663300"><code>STRING</code></font> is the one built-in I'm aware of that is <i>also</i>
 commonly used as a name for a variable.  If names of built-ins are 
declared as variables (or procedures), the user's declaration overrides 
the built-in for the scope of the declaration.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING_GT(DE<sub>1</sub>,DE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a <font color="#663300"><code>TRUE</code></font> value if the contents of string <font color="#663300"><code>DE<sub>1</sub></code></font> is greater than the contents of string <font color="#663300"><code>DE<sub>2</sub></code></font>, based on the collating sequence of the characters, irrespective of the lengths of <font color="#663300"><code>DE<sub>1</sub></code></font> and <font color="#663300"><code>DE<sub>2</sub></code></font>. Otherwise, the value is <font color="#663300"><code>FALSE</code></font>. This is functionally equivalent to padding the shorter of <font color="#663300"><code>DE<sub>1</sub></code></font> or <font color="#663300"><code>DE<sub>2</sub></code></font> with blanks and then comparing the strings.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; If this seems confusing, it may be helpful to recall that when the XPL relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>&lt;=</code></font>, and <font color="#663300"><code>&gt;=</code></font> compare two <font color="#663300"><code>CHARACTER</code></font>
 values, they look first at the lengths of the values, and only if the 
lengths are equal do they compare the actual character data.&nbsp; For 
example,<br>
        <blockquote><font color="#663300"><code>'ZZZ' &lt; 'AAAA'</code></font><br>
        </blockquote>
because <font color="#663300"><code>'ZZZ'</code></font> has only 3 characters, while <font color="#663300"><code>'AAAA'</code></font> has 4.&nbsp; Presumably <font color="#663300"><code>STRING_GT</code></font> was introduced because somebody at Intermetrics didn't think that kind of behavior was great, and thus <font color="#663300"><code>STRING_GT('ZZZ', 'AAAA')</code></font> will report instead that <font color="#663300"><code>'ZZZ'</code></font> is greater than <font color="#663300"><code>'AAAA'</code></font>.<br>
        <br>
The collating sequence in either case is EBCDIC rather than the 
more-usual ASCII.&nbsp; The primary visually-obvious consequence of this
 is that digits come after letters rather than before them.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the substring of the string specified by <font color="#663300"><code>DE</code></font>, starting at position with <font color="#663300"><code>NE<sub>1</sub></code></font> with length <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">I.e., it allocates and returns a new string created by taking a substring of length <font color="#663300"><code>NE<sub>2</sub></code></font>, starting at position <font color="#663300"><code>NE<sub>1</sub></code></font> in string <font color="#663300"><code>DE</code></font>.<sub><code></code></sub><sub><code></code></sub><font color="#663300"><code></code></font> </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE)</code><code><br>
          </code></font></td>
      <td valign="middle">Like the above except that all characters from <font color="#663300"><code>NE</code></font> to the end of the string are taken.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME</code><code><br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the time-of-day coded as centiseconds since midnight.<br>
      </td>
      <td valign="middle">See the notes for the <font color="#663300"><code>DATE</code></font> function above.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>TIME</code></font> during compilation of the program.<br>
      </td>
      <td valign="middle"><font color="#663300"><code>TIME</code></font> (see above) isn't literally available during compilation.&nbsp; Moreover, <b>XCOM-I</b>
 implements this as a function rather than as a variable, which should 
be transparent to the programmer.&nbsp; <br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL TRACE;</code></font><br>
        </blockquote>
which causes activation of the instruction-by-instruction trace at runtime.<br>
      </td>
      <td valign="middle">This is described in quite a lot of detail in <i>A Compiler Generator</i>'s Appendix 2.&nbsp; At present, it is accepted during 
compilation but does nothing at runtime in code generated by <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>UNTRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL UNTRACE;</code></font><br>
        </blockquote>
which turns off run-time trace.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>TRACE</code></font>.<br>
      </td>
    </tr><tr>
  <td valign="middle" align="center"><font color="#663300"><code>XPL_COMPILER_VERSION</code></font><br>
  </td>
  <td valign="middle"><code></code><code></code><font color="#663300"><code></code></font> An array of length 2 — actually a function in the <b>XCOM-I</b> runtime library —  in which the first element is the major version of the XPL compiler (<b>XCOM-I</b> in this case), and the second element is the minor version, both in the range 0-99.<br>
  </td>
  <td valign="middle">This is just speculation on my part, based on how 
an undeclared variable with this name is used when it appears a couple 
of times in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp; Nearby code also provides the interesting information that the XPL version <i>name</i> is "TITAN--XPL".&nbsp; You may recall my <a moz-do-not-send="true" href="#titan">earlier observation</a>
 that Intermetrics merged with Titan Corporation in March 2000, which is
 obviously the origin of the "TITAN" portion of the name.&nbsp; The 
other interesting&nbsp; point is that no effort is made to distinguish 
it in any way from <i>standard</i> XPL.<br>
    <br>
Of course, I have no inkling whatever of how the versions for the 
Intermetrics/Titan XPL compiler were numbered.&nbsp; I was tempted to 
set the major version to 32 and the minor version to 0, but that would 
only serve to obscure the fact that <b>XCOM-I</b> is in fact <i>not</i> TITAN--XPL, nor even related to it other than that I've tried to imitate it.&nbsp; Instead, <b>XCOM-I</b>
 will always return a major and minor versions appropriate to 
itself:&nbsp; major = 0 preliminary versions, 1 for first release, and 
so on.<br>
    <br>
As an <i>ad hoc</i> measure, <b>XCOM-I</b> also transparently performs string substitions replacing 'TITAN--XPL', wherever it may be found, by 'RSB-XCOM-I'.<br>
  </td>
</tr>

  </tbody>
</table>
<br>
<h1><a name="monitor"></a>The MONITOR Built-In Runtime-Library Function</h1>

<p>As mentioned before, an XPL/I program obtained various services 
outside what the XPL/I language proper or runtime library could provide,
 by instead making requests to the separate "submonitor" program.  The 
mechanism was a call of the <font color="#663300"><code>MONITOR</code></font> procedure.  For <b>XCOM-I</b>, on the other hand, there is no separate submonitor program, and we may as well think of <font color="#663300"><code>MONITOR</code></font> as being just another built-in runtime-library function.  Well, not just <i>any</i>
 runtime-library function.  A big difference is that it provides a very 
large number of functions, each one of which can require its own unique 
syntax, thus necessitating a somewhat more-flexible discussion of how to
 use it.</p>
<p>The only uniform feature among the many aspects of <font color="#663300"><code>MONITOR</code></font> usage is that each separate function it provides is identified by a number, and such a function number is passed to <font color="#663300"><code>MONITOR</code></font>
 as its first parameter.  My explanations in the table below are mostly 
pulled from Chapter 13 of IR-182-1, and then altered according to my 
understanding (or lack thereof).  Functions 24 through 32 are deduced, 
poorly, from the <b>HAL/S-FC</b> BAL source-code file for the submonitor program (which happens to be called "MONITOR").<br></p>
<p>A number of the <font color="#663300"><code>MONITOR(...)</code></font>
 functions work with what's called "IBM hexadecimal floating-point" 
format, and specifically to the 64-bit (double-precision) version of 
that format, as opposed to the 32-bit (single-precision) version of it. 
To make the discussion more concise, I'll just refer to it as "DP 
floating point".  <br></p>
<p>To be perfectly clear, there is <i>no</i> floating-point datatype in 
XPL/I, there are no floating-point literal constants, and there is no 
provision whatever to make it convenient for you (the programmer!) to 
hard-code such constants into your XPL source code, nor to interpret any
 such hexadecimal constants you find within legacy source code.  Rather, 
you must somehow obtain the hexadecimal equivalents for whatever 
floating-point constants you wish to use, and then hard-code those 
hexadecimals into your code.  For your convenience — or more accurately,
 for <i>mine</i> — I've included a little utility called ibmHex.py that 
you can use to convert back-and-forth between human-readable 
floating-point numbers and DP floating point.  Just run <font color="#663300"><code>ibmHex.py --help</code></font> for instructions.  This little utility can either be run in a stand-alone fashion, or else you can <font color="#663300"><code>import</code></font> it as a Python module.  But I digress!<br></p>
<p>To understand DP floating point, imagine 8 groups of 8 bits each:<br></p>
<blockquote>
  <pre><font color="#663300">SEEEEEEE FFFFFFFF FFFFFFFF ... FFFFFFFF</font></pre>
</blockquote>
<p>where <font color="#663300"><code>S</code></font> is the sign, <font color="#663300"><code>E</code></font> is the exponent, and <font color="#663300"><code>F</code></font> is the fraction.  (SP floating point is the same, but with 3 <font color="#663300"><code>FFFFFFFF</code></font>-groups rather than 7 of them.)  The exponent is a power of 16, biased by 64, and thus represents 16<sup>-64</sup> through 16<sup>63</sup>.
  The fraction is an unsigned number, of which the leftmost bit 
represents 1/2, the next bit represents 1/4, and so on.  As a special 
case, 0 is encoded as all zeroes.<br><br>For example, the 64-bit hexadecimal pair 0x42640000 0x00000000 parses as:<br></p>
<ul>
  <li>Sign = 0 (i.e., positive)</li>
  <li>Exponent = 16<sup>0x42-0x40</sup> = 16<sup>2</sup> = 2<sup>8</sup>.</li>
  <li>Fraction = 0.0110 0100 ...</li>
</ul>
<p>or in total, 1100100 (binary), or 100 decimal.<br></p>
<p>As in the preceding section, I want to make it clear that the descriptions given here are how the <b>XCOM-I</b> runtime library's <font color="#663300"><code>MONITOR</code></font> functions work, and not how the original <font color="#663300"><code>MONITOR</code></font> functions as confined to an IBM 360 runtime environment worked!</p>

<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>MONITOR Functions</b></font></caption>

  <tbody>
    <tr>
      <th valign="bottom" nowrap="nowrap" align="center">MONITOR Call<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(0,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes output file <i><font color="#663300"><code>n</code></font></i>.<br>
</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(1,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to output device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Physically writes any data previously buffered in memory by <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font> operations into the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp; Returns 0 if the member hadn't existed previously in 
the PDS, or 1 if the contents of an existing member of that name was 
replaced.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(2,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to input device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Sets future <font color="#663300"><code>INPUT(n)</code></font> operations to pull data from the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp;  Returns 0 if the member was found, or 1 if it was not 
found.<br>
</td>
      <td valign="middle">The end-of-data for the member is detected when an input string of 0 length is encountered.<br>
  <br>
IR-182-1 asserts that devices 4 and 7 have the following abnormal <i>ad hoc</i> behavior very specific to <b>HAL/S-FC</b>.&nbsp;
 A PDS called "INCLUDE" is normally attached to input device 4, while 
either "INCLUDE" or "OUTPUT6" is normally attached to input device 
7.&nbsp; But member <code><font color="#663300"><i>name</i></font></code>&nbsp; is sought in device 4 or 7, then <code><font color="#663300"><i>name</i></font></code> is first sought in "INCLUDE" but upon failure is then sought in "OUTPUT6".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(3,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes input file <i><font color="#663300"><code>n</code></font></i>.</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>INPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(4,<i>n</i>,<i>b</i>);<br>
    </font></code></td>
      <td valign="middle">Changes the record size of random-access file <code><font color="#663300"><i>n</i></font></code> to <code><font color="#663300"><i>b</i></font></code>.&nbsp; Must precede the first use of <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(5,ADDR(DW));<br>
    </font></code></td>
      <td valign="middle">Sets the location of the double-word work area (<font color="#663300"><code>DW</code></font>) for subsequent use by <font color="#663300"><code>MONITOR(9,...)</code></font> and <font color="#663300"><code>MONITOR(10,...)</code></font>.<br>
</td>
      <td valign="middle"><code><font color="#663300">DW</font></code> is meant to be literal here, at least for <b>HAL/S-FC</b>, and should not be replaced by anything else.<br>
  <br>
  <code><font color="#663300">DW</font></code> refers to an array of <font color="#663300"><code>FIXED</code></font>
 variables used in pairs, to hold 64-bit values. In particular, these 
pairs are often used to hold double-precision floating-point numbers in 
IBM System/360 format.&nbsp;&nbsp; <code><font color="#663300">MONITOR(9,<i>op</i>)</font></code> <font color="#663300"><font color="#000000">(see
 below) is then capable of performing various arithmetical operations on
 those numbers.&nbsp; Since XPL/I itself has no facilities for 
floating-point variables or operations on them, this workaround is the 
only available way to employ floating-point numbers in XPL/I programs.<br>
<br>
In legacy HAL/S code, I've found that at least 14 words of memory are 
needed for this work area.&nbsp; In the XCOM-I implementation, the </font></font><font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(5)</font></code> call is rejected within 14 words of the end of memory.</font></font><code><font color="#663300"><br>
    </font></code></td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Allocates <font color="#663300"><i>n</i></font> bytes of storage in free memory, clearing that memory to 0, and assigns the pointer of the <font color="#663300"><code><i>basedVariable</i></code></font> to point to that newly-allocated space.&nbsp; Returns 0 upon success, or 1 upon failure.<br>
</td>
      <td valign="middle">It would be natural to suppose that <code><font color="#663300">MONITOR(6)</font></code> is the mechanism used to allocate memory for <font color="#663300"><code>BASED</code></font>
 variables declared in the XPL/I code.&nbsp; In general, this is <i>not</i> true.&nbsp; Memory for <font color="#663300"><code>BASED</code></font>
 variables declared in user XPL code comes from a large pre-allocated 
contiguous block of memory, and the sub-allocations of individual <font color="#663300"><code>BASED</code></font> variables within that large block are managed using means other than <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font> and <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(7)</font></code></font></font>.<br>
<blockquote>
  <b><font size="-1">Aside:</font></b><font size="-1">&nbsp; It appears to me that once upon a time, the intention may indeed have been for </font><font size="-1"><font color="#663300"><code>BASED</code></font> variables to be managed by </font><font size="-1"><code><font color="#663300">MONITOR(6)</font></code>.&nbsp; The evidence for this is a procedure called <font color="#663300"><code>DESCRIPTOR_MONITOR</code></font> in SPACELIB, which does try to allocate or deallocate space for </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables in just that fashion.&nbsp; However, </font><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font> is never called, and some of the variables upon which it depends are never declared, making </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font></font> uncompilable.&nbsp; (<b>XCOM-I</b> transparently deletes it, and other functions which are never called.) &nbsp; But in spite of the historical evidence of </font><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font>, I see no such behavior in any of the <i>active</i> code, with a single exception:&nbsp; The memory-management system itself (i.e., SPACELIB) does have a </font><font size="-1"><font color="#663300"><code>BASED</code></font> variable, <font color="#663300"><code>DX</code></font>, which it continues to manage using <font color="#663300"><code>MONITOR(6)</code></font> and <font color="#663300"><code>MONITOR(7)</code></font>.<br>
  </font></blockquote>
My observation is that <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font> must update more of the <font color="#663300"><code><i>basedVariable</i></code></font> than just its pointer to its data.<font color="#663300"><font color="#000000">&nbsp;&nbsp; </font></font>Recall that a <font color="#663300"><code>BASED</code></font> variable is associated with a 28-byte structure known as a <a moz-do-not-send="true" href="#DopeVectors">"dope vector"</a>,
 of which the pointer to the data comprises only bytes 0-3.&nbsp; Beyond
 that, bytes 4-5 give the sizes (in bytes) of each record, while bytes 
8-11 give the total number of records allocated so far.&nbsp; (Not to be
 confused with the total number of records in use; for growth, more 
records may have been allocated than were strictly needed at that 
moment.)&nbsp; While <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font>
 may not need an entire dope vector to be present at the address it has 
been given, it needs the first 12 bytes to be present, so that it can 
use/update the fields just mentioned.&nbsp; I don't see evidence of that
 in the submonitor source code, but then I don't fully understand that 
source code; at any rate, this is how <b>XCOM-I</b> treats it.<br>
<br>
Note that <font color="#663300"><code>MONITOR(6)</code></font> <i>increases</i> the size of <code><font color="#663300"><i>basedVariable</i></font></code> by <code><font color="#663300"><i>n</i></font></code> bytes; it does not <i>set</i> the size to <code><font color="#663300"><i>n</i></font></code> bytes.<br>
</td></tr><tr><td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(7,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Frees memory previously allocated via <code><font color="#663300">MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>)</font></code>.&nbsp; However, <code><font color="#663300"><i>basedVariable</i></font></code>'s pointer is not changed, and thus will continue to point to the freed area until explicitly changed.<br>
</td>
      <td valign="middle" bgcolor="transparent">See the comments for <code><font color="#663300">MONITOR(6)</font></code>.&nbsp; <br>
<br>
If <code><font color="#663300"><i>n</i></font></code> is less than the total number of bytes allocated for <code><font color="#663300"><i>basedVariable</i></font></code>, then the number of records available in <code><font color="#663300"><i>basedVariable</i></font></code> has shrunk, but <code><font color="#663300"><i>basedVariable</i></font></code> continues to be usable, with a reduced number f records.<br>
<br>
Although described as having the address of a <font color="#663300"><code>BASED</code></font> variable as a parameter, this isn't entirely true.&nbsp; It is also sometimes the address of a <font color="#663300"><code>FIXED</code></font> variable.<br>
</td></tr><tr><td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(8, <i>dev</i>, <i>filenum</i>);<br>
    </font></code></td>
      <td valign="middle">Set PDS DDNAME.<br>
</td>
      <td valign="middle" bgcolor="transparent">Apparently, the use of <code><font color="#663300">MONITOR(8)</font></code>
 changed after the only documentation of it (in IR-182-1) was produced, 
leaving us to try to infer its usage from context in the <b>HAL/S-FC</b> and <code><font color="#663300">MONITOR</font></code>'s source code.&nbsp; The purpose seems to be to change the association of files to device numbers, <i>à la</i> <font color="#663300"><code>DD</code></font>'s in JCL, but to do so dynamically during execution rather than statically at program startup.&nbsp; <br>
<br>
The <font color="#663300"><code><i>dev</i></code></font> parameter, an integer, would appear to be the logical device number as used in an <code>XPL <font color="#663300">INPUT(<i>dev</i>)</font></code> or <font color="#663300"><code>OUTPUT(<i>dev</i>)</code></font> (or in a HAL/S <font color="#663300"><code>READ(<i>dev</i>)</code></font> or <font color="#663300"><code>WRITE(<i>dev</i>)</code></font>).<br>
<br>
The <i><font color="#663300"><code>filenum</code></font></i> parameter is trickier for me to understand, because I'm unclear how <font color="#663300"><code>DD</code></font>
 in JCL associates a dataset name with a file number, so take what I say
 with a grain of salt.&nbsp; My inference, subject to change, is that if
 you have a dataset identified with the <font color="#663300"><code>DD</code></font> name "<font color="#663300"><code>INPUT<i>n</i></code></font>" (where <font color="#663300"><code><i>n</i></code></font> is a digit), then that is <font color="#663300"><code><i>filenum</i>=<i>n</i></code></font>; whereas a dataset named "<font color="#663300"><code>OUTPUT<i>n</i></code></font>" is associated with <font color="#663300"><code><i>filenum</i>="80000000"|<i>n</i></code></font>.&nbsp; Recall that <font color="#663300"><code>"80000000"</code></font> is XPL-speak for 0x80000000.&nbsp; So the <i><font color="#663300"><code>filenum</code></font></i> is implicit in the dataset name, and the most-significant bit is used to indicate the direction of data flow.<br>
<br>
For example, <font color="#663300"><code>INPUT(4)</code></font> invocations might normally input data from <font color="#663300"><code>INPUT4</code></font>, but you could associate it instead with <font color="#663300"><code>INPUT2</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 2);</font><br></pre>
</blockquote>
and then reassociate it later with <font color="#663300"><code>INPUT4</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 4);<br></font></pre></blockquote>
The description "Set PDS DDNAME" I've given as the description comes 
from the associated program comment in MONITOR.bal, the source-code for 
the <font color="#663300"><code>MONITOR</code></font> procedure.&nbsp; 
It would seem to imply that it has something specifically do with 
Partitioned Data Sets (PDS).&nbsp; It's difficult to see why that would 
be so; I think it merely reflects the specific usage in HAL/S-FC, which 
indeed relates to PDS.&nbsp; The XCOM-I runtime library allows it to be 
used for and PDS <i>or</i> sequential dataset.&nbsp; It is not applicable to random-access files.<br>
<br>
Of course, there is no JCL, and consequently no DD statements, associated with an XPL or XPL/I file compiled with <b>XCOM-I</b>, nor with a HAL/S file compiled with <b>HAL/S-FC</b>.&nbsp; The description above has to be applied instead to command-line switches in a hopefully-obvious way.<br>
<blockquote>
</blockquote>


</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(9,<i>op</i>);<br>
    </font></code></td>
      <td valign="middle">Performs floating point evaluation as specified by value of <code><font color="#663300"><i>op</i></font></code>.&nbsp; Operands are obtained from work area whose address was set up via a <font color="#663300"><code>MONITOR(5)</code></font>
 call. The first operand is taken from the first double word of the work
 area and the second operand from the second double word. The result is 
placed in the first double word of the work area. The return code is 0 
if the operation succeeds, or 1 if the operation fails (under or 
overflow).<br>
  <br>
The values of <code><font color="#663300"><i>op</i></font></code> are:<br>
  <table align="center" cellspacing="2" cellpadding="2" border="1">
    <tbody>
      <tr>
        <th valign="top">OP<br>
        </th>
        <th valign="top">Function<br>
        </th>
      </tr>
      <tr>
        <td valign="top" align="center">1<br>
        </td>
        <td valign="top" align="center">arg1 + arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">2<br>
        </td>
        <td valign="top" align="center">arg1 - arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">3<br>
        </td>
        <td valign="top" align="center">arg1 * arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">4<br>
        </td>
        <td valign="top" align="center">arg1 / arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">5<br>
        </td>
        <td valign="top" align="center">arg1<sup>arg2</sup><br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">6<br>
        </td>
        <td valign="top" align="center">sin(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">7<br>
        </td>
        <td valign="top" align="center">cos(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">8<br>
        </td>
        <td valign="top" align="center">tan(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">9<br>
        </td>
        <td valign="top" align="center">exp(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">10<br>
        </td>
        <td valign="top" align="center">log(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">11<br>
        </td>
        <td valign="top" align="center">sqrt(arg1)<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
</td>
      <td valign="middle">"arg1" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(0),DW(1)</code></font>.<br>
  <br>
"arg2" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(2),DW(3)</code></font>.<br>

  <br>
The DP floating-point result of the operation is stored back into <font color="#663300"><code>DW(0),DW(1)</code></font>, although not all of the operations can necessarily produce results of full DP accuracy from DP operands.<br>
  <br>
The angular unit for trigonometric operations is the radian.<br>
<br>
Note that the values stored in these registers of the work-area are in 
the binary format of "IBM hexadecimal floating-point", which are not 
used anywhere else in XPL memory (unless copied from the working area).<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(10,<i>string</i>);<br>
    </font></code></td>
      <td valign="middle">Performs character to DP floating-point conversion upon characters in <code><font color="#663300"><i>string</i></font></code>.
 The return code is 0 if the result is valid, or 1 if conversion was not
 possible. The result is placed in the first double word of the work 
area provided by the <font color="#663300"><code>MONITOR(5)</code></font> call.<br>
</td>
      <td valign="middle">In other words, <code><font color="#663300"><i>string</i></font></code> is interpreted as a DP floating-point number and stored in <font color="#663300"><code>DW(0),DW(1)</code></font>.&nbsp; Any of the usual representations for decimal numbers are accepted in the string, including the usual <font color="#663300"><code>E</code></font> notation for exponents.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(11);<br>
    </font></code></td>
      <td valign="middle">No-op.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>string</i>=MONITOR(12,<i>p</i>);<br>
    </font></code></td>
      <td valign="middle">Converts floating-point number in the first double word of the work area to standard HAL/S character form. Value of <code><font color="#663300"><i>p</i></font></code> indicates whether the operand is SP (<code><font color="#663300"><i>p</i></font></code>=0) or DP (<code><font color="#663300"><i>p</i></font></code>=8).<br>
</td>
      <td valign="middle">In other words, this is the inverse of <code><font color="#663300">MONITOR(10,<i>string</i>)</font></code> (see above).<br>
  <br>
As far as the "standard HAL/S character form" is concerned, it's described in HAL/S documentation (<i>Programming in HAL/S</i>, p. 3) as follows:<br>
  <ul>
    <li>0.0: Printed as " 0.0" (notice the leading space).</li>
    <li>Positive:  Printed as " d.ddd...E±ee"</li>
    <li>Negative:  Printed as "-d.ddd...E±ee"</li>
  </ul>
Except for the special case 0.0, the number of printed fractional digits
 is always the same, although we're not told exactly how many that it 
is:&nbsp; merely that it is "implementation dependent".&nbsp; I believe,
 without any basis — and therefore <b>XCOM-I</b> implements — that the 
number of fractional digits is chosen to provide the maximum accuracy, 
which is 6 for single precision and 15 for double precision.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>address</i>=MONITOR(13,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Performs DELETE of current option processor and then LOADs an option processor specified by <code><font color="#663300"><i>name</i></font></code>.
 The option processor loaded is called and passed a pointer to the PARM 
field in effect at the time of compiler invocation. The option processor
 passes the PARM field and establishes an options table (see Chapter 9 
[of document IR-182-1]) whose address is passed back as a return 
value.&nbsp; If <code><font color="#663300"><i>name</i></font></code> is a null string, the pointer to the existing options table is returned.<br>
</td>
      <td valign="middle"><a name="MONITOR13"></a><a moz-do-not-send="true" href="#programOptions">See the earlier discussion concerning program options</a>.&nbsp;
 In brief, each XPL or XPL/I program has some defined set of "Type 1" 
options and "Type 2" options.&nbsp; The former are binary (on/off) 
options, whereas the latter are options with integer or string values.<br>
<br>
<code><font color="#663300">MONITOR(13,<i>name</i>)</font></code>
 returns an address which is used by the XPL program to find options settings for it that have been
 set up by the run-time library.&nbsp; In C terms, it's the equivalent 
for <font color="#663300"><code>argv[]</code></font> but with more 
behind-the-scenes interpretation of the parameters.&nbsp; Those program 
options would originally have been provided by the Job Control 
Language (JCL) which initiated execution of the program, by means a 
"PARM field" given on one of the JCL cards.&nbsp; For example, in the 
JCL<br>
<blockquote>
  <pre><font color="#663300">//XPL EXEC PGM=MONITOR,<br>//         PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</font><br></pre>
</blockquote>
the PARM field is the string <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font>,
 and the comma-delimited items are the individual options 
selected.&nbsp; Presumably, the operating system wouldn't have been able
 to directly interpret the meaning of this PARM field on its own, since 
the types of options would have been specific to the program being 
run.&nbsp; So an "option processor" specific to the allowed parameters
must be loaded to perform that interpretation.&nbsp; In the case of 
the Intermetrics version of <b>HAL/S-FC</b>, the particular options processor for compiler pass 1 was <code><font color="#663300"><i>name</i></font></code><font color="#663300"><code>='COMPOPT '</code></font>, whereas it was an empty string for passes 2 and 3, and <font color="#663300"><code>'LISTOPT '</code></font>
 for pass 4.&nbsp; (Note the trailing spaces to make the non-empty 
strings come out to 8 characters.&nbsp; These trailing spaces are not required in <b>XCOM-I</b>.)&nbsp; <br>
<br>
Again, just to be doubly clear, <code><font color="#663300">MONITOR(13)</font></code> provides access to options settings <i>not</i> for <b>XCOM</b> or <b>XCOM-I</b>, but rather for the XPL program being compiled by <b>XCOM-I</b>, and specifically for <b>HAL/S-FC</b>. <br>
<br><b>XCOM-I</b> supports the pre-existing built-in options processors 
'COMPOPT', 'LISTOPT' and 'MONOPT'.&nbsp; (MONOPT provides the parameters
 described in <i>A Compiler Generator</i> but they are passed to the XPL/I program in the 
Intermetrics manner rather than being confined to the submonitor as in <i>A Compiler Generator</i>.)&nbsp; Plus, it is possible (as described in the discussion of
 program options) for the user to define their own custom options 
processor called 'USEROPT'.&nbsp; Whenever <code><font color="#663300">MONITOR(13)</font></code> is called, it saves the <code><font color="#663300"><i>name</i></font></code> and the PARM field to a file called "monitor13.parms".&nbsp; If called with an empty <code><font color="#663300"><i>name</i></font></code>, or more typically as <code><font color="#663300">MONITOR(13,0)</font></code>, it simply reloads the contents of monitor13.parms and reuses those.<br>
<br>
The <code><font color="#663300"><i>address</i></font></code> returned by <code><font color="#663300">MONITOR(13)</font></code> is a pointer in memory to the beginning of a block of 6 consecutive <font color="#663300"><code>FIXED</code></font> values<font size="-1"><b>:</b></font><br>
<ul>
  <li><font color="#663300"><font color="#000000">The<b> </b>first is a <font color="#663300"><code>FIXED</code></font> value (called </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>OPTIONS_CODE</code></font> or <font color="#663300"><code>OPTION_BITS</code></font>) that collects</font></font>
 32 bit flags, each of them (in principle) itself representing a type 1 
(on/off) option.  Refer to the source-code files COMPOPT.bal, 
LISTOPT.bal, and MONOPT.bal (in the MONITOR.ASM folder of the <b>HAL/S-FC</b> source code) for the detailed list of which options correspond to which of the 32 bits.</li><li><font color="#663300"><font color="#000000">The remaining five values are the pointer addresses for <font color="#663300"><code>BASED FIXED</code></font> arrays:  </font><code>CON</code></font>, <font color="#663300"><code>PRO</code></font>, <font color="#663300"><code>TYPE2</code></font>, <font color="#663300"><code>VALS</code></font>, <font color="#663300"><code>NPVALS</code></font> (or <font color="#663300"><code>MONVALS</code></font>), each of which the options processor has already allocated memory for and equipped with data:</li>
  
<ul>

    <li><font color="#663300"><code>CON</code></font>:  This is an array of string descriptors for the selected type 1 options.  <b>HAL/S-FC</b> uses it just for printing a report in pass 1, while using <font color="#663300"><code>OPTIONS_CODE</code></font> in place of it for any more-significant purpose. <a moz-do-not-send="true" href="#programOptions">Our earlier section on program options</a> lists the order in which the parameters appear in <font color="#663300"><code>CON</code></font>.</li><li><font color="#663300"><code>PRO</code></font>:  In principle, this is like <font color="#663300"><code>CON</code></font>, but instead contains the opposites of the selected options.  For example, if "LISTING2" appears in <font color="#663300"><code>CON</code></font>, then "NOLISTING2" appears in <font color="#663300"><code>PRO</code></font>.</li>
    <li><font color="#663300"><code>TYPE2</code></font>:  This array 
contains the names (as string descriptors) of options of type 2 (i.e., 
options which can be assigned value other than on/off).  They are 
presented in the order listed in the discussion of program options. <br></li>
    <li><font color="#663300"><code>VALS</code></font>:  This array contains the values of the options of type 2, in the same order as the names in the <font color="#663300"><code>TYPE2</code></font> array.  Once again, see the discussion of program options.</li>
    <li><font color="#663300"><code>NPVALS/MONVALS</code></font>: This is like <font color="#663300"><code>CON/PRO</code></font>, except that in principle it contains values of options which are <i>not</i> among the list printed by <b>HAL/S-FC</b>, which roughly speaking, is half of them.</li>
  
</ul>
</ul>
<ul>

</ul>



</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(14,<i>n</i>,<i>a</i>);<br>
    </font></code></td>
      <td valign="middle">For creating Simulation Data Files.&nbsp; The value of <code><font color="#663300"><i>n</i></font></code> selects a function; the value of <code><font color="#663300"><i>a</i></font></code> supplies supplementary data:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="top"><code><font color="#663300"><i>n</i></font></code></th>
      <th valign="top">Function<br>
      </th>
      <th valign="top"><code><font color="#663300"><i>a</i></font></code></th>
    </tr>
    <tr>
      <td valign="middle" align="center">0<br>
      </td>
      <td valign="middle" align="center">Open<br>
      </td>
      <td valign="middle" align="center">option flags<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">1<br>
      </td>
      <td valign="middle" align="center">Write<br>
      </td>
      <td valign="middle" align="center">area address<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">2<br>
      </td>
      <td valign="middle" align="center">Stow &amp; Close<br>
      </td>
      <td valign="middle" align="center">member name<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
</td>
      <td valign="middle">Unfortunately, the only documentation of this is from 1976, and it may be somewhat preliminary in nature.<br>
<br>
For example, from the source code of <b>HALS/FC</b> (see the <font color="#663300"><code>OUTPUT_SDF</code></font> procedure in <b>PASS3</b>), the function numbers (<code><font color="#663300"><i>n</i></font></code>) appear to be 0, 4, and 8 (rather than 0, 1, and 2 as it says in the description to the neighboring column).<br>
<br>
It appears to me that it's used somewhat like this:&nbsp; <br>
<ol>
  <li>First you "open" the SDF file.&nbsp; It apparently consists of 
"pages", numbered from 0 upward.&nbsp; The only "option" you can give it
 is the maximum page number.</li>
  <li>Then you "write" to the file a page at a time, starting at page 
0.&nbsp; Each "write" transfers data from the "area address" you specify
 to the next higher page in the buffer.</li>
  <li>Finally, you "stow&amp;close" the SDF file.&nbsp; This is the step
 which writes the memory buffer out to the actual SDF file (if it hasn't
 been doing so already), which is a partitioned data set (PDS).&nbsp; 
The member name of the PDS is assigned at this point.&nbsp; Note that 
the member name can be one that already exists in the PDS, which will 
cause the existing member to be overwritten.<br>
  </li>
</ol>
<p>Thus you start with a presumably-empty PDS (which happens to be 
attached to output device 5), and end up with a PDS populated with lots 
of named members, each one of which consists of some integral number of 
"pages".<br>
</p>

</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(15);<br>
    </font></code></td>
      <td valign="middle">Returns Revision Level and Catenation Number from last <font color="#663300"><code>MONITOR(2)</code></font>
 call.&nbsp; Catenation number is obtained from PDS directory data and 
Revision Level from user data field as specified in the HAL/SDL ICD. The
 values are returned in the left and right halfwords of the result.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(16,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Sets flags in byte to be returned as high 
order byte of return code at end of compilation. Flags are passed as 
right most byte of fullword <code><font color="#663300"><i>n</i></font></code>. If high order bit of <code><font color="#663300"><i>n</i></font></code> is zero, flags are OR'ed into existing flags. If high order bit of <code><font color="#663300"><i>n</i></font></code> is one, flags replace existing flags.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(17,name);<br>
    </font></code></td>
      <td valign="middle">Causes <i><code><font color="#663300">name</font></code></i> to be copied to third parm field (if any) passed to <font color="#663300"><code>MONITOR</code></font> by the program that invoked the compiler. See HAL/SDL ICD.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>T</i>=MONITOR(18);<br>
    </font></code></td>
      <td valign="middle">Returns elapsed CPU time since beginning of run in units of .01 seconds.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(19,<i>addressList</i>,<i>sizeList</i>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(6)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes.&nbsp; Unlike <font color="#663300"><code>MONITOR(6)</code></font>, the newly-allocated blocks of memory are not cleared to 0.<br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.&nbsp; Besides, it's unclear how to represent a "list".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(20,</font></code><code><font color="#663300"><code><font color="#663300"><i>addressList</i>,<i>sizeList</i></font></code>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(7)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes. <br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(21);<br>
    </font></code></td>
      <td valign="middle">Returns remaining amount of memory (in bytes) that's free for allocation via <font color="#663300"><code>MONITOR(6)</code></font>.<br>
</td>
      <td valign="middle">For Intermetrics <b>XCOM</b>, I believe, <font color="#663300"><code>MONITOR(6)</code></font> could use <i>any</i> contiguous block of free memory, including those that were candidates for garbage collection.&nbsp; Whereas <b>XCOM-I</b>
 only allocates memory within the contiguous block at the end of the 
free-memory space.&nbsp; Consequently, this function would originally 
have found the largest free block wherever it was located, whereas <b>XCOM-I</b> merely reports the size of the final block of free memory.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i><code><font color="#663300"><code><font color="#663300">=MONITOR(22,0,<i>n</i><i><sub>2</sub></i>);</font></code></font></code><i><code><font color="#663300"><code><font color="#663300"><br>
            </font></code></font></code>F</i>=MONITOR(22,<i>n<sub>1</sub></i>);</font></code><br>
<code><font color="#663300"><code></code>
    </font></code></td>
      <td valign="middle">Calls SDF access package.<br>
</td>
      <td valign="middle">SDF stands for Simulation Data File.&nbsp; The
 "SDF access package" (SDFPKG) was a separate program, similar to the 
submonitor itself, with which the XPL/I program could communicate via <font color="#663300"><code>MONITOR(22)</code></font>.&nbsp; And like the submonitor, in the <b>XCOM-I</b>
 framework, SDFPKG equivalents are built into the runtime library rather
 than being provided by a separate SDFPKG program.&nbsp; <br>
<br>
Documentation can be found in TBD.&nbsp; There is not space for a full 
description here, so I'm only giving a brief summary; the documentation 
should be consulted for more details.<br>
<br>
The first form, <code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i><code><font color="#663300"><code><font color="#663300">=</font></code></font></code></font></code>MONITOR(22,0,<i>n</i><i><sub>2</sub></i>)</font></code></font></code></font></code>, initializes the SDFPKG functionality.&nbsp; The <code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><i>n</i><i><sub>2</sub></i></font></code></font></code></font></code> parameter points to an array of 30 <font color="#663300"><code>FIXED</code></font> values which serves as a "communications area" holding data for subsequent calls. <br>
<br>
For calls of the second form, <code><font color="#663300"><i>F</i>=MONITOR(22,<i>n<sub>1</sub></i>)</font></code>, the <code><font color="#663300"><i>n<sub>1</sub></i></font></code> parameter specifies a function number ("mode"):<br>
<ol>
  <li>Terminate SDFPKG.</li>
  <li>Augment paging area.</li>
  <li>Rescind paging area augments.</li>
  <li>Select an SDF.</li>
  <li>Locate pointer.</li>
  <li>Set disposition parameters.</li>
  <li>Locate directory root cell.</li>
  <li>Locate block data cell given block number.</li>
  <li>Locate symbol data cell given symbol number.</li>
  <li>Locate statement data cell given statement number.</li>
  <li>Locate block data cell given block name.</li>
  <li>Locate symbol data cell given block name and symbol name.</li>
  <li>Locate symbol data cell given only symbol name.</li>
  <li>Locate statement data cell given SRN.</li>
  <li>Locate block node given block number.</li>
  <li>Locate symbol node given symbol number.</li>
  <li>Locate statement node given statement number.</li>
  <li>Locate initialization data given symbol number. <br>
  </li>
  <li>Deselect an SDF.<br>
  </li>
</ol>
There's some confusion in the available software/documentation, in that 
sometimes function #19 is missing; and when #19 is missing, #18 may 
either be as shown or else may be deselection of the SDF.&nbsp; I have 
no explanation for that discrepancy.&nbsp; However, the functional 
lineup listed above is consistent with the version of HAL/S-FC source 
code we have.<br>
<br>
Additionally, the function number <code><font color="#663300"><i>n<sub>1</sub></i></font></code> may have high-order bits set, such as 0x10000006 or 0x80000007.&nbsp; The significance of that is TBD.<br>
<br>
The return code, <code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i></font></code>, for all calls is 0 upon success, or non-zero for various failures.&nbsp; See section 11 of the documentation.<br>

</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>descriptor</i>=MONITOR(23);<br>
    </font></code></td>
      <td valign="middle">Returns the <code><font color="#663300"><i>descriptor</i></font></code> of the 10-character string obtained from 
the ID field of the File Control Block of the first phase of the 
compiler.&nbsp; The ID field is maintained by the <b>XPLZAP</b> program and contains the identifying string printed on the header of each page of the HAL listing".
</td>
      <td valign="middle">I think that what the original documentation was trying to get at is that <b>HAL/S-FC</b>'s version code, printed on each of the report pages printed by <b>XCOM</b> (or now, <b>XCOM-I</b>), is given by this ID string, and that the ID string is provided to each pass of <b>HAL/S-FC</b> via a call to <code><font color="#663300">MONITOR(23)</font></code>.&nbsp; Of course, in the modern reimplementation, there is no <b>XPLZAP</b> program, and it wouldn't be compatible with <b>XCOM-I</b> if there were one.&nbsp; In <b>XCOM-I</b>, the ID string itself is by default 'REL32V0&nbsp;&nbsp; ', but it can be changed via the <b>XCOM-I</b> command-line parameter <font color="#663300"><code>--identifier</code></font>.<br>
<br>
As for what a "descriptor" is, see <a moz-do-not-send="true" href="#datatypes">the description of the CHARACTER datatype</a>.&nbsp;&nbsp; In brief, the return value is not itself the ID string, but an integer value (i.e., of the <font color="#663300"><code>FIXED</code></font> datatype) that provides an index for finding the ID string in memory. <br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(24)<br>
    </font></code></td>
      <td valign="middle">Read a block of a load module.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(25)<br>
    </font></code></td>
      <td valign="middle">Read a mass-memory load block.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(26)<br>
    </font></code></td>
      <td valign="middle">Read a MAF (memory analysis file) block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(27)<br>
    </font></code></td>
      <td valign="middle">Write a MAF block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(28)<br>
    </font></code></td>
      <td valign="middle">Link to dump analysis service routine<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(29)<br>
    </font></code></td>
      <td valign="middle">Return current page number<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(30)<br>
    </font></code></td>
      <td valign="middle">Return JFCB as string<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(31</font></code><code><font color="#663300"><code><font color="#663300">,<i>n</i></font></code>,<i>recnum</i>)<br>
    </font></code></td>
      <td valign="middle">Virtual-memory lookahead service.<br>
</td>
      <td valign="middle">This function is seemingly only used internally by the virtual-memory system.<br>
<br>
In looking at the the usage in actual XPL/I code, as well as the assembly-language source code for the submonitor (see <font color="#663300"><code>VMEMSRV</code></font> in <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM/MONITOR.bal">MONITOR.bal</a>),
 which admittedly I can only follow very imperfectly,&nbsp; it appears 
to me that this function is used in three distinct ways:<br>
<ul>
<li><font color="#663300"><code>MONITOR(31,<i>n</i>,-1)</code></font>, <font color="#663300"><code><i>n</i> &gt; 0</code></font>, sets the default file number for future <font color="#663300"><code>MONITOR(31,...)</code></font> calls to <code><font color="#663300"><code><font color="#663300"><i>n</i></font></code></font></code>.&nbsp;&nbsp;&nbsp; The default file number is initially 2.<br>
<font color="#663300"><code></code></font></li><li><font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>)</code></font> , <font color="#663300"><code><i>recnum</i> </code><code>≥ 0</code></font>, immediately initiates an operation that reads record <font color="#663300"><code><i>recnum</i></code></font> from the default file, into a memory buffer at address <font color="#663300"><code><i>bufferAddress</i></code></font>.&nbsp;
 In IBM 360 terms, that's an "XDAP" operation.&nbsp; I think it's like 
what we'd call a DMA operation now, so this read operation may take some
 time to complete, but it's a background operation while it's doing so.<br>
</li>
  <li><font color="#663300"><code>MONITOR(31,0,-1)</code></font> waits until a previously-initiated read operation on the default file has completed. <br>
  </li>
</ul>
There's an additional subtlety — really, that's astounding?! —, in that the <font color="#663300"><code><i>bufferAddress</i></code></font> in <font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>) </code></font>may
 sometimes have its most-significant bit set to 1, thus turning it into a
 negative number.&nbsp; I think in that case what happens is that the 
function waits for any background read-operation already in progress to 
complete, and then clears the sign bit of <font color="#663300"><code><i>bufferAddress</i></code></font> and commences a new read operation.<br>
<br>
The <b>XCOM-I</b> runtime library, doesn't really need any of these subtleties, so implements this function basically as immediate <font color="#663300"><code>FILE</code></font> operations, as appropriate.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(32)<br>
    </font></code></td>
      <td valign="middle">Find out subpool minimum size<br>
</td>
      <td valign="middle">The memory-allocation and -deallocation functions (<code><font color="#663300">MONITOR</font></code>
 6, 7, 19, and 20) are supposed to get their memory from something 
called "SUBPOOL 22".&nbsp; SUBPOOLs apparently have block-sizes which 
are either 2048 or 4096 bytes, depending on the operating system.&nbsp; <code><font color="#663300">MONITOR(32)</font></code>
 returns the appropriate block size for the operating system.&nbsp; 
Given that the block size is bigger in later versions of the operating 
system, I infer that bigger is better, within certain limits, and hence <b>XCOM-I</b> arbitrarily returns 4096.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(33)<br>
    </font></code></td>
      <td valign="middle">Find out FILE max REC# and BLKSIZ<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    
    
    
    
    
    
  </tbody>
</table><br>
<h1><a name="debugging"></a>Debugging XPL Programs</h1>

<p>It is admittedly unlikely that many people will be writing new XPL or
 XPL/I programs nowadays, and will instead be compiling only legacy XPL 
or XPL/I programs ... assuming that I haven't already compiled all of 
them first!  (Which is a distinct possibility.)  Since such legacy 
programs will presumably all have been debugged decades before, there's 
not as much need for a debugger as there is for computer languages in 
which there are many active developers.  Nevertheless, XPL or XPL/I 
programs can be run under a debugger to a certain extent.<br></p>
The trick is to realize that while we have no debugger for the XPL language, we do have debuggers for C, and once <b>XCOM-I</b>
 has translated XPL or XPL-I software into C, such C debuggers can be 
used.  It is merely necessary when compiling your XPL program to use the
 appropriate command-line switches for incorporating
 debugging information into the executable.&nbsp;  There are actually 
two aspects to this:&nbsp; Including the debugging aids provided by 
XCOM-I, and including the debugging information appropriate for whatever
 debugger software you're using.&nbsp; If you're using GNU <b>gdb</b> or any debugger than accepts <b>gdb</b>-style data to debug your program then, and for the sake of discussion ignoring any other options you chose to use (such as <font color="#663300"><code>CC=clang</code></font>), you'd compile your XPL program like this:<br>
<blockquote>
  <pre><font color="#663300">XCOM-I.py --xpl --debugging-aid <i>SOURCEFILE</i>.xpl<br>make EXTRA=-ggdb -C <i>SOURCEFILE</i></font></pre>
</blockquote>
However, the C compiler undoubtedly has other debugging options as well, which you might use in place of <font color="#663300"><code>-ggdb</code></font>.&nbsp;
 I won't provide advice, since if you want to do this in the first 
place, it's very likely you know more about it than I do.&nbsp; You can,
 of course, use graphical-interface front-ends for <b>gdb</b> as well, 
at least in Linux and Mac OS, though I'm at a loss as to how to do this 
in Windows because of probably having to work under MSYS2.&nbsp; There 
is a primitive but useful interface that works in MSYS2, provided 
directly by <b>gdb</b> (namely <font color="#663300"><code>gdb --tui</code></font>),
 that's a step up from its default command-line-style interface.&nbsp; 
And there are reports of people debugging MSYS2-generated programs is 
Visual Studio, although the descriptions of how to do it are greek to 
me.<br>
<br>
But debugging XPL code via its C translation is not as convenient as 
using a native XPL debugger would be.&nbsp; The principal difficulty in 
debugging the code in C vs in XPL is that <b>XCOM-I</b> doesn't model XPL variables as C variables, but rather as numerical locations in a byte-array called <font color="#663300"><code>memory</code></font>.&nbsp;
 Moreover, the format of this data in "memory" is that of the IBM 
System/360 rather than the native format of the computer on which 
debugging is being performed.&nbsp; So if you had an XPL variable called (say) <code>MYVAR</code>, neither would the debugger recognize that there was a variable called <code>MYVAR</code>,
 nor would its value be interpreted by the debugger as anything 
meaningful even if it were found. &nbsp; In my opinion these design 
choices for <b>XCOM-I</b> were are all necessary and unavoidable, 
but there's no denying that they make it trickier to use a debugger to see 
the how the values of variable change during execution.&nbsp; <br>
<br>
I have provided a few C functions in the <b>XCOM-I</b> runtime library to make it a <i>little</i> less painful to examine XPL variables within a debugger.&nbsp; You can also use the XPL <font color="#663300"><code>CALL INLINE</code></font>
 feature to directly embed calls to these functions within your program,
 without running a debugger at all, if it's more convenient for you to 
do so.<br>
<br>
The most-useful debugging functions are:<br>
<ul><li><font color="#663300"><code>char *getXPL(char *identifier)</code></font> — Returns (as a C string) the value of a single XPL variable whose name is given by the <font color="#663300"><code>identifier</code></font>.  The <font color="#663300"><code>identifier</code></font>
 string can be any identifier expression that's syntactically correct in
 XPL/I, provided that subscripts consist entirely of decimal digits, 
possibly with a leading minus sign, or else of integer XPL variables.  This includes expressions like <font color="#663300"><code>"V"</code></font>, <font color="#663300"><code>"V(5)"</code></font>, <font color="#663300"><code>"B(3).V"</code></font>, or <font color="#663300"><code>"B(I).V(-5)"</code></font>.  Recall that in XPL/I, subscripts can be applied to scalar variables.  If you are querying a <font color="#663300"><code>BASED RECORD</code></font>, then be sure to include the desired field, since while <font color="#663300"><code>getXPL</code></font> knows how to print an individual field of a <font color="#663300"><code>RECORD</code></font>, it does not know how to print a <i>collection</i> of fields such as a <font color="#663300"><code>RECORD</code></font>.  In a <b>gdb</b> console, you could use <font color="#663300"><code>getXPL</code></font> with a command like <font color="#663300"><code>print getXPL(...)</code></font>.   For example, <font color="#663300"><code>print getXPL("C1(4)")</code></font>.&nbsp; But expressions for the subscripts are not understood.<br>
</li>
<li><font color="#663300"><code>int ADDR(char *base, int bIndex, char *field, int fIndex)</code></font> — Given the name of a <font color="#663300"><code>BASED</code></font>
 variable (or 0 if none), an index into it, the name of field (or 0 if 
none), and an index into it, returns the "address"; i.e., the offset 
into the <font color="#663300"><code>memory</code></font> array.<br>
</li>
</ul>
<p>There are other runtime-library functions and debugging-aid functions
 that are useful from time to time, though the ones listed above are the
 bread-and-butter, but I won't bother describing them here until/unless 
somebody asks me about them.&nbsp; You can see them all by examining the
 file XCOM-I/runtimeC.c.<br>
</p>
<p>In using these debugging functions, note that they all require <i>mangled</i> forms of variable names and parameters of <code>PROCEDURE</code>s. <br>
</p>
<p>First, recall that XPL is case-insensitive in so far as identifiers (and 
keywords are concerned), therefore:<br>
</p>
<ul>
  <li>All XPL identifiers are automatically capitalized.<br>
  </li>
</ul>
<p>Second, <b>XCOM-I</b> wants to use identifiers in the generated C 
code which are as close to the identifiers originally used in the XPL 
code as possible, even it's only to make it easier for we mere humans to
 read and to match against the original code.&nbsp; But XPL identifiers 
can contain not only the alphanumeric characters, but also the 
characters '#', '@', and '$', which are <i>not</i> legal characters for 
identifiers in C.&nbsp; Part of the mangling process is therefore to 
make the following substitutions in identifier mangling:<br>
</p>
<ul>
  <li>'#' → 'p'</li>
  <li>'@' → 'a'</li>
  <li>'$' → 'd'</li>
</ul>
<p>Additionally, though, the underscore character ('_') is problematic 
in some C compilers.&nbsp; The worst offender I'm aware of is the <b>cl</b> compiler from Microsoft's Visual Studio.&nbsp; <a moz-do-not-send="true" href="https://learn.microsoft.com/en-us/cpp/c-language/c-identifiers?view=msvc-170">I quote directly from Microsoft</a> (emphasis mine):<br>
</p>
<blockquote><font size="-1">"<b>Don't select names for identifiers that begin</b> with two underscores or <b>with an underscore followed by an uppercase letter</b>.
 The ANSI C standard allows identifier names that begin with these 
character combinations to be reserved for compiler use. Identifiers with
 file-level scope should also not be named with an underscore and a 
lowercase letter as the first two letters. Identifier names that begin 
with these characters are also reserved. <b>By convention, Microsoft uses an underscore and an uppercase letter to begin macro names</b> and double underscores for Microsoft-specific keyword names. <b>To avoid any naming conflicts, always select identifier names that don't begin</b> with one or two underscores, or names that begin <b>with an underscore followed by an uppercase letter.</b>"</font><br>
</blockquote>
<p>There are a number of such XPL identifiers in the source code for <b>HAL/S-FC</b>, and <b>cl</b> blasts them to infinity (or beyond) if they appear as-is in the generated C code.&nbsp; To work around this problem, <b>XCOM-I</b> performs the additional automatic substitution in identifier mangling:<br>
</p>
<ul>
  <li>'_'  → 'u'</li>
</ul>
<p>Note that these four substitutions are everywhere within an identifier, and not merely in the leading character.&nbsp; <b><br>
  </b></p>
<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; Names of fields within the <code>RECORD</code> of a <code>BASED</code>
 variable are exempt from mangling.&nbsp; There's no deep reason for 
omitting the field names from the mangling process, other than that I 
forgot to do it, and it turned out to be unnecessary.&nbsp; Although 
unnecessary, I did attempt to implement it later, just for 
consistency.&nbsp; But it turned out to be tricky to do, so I chucked 
the attempt.&nbsp; </font><br>
  </p>
</blockquote>
<p>Finally, while <code>PROCEDURE</code> definitions and variable declarations can be embedded inside of <code>PROCEDURE</code>
 definitions in XPL, functionally these embedded entities all act as if 
they were globally declared.&nbsp; It is only their namespaces which are
 restricted.&nbsp; Therefore:<br>
</p>
<ul>
  <li>Mangled names are <i>prefixed</i> by the mangled names of every parent <font color="#663300"><code>PROCEDURE</code></font>,
 separated by 'x' for readability.  Perhaps an example would make this 
clearer.  Suppose your XPL source code looked like the following:</li>
</ul>
<blockquote>
  
<blockquote>
  <pre><font color="#663300">DECLARE X FIXED, Y FIXED, Z FIXED;<br></font></pre>

  
  <pre><font color="#663300">PROC1:<br>PROCEDURE(X, Y);<br>   DECLARE X FIXED, Y FIXED, Z FIXED;<br><br>   PROC2:<br>   PROCEDURE(X, Y);<br>      DECLARE X FIXED, Y FIXED, Z FIXED;<br>      ...<br>   END PROC2;<br><br>END PROC1;</font><br></pre>
</blockquote>

</blockquote>
<blockquote>
  <p>Then the mangled variable, parameter, and <font color="#663300"><code>PROCEDURE</code></font> names would be:<br></p>

  <blockquote>
  <pre><font color="#663300">X<br>Y<br>Z<br>PROC1<br>PROC1xX<br>PROC1xY<br>PROC1xZ<br>PROC1xPROC2<br>PROC1xPROC2xX<br>PROC1xPROC2xY<br>PROC1xPROC2xZ</font><br></pre>
  </blockquote>

Thus while we have lots of global and local variables and function parameters named <font color="#663300"><code>X</code></font>, <font color="#663300"><code>Y</code></font>, and <font color="#663300"><code>Z</code></font>, their mangled names are all distinct. <br>

</blockquote>

<h1>


  <a name="hooks"></a>Patches for Insertion of Arbitrary Inline Code</h1>A serious difficulty in working with XPL or XPL/I code is that they are often not 
written entirely in XPL/I, but also have insertions of inline machine code at various junctures.&nbsp; <br>
<br>
For example, <b>XCOM45</b> and <b>HAL/S-FC</b> source code both have such inlined code.&nbsp; However good 
<b>XCOM-I</b> may (or may not) be at translating XPL or XPL/I to C, it 
is not capable of inferring the intent of arbitrary assembly language, 
nor of translating such code into C with the level of reliability 
required for automating it.&nbsp;&nbsp; While it can <i>help</i> with such translation (as described in the <a moz-do-not-send="true" href="#inlines">next section</a>),
 some amount of manual intervention is still required on the part of the
 coder.&nbsp; The basic principles underlying the framework provided for
 that are discussed in this section.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; In reality, such inlined code is numerical in nature, and consists of IBM 360 <i>machine code</i>
 ... whereas the term "assembly language" implies that the insertions 
are symbolic in nature rather than just numbers.&nbsp; I'll continue to 
call the insertions BAL, because they undoubtedly began as BAL before 
somebody assembled them to determine which numerical values to 
use.&nbsp; But it is certainly technically incorrect to do so.<br>
</font>
</blockquote>Of course, one possible approach would be to replace 
offending inline code directly by C code in the XPL source-code files of
 the program being compiled, using the <b>XCOM-I</b> built-in <font color="#663300"><code>INLINE</code></font> function:<br>
<blockquote>
  <pre><font color="#663300">CALL INLINE('<i>...arbitrary C code of no more than 256 characters...</i>');</font><br></pre>
</blockquote>
In your use case, whatever that may be, perhaps that's adequate.&nbsp; 
However, the Virtual AGC Project aims to provide a way to work with 
legacy code — i.e., code from the past, rather than newly-written code 
—, and that implies being able to compile such source code as-is, 
without syntactical or functional modification to source code.&nbsp; 
Which means that from our point of view, irreversible modification of 
legacy source code is unacceptable.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; It is, of course, 
arguable the extent to which modifications are acceptable.&nbsp; The 
Virtual AGC Project allows insertion of modern comments, as long as 
modern comments are clearly distinguishable from original program 
comments.&nbsp; It has occasionally allowed clearly-commented simple 
changes of a line or two of code, when it was thought impossible for 
modern compilers to duplicate some undocumented behavior of the original
 compilers ... although improvements to the modern compilers almost 
always eventually allowed reversal of such modifications.&nbsp; My 
personal judgment is that replacement of dozens or hundreds of lines of 
code by code that's not obviously functionally identical, written in 
another language, is taking it farther than I'd like.&nbsp; Better to 
leave the source code the same, so that it's in principle verifiable by the user as being the authentic source code.</font><br>
</blockquote>
Don't worry!&nbsp; <b>XCOM-I</b> lets us satisfy these criteria.&nbsp; But to understand <i>how</i>, you need to know a 
little more about this IBM Basic Assembly Language (BAL) code that's causing the problem.<br>
<br>
Let's let a real-life example guide the discussion.&nbsp; The XPL source-code for SUNY's <b>XCOM45</b>
 program — which as you'll recall is an XPL compiler from the State 
University of New York in the mid-1970's  — contains a single block of 
19 consecutive <font color="#663300"><code>CALL INLINE</code></font> statements that we need to work around if we want to compile <i>and run</i> a version of <b>XCOM45</b> with <b>XCOM-I</b>:<br>
<blockquote>
  <pre><font color="#663300">SCAN_FINDS_END_OF:<br>   PROCEDURE(TABLE) BIT(1);<br>      DECLARE TABLE FIXED;<br>      DECLARE TRT(1) FIXED INITIAL("DD003000", "10000000");<br><br>      /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */<br>      CALL INLINE("58", 3, 0, TEXT);     /* LOAD STRING DESCRIPTOR */<br>      CALL INLINE("1B", 2, 2);           /* CLEAR REG. 2 */<br>      CALL INLINE("19", 3, 2);           /* CHECK FOR TEXT = NULL STRING */<br>      CALL INLINE("07", 8, 12);          /* RETURN FALSE IF TEXT IS NULL */<br>      CALL INLINE("8D", 2, 0, 0, 8);     /* SHIFT LENGTH FIELD TO REG. 2 */<br>      CALL INLINE("88", 3, 0, 0, 8);     /* RESTORE STRING ADDRESS  */<br>      CALL INLINE("58", 1, 0, TABLE);    /* LOAD BASE ADDRESS OF TRANS_TABLE */<br>      CALL INLINE("41", 12, 0, TRT);     /* LOAD ADDRESS OF TRT INSTRUCTION */<br>      CALL INLINE("44", 2, 0, 12, 0);    /* EXECUTE TRT INSTRUCTION */<br>      CALL INLINE("05", 12, 0);          /* LOAD BRANCH REGISTER  */<br>      CALL INLINE("47", 7, 0, 12, 18);   /* BRANCH ON CC~=0  */<br>      CALL INLINE("18", 1, 2);           /* LOAD REG. 1 WITH LENGTH(\) - 1 */<br>      CALL INLINE("41", 0, 0, 0, 1);     /* LOAD REG. 0 WITH 1  */<br>      CALL INLINE("1A", 1, 0);           /* ADD TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("1B", 3, 3);           /* PUT 0 INTO RETURN REGISTER */<br>      CALL INLINE("47", 15, 0, 12, 24);  /* BRANCH AROUND NEXT TWO INSTR*/<br>      CALL INLINE("1B", 1, 3);        /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("41", 3, 0, 0, 1);     /* LOAD 1 INTO RETURN REGISTER */<br>      CALL INLINE("50", 1, 0, CP);       /* STORE IDENTIFIER LENGTH */<br>   END SCAN_FINDS_END_OF;</font><br></pre>
</blockquote>
Actually, to be clear, <b>XCOM-I</b> will <i>compile</i> <b>XCOM45</b> 
just fine, whether we work around this embedded assembly-language stuff 
or not; the compiled program simply won't run correctly, because vital 
IBM 360 instructions will be missing in the midst of the program.&nbsp; 
As it 
happens, though, part of the process of creating the workaround <i>depends</i> on us compiling <b>XCOM45</b> in advance, without any workarounds in place.&nbsp; So let's just do that.&nbsp; In the compilation process, the XPL procedure <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> turns into a C file called SCANxSCAN_FINDS_END_OF.c that contains the following harmless but useless C representation of it:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-19 12:14:14.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>bit_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br>  ; // (0) CALL INLINE( 88, 3, 0, TEXT);<br>  ; // (1) CALL INLINE( 27, 2, 2);<br>  ; // (2) CALL INLINE( 25, 3, 2);<br>  ; // (3) CALL INLINE( 7, 8, 12);<br>  ; // (4) CALL INLINE( 141, 2, 0, 0, 8);<br>  ; // (5) CALL INLINE( 136, 3, 0, 0, 8);<br>  ; // (6) CALL INLINE( 88, 1, 0, TABLE);<br>  ; // (7) CALL INLINE( 65, 12, 0, TRT);<br>  ; // (8) CALL INLINE( 68, 2, 0, 12, 0);<br>  ; // (9) CALL INLINE( 5, 12, 0);<br>  ; // (10) CALL INLINE( 71, 7, 0, 12, 18);<br>  ; // (11) CALL INLINE( 24, 1, 2);<br>  ; // (12) CALL INLINE( 65, 0, 0, 0, 1);<br>  ; // (13) CALL INLINE( 26, 1, 0);<br>  ; // (14) CALL INLINE( 27, 3, 3);<br>  ; // (15) CALL INLINE( 71, 15, 0, 12, 24);<br>  ; // (16) CALL INLINE( 27, 1, 3);<br>  ; // (17) CALL INLINE( 65, 3, 0, 0, 1);<br>  ; // (18) CALL INLINE( 80, 1, 0, CP);<br>  return 0;<br>}</font><br></pre>
</blockquote>


Basically, <b>XCOM-I</b> has simply commented out each <font color="#663300"><code>CALL INLINE</code></font>
 statement, while replacing it with an empty statement.&nbsp; So why did
 we bother compiling it at all?&nbsp; The answer is that we want the 
parenthesized numbers that have been added to the comments!&nbsp; The 
parenthesized numbers will be the same every time we compile <b>XCOM45</b>, unless you take it upon yourself to mess us up by removing some of the <font color="#663300"><code>CALL INLINE</code></font> statements or adding new ones in the meantime.&nbsp; <b>Pro tip:</b>&nbsp; Don't do that!<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; There is even one (!) instance in <b>HAL/S-FC</b> in which there is a <font color="#663300"><code>RETURN INLINE</code></font> statement as well, and it is treated by <b>XCOM-I</b> the same way as <font color="#663300"><code>CALL INLINE</code></font>s
 are treated:&nbsp; namely, it is numbered and commented out.&nbsp; As 
it happens, </font><font size="-1"><i>A Compiler Generator</i> does not give even the slightest hint that <font color="#663300"><code>INLINE</code></font> can return a value.&nbsp; In point of fact, I don't think the value returned by the </font><font size="-1"><font color="#663300"><code>RETURN INLINE</code></font> statement in the case I mention even comes from the </font><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font> at all, but is instead generated by other means.&nbsp; Technically, I think that if you have a block of <font color="#663300"><code>CALL INLINE</code></font>s terminated by a <font color="#663300"><code>RETURN INLINE</code></font>, then whatever value happens to remain in the CPU's R0 register will be returned, regardless of where in the block of </font><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font>s</font> R0 was set up.&nbsp; But regardless of the underlying details, it demonstrates that <i>syntactically</i>, both <font color="#663300"><code>CALL INLINE</code></font> and <font color="#663300"><code>RETURN INLINE</code></font> are possible in XPL/I source code.<br>
<br>
<b>Important note:</b>&nbsp; If you must write a C-language patch-file for a block of <font color="#663300"><code>INLINE</code></font>s that include an </font><font size="-1"><font size="-1">XPL </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN INLINE(...)</code></font></font></font>, you should use the C macro <font color="#663300"><code>RETURN()</code></font> rather than simply <font color="#663300"><code>return</code></font>, or </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(<i>something</i>)</code></font></font> rather than <font color="#663300"><code>return <i>something</i></code></font>.&nbsp; That's because the </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(...)</code></font></font> macro takes into account extra code which <b>XCOM-I</b> may need to insert in conjunction with XPL </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN</code></font></font> statements.&nbsp; For example, if <b>XCOM-I</b> is run with its <font color="#663300"><code>--reentry-guard</code></font> switch, then <b>XCOM-I</b> inserts code at the entry point and exit points of each XPL <font color="#663300"><code>PROCEDURE</code></font> that allows the runtime library to detect illegal reentries.&nbsp; (Recall that recursion is illegal in XPL.)&nbsp; The </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(...)</code></font></font></font> macro handles this for you transparently, and if a simple </font><font size="-1"><font size="-1"><font color="#663300"><code>return</code></font></font> is used instead, then the runtime library will falsely detect recursion the second time any individual </font><font size="-1"><font size="-1"><font color="#663300"><code>PROCEDURE</code></font></font> is executed.<br>
  </font></blockquote>


In this particular example, since <b>XCOM45</b> has a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we were guaranteed in advance that the block would start with number 0.&nbsp; In a more-complex example like <b>HAL/S-FC</b>, there would be a number of blocks of inlines, strewn throughout the source code, and lieu of <b>XCOM-I</b>
 printing them all out for us the numbering would be 
unpredictable.&nbsp; But because the numbers never change, we can use 
them as unique, persistent identifiers for the <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<br>
Why is that important?&nbsp; The way we're going to work around the <font color="#663300"><code>CALL INLINE</code></font>
 statements is to create a series of numbered "patch files", written in 
C:&nbsp; patch0.c, patch1.c, patch2.c, and so on.&nbsp; The patch files 
are placed in the same folder that contains the source code of the XPL 
program being compiled, though <b>XCOM-I</b> does have a command-line 
option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
 that allows a different folder to be specified.&nbsp; When <b>XCOM-I</b> encounters a <font color="#663300"><code>CALL INLINE</code></font> statement, it looks for a patch file with the same number, and <i>if</i>
 it finds one, it directly inserts the contents of the patch file into 
the object code. &nbsp; If there's no matching patch file, then the <font color="#663300"><code>CALL INLINE</code></font> simply remains a comment.&nbsp; In principle, you could have a different patch file for each <font color="#663300"><code>CALL INLINE</code></font>, but it's usually more practical and more aesthetically pleasing to have a single patch file for each contiguous block of <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp; In working with the source code for <b>HAL/S-FC</b>
 specifically, it's a little more complex than what I just 
indicated.&nbsp; As I've mentioned previously, there are two different 
methods of compiling <b>HAL/S-FC</b> source code:&nbsp; One to create a compiler intended to compile Primary Flight Software (PFS) via <b>XCOM-I</b>'s <font color="#663300"><code>--cond=P</code></font> command-line switch, and one to create a compiler intended to compile Backup Flight Software (BFS) via <b>XCOM-I</b>'s <font color="#663300"><code>--cond=B</code></font> command-line switch.&nbsp; Unfortunately, the numbering of the <font color="#663300"><code>CALL INLINE</code></font>
 statements, or even the inlined code itself, can a bit different in 
these two cases, which makes it unwieldy to rely on the generic naming 
patch<i>N</i>.c for the patch files.&nbsp; My description above is what happens when neither </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=P</code></font></font> nor </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=B</code></font></font> is used.&nbsp; But if </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=P</code></font></font> is used, then <b>XCOM-I</b> actually looks for patch files with names like patch<i>N</i>p.c first, falling back to patch<i>N</i>.c if patch<i>N</i>p.c isn't found.&nbsp; And similarly, if </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>--cond=B</code></font></font></font> is used, it prefers patch files named patch<i>N</i>b.c, falling back to patch<i>N</i>.c.&nbsp; This method allows the generic names patch<i>N</i>.c to be used up the point at which the numbering of the </font><font size="-1"><font color="#663300"><code>INLINE</code></font>'s begins to differ, switching to the patch<i>N</i>p.c/patch<i>N</i>b.c naming thereafter, without any ambiguity or conflicts between the two.</font><br>
</blockquote>


In this real-life example, since there's a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we need a single patch file, patch0.c.<br>

<blockquote>
  <pre><font color="#663300">/*<br> * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br> * by XCOM-I.py.<br> *<br> * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br> * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br> * the entire xcom4 program.<br> *<br> * What the procedure does is this:  It's given the address of a "translation<br> * table" of one of the following types:<br> *      `BLANKTABLE`  (Blanks)<br> *      `ALPHATABLE`  (Identifier)<br> *      `STRINGTABLE` (Quoted string)<br> *      `COMMENTABLE` (Comment)<br> * Starting at position `CP=0` (already set up upon entry so that we know the<br> * first character is of the asked-for type) in the string `TEXT`, searches<br> * for the end of the pattern of the selected type, and updates `CP` to the<br> * length of the found string.  It returns 0 on failure and 1 on success.  An<br> * empty string counts as a failure.<br> *<br> * This was apparently coded in BAL because the IBM 360 has a translation-table<br> * instruction, TRT, that does this efficiently.  But from my perspective,<br> * considering that there's no other embedded BAL code in the entire program,<br> * it seems as though it's a big price to pay, maintenance-wise and<br> * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br> * always make assembly-language go faster than a high-level language; this is<br> * news?<br> */<br><br>static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>      *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>char *s, *TEXT;<br>uint32_t TABLE;<br><br>if (mapCP == NULL)<br>  {<br>    mapCP = lookupVariable("CP");<br>    mapTEXT = lookupVariable("TEXT");<br>    mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>    mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>    mapALPHATABLE = lookupVariable("ALPHATABLE");<br>    mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>    mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>  }<br><br>TABLE = getFIXED(mapTABLE-&gt;address);<br>TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br><br>if (*TEXT == 0)<br>  return fixedToBit(1, 0);<br>if (TABLE == mapBLANKTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>  }<br>else if (TABLE == mapALPHATABLE-&gt;address)<br>  {<br>    for (s = TEXT;<br>         isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>         s++);<br>  }<br>else if (TABLE == mapSTRINGTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br><br>  }<br>else if (TABLE == mapCOMMENTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>  }<br>else<br>  abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>if (*s == 0)<br>  {<br>    putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>    return fixedToBit(1, 0);<br>  }<br>putFIXED(mapCP-&gt;address, s - TEXT);<br>return fixedToBit(1, 1);<br></font></pre><font size="-1"><b>Aside:</b>&nbsp;
 The patch file given above uses a technique that I consider a bit 
obsolete.&nbsp; In it, I wrote C code that I thought expressed the same <i>intent</i>
 as the inline assembly-language it was replacing.&nbsp; It's fine to do
 that!&nbsp; But after a while I found that technique a bit wearing and 
error-prone, not to mention time-consuming when there are dozens of 
patches to consider.&nbsp; Nowadays, I would be much more likely to 
write C code that slavishly mimics each assembly-language instruction 
individually, without worrying much about the intent of the instruction 
being replaced.&nbsp; It is more efficient to do this than it may appear
 at first glance.&nbsp; More on this later.</font><br>

</blockquote>

Now that we actually have a patch file, when <b>XCOM-I</b> again compiles <b>XCOM45</b>, the <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> procedure is now translated to the following C code:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-25 14:05:21.<br>*/<br><br>#include "runtimeC.h"<br><br>descriptor_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br><br>  { // (0) CALL INLINE ( 88, 3, 0,TEXT);<br>    /*<br>     * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br>     * by XCOM-I.py.<br>     *<br>     * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br>     * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br>     * the entire xcom4 program.<br>     *<br>     * What the procedure does is this:  It's given the address of a "translation<br>     * table" of one of the following types:<br>     *      `BLANKTABLE`  (Blanks)<br>     *      `ALPHATABLE`  (Identifier)<br>     *      `STRINGTABLE` (Quoted string)<br>     *      `COMMENTABLE` (Comment)<br>     * Starting at position `CP=0` (already set up upon entry so that we know the<br>     * first character is of the asked-for type) in the string `TEXT`, searches<br>     * for the end of the pattern of the selected type, and updates `CP` to the<br>     * length of the found string.  It returns 0 on failure and 1 on success.  An<br>     * empty string counts as a failure.<br>     *<br>     * This was apparently coded in BAL because the IBM 360 has a translation-table<br>     * instruction, TRT, that does this efficiently.  But from my perspective,<br>     * considering that there's no other embedded BAL code in the entire program,<br>     * it seems as though it's a big price to pay, maintenance-wise and<br>     * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br>     * always make assembly-language go faster than a high-level language; this is<br>     * news?<br>     */<br>    <br>    static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>          *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>    char *s, *TEXT;<br>    uint32_t TABLE;<br>    <br>    if (mapCP == NULL)<br>      {<br>        mapCP = lookupVariable("CP");<br>        mapTEXT = lookupVariable("TEXT");<br>        mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>        mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>        mapALPHATABLE = lookupVariable("ALPHATABLE");<br>        mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>        mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>      }<br>    <br>    TABLE = getFIXED(mapTABLE-&gt;address);<br>    TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br>    <br>    if (*TEXT == 0)<br>      return fixedToBit(1, 0);<br>    if (TABLE == mapBLANKTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>      }<br>    else if (TABLE == mapALPHATABLE-&gt;address)<br>      {<br>        for (s = TEXT;<br>             isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>             s++);<br>      }<br>    else if (TABLE == mapSTRINGTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br>    <br>      }<br>    else if (TABLE == mapCOMMENTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>      }<br>    else<br>      abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>    if (*s == 0)<br>      {<br>        putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>        return fixedToBit(1, 0);<br>      }<br>    putFIXED(mapCP-&gt;address, s - TEXT);<br>    return fixedToBit(1, 1);<br>  }<br>  ; // (1) CALL INLINE ( 27, 2, 2);<br>  ; // (2) CALL INLINE ( 25, 3, 2);<br>  ; // (3) CALL INLINE ( 7, 8, 12);<br>  ; // (4) CALL INLINE ( 141, 2, 0,0,8);<br>  ; // (5) CALL INLINE ( 136, 3, 0,0,8);<br>  ; // (6) CALL INLINE ( 88, 1, 0,TABLE);<br>  ; // (7) CALL INLINE ( 65, 12, 0,TRT);<br>  ; // (8) CALL INLINE ( 68, 2, 0,12,0);<br>  ; // (9) CALL INLINE ( 5, 12, 0);<br>  ; // (10) CALL INLINE ( 71, 7, 0,12,18);<br>  ; // (11) CALL INLINE ( 24, 1, 2);<br>  ; // (12) CALL INLINE ( 65, 0, 0,0,1);<br>  ; // (13) CALL INLINE ( 26, 1, 0);<br>  ; // (14) CALL INLINE ( 27, 3, 3);<br>  ; // (15) CALL INLINE ( 71, 15, 0,12,24);<br>  ; // (16) CALL INLINE ( 27, 1, 3);<br>  ; // (17) CALL INLINE ( 65, 3, 0,0,1);<br>  ; // (18) CALL INLINE ( 80, 1, 0,CP);<br>  return 0;<br>}<br></font><br></pre>
</blockquote>
Notice that the patch is <i>automatically</i> placed within a C <font color="#663300"><code>{...}</code></font> block, which is important if the <font color="#663333"><code>CALL INLINE(...)</code></font> happens to have been preceded by something like <code><font color="#663300">IF ... THEN</font></code> or <font color="#663300"><code>ELSE</code></font>. <br>
<h1><a name="inlines"></a>More on IBM System/360 Inline Code<br>
</h1>
<p>Let's start with the executive summary: <br>
</p>
<p>In this section, we revisit the problem of inline machine code discussed in <a moz-do-not-send="true" href="#hooks">the preceding section</a>, describing a tool that may be of assistance in writing patch files for IBM System/360 inline code.&nbsp; In brief, if you run <b>XCOM-I</b> with the command-line switch <font color="#663300"><code>--guess=-1</code></font>,&nbsp; it will create a set of files (guess*.c) that are <b>XCOM-I</b>'s best guess of what the patch-files (patch*.c) should be like.&nbsp; (You can also use <font color="#663300"><code>--guess=<i>N</i><i><sub>1</sub></i>,<i>N</i><sub><i>2</i></sub>,<i>N<sub>3</sub></i>,...</code></font> to generate just the files for specific patch numbers, whereas -1 generates <i>every</i>
 patch.)&nbsp; You can then manually tweak these "guessed" files with 
(hopefully!) much-reduced effort to get patch-files you're satisfied 
with.&nbsp; There are three ways in which this guessing facility is 
known to fail,&nbsp; and thus to require manual fixes:<br>
</p>
<ol>
  <li>Only the IBM 360 instructions I've actually encountered in legacy XPL programs (specifically, <b>XCOM3</b>, <b>XCOM4</b>, and <b>HAL/S-FC</b>)
 are supported.&nbsp; At this writing, that's about ~10% of the full IBM
 360 instruction set.&nbsp; So the guesser will not understand anything 
about the 90% of possible-but-currently-unused instruction types.<br>
</li>
  <li>Self-modifying code, or pseudo-self-modifying code due to the use of the IBM 360 instruction EX, will not work properly.&nbsp;
 Translations of the EX instruction are specifically detected and marked
 with a comment of "***FIXME***".&nbsp; In my experience, most manual 
tweaks are related to these EX instructions, and specifically to the use
 of EX to execute modified MVC instructions; this is covered in more 
detail later.<br>
  </li>
  <li>Code which accesses or modifies CPU registers associated with subroutine linkage requires attention, because <b>XCOM-I</b> does <i>not</i>
 set up these registers upon entry to a procedure, nor does it use the 
contents of these registers upon exit from a procedure.&nbsp; Or more 
succinctly, C translations of XPL procedures do not follow IBM 360 
calling conventions.&nbsp; This is rare problem in my experience, but it does occur occasionally.<br>
  </li>
</ol>
<p>That's the summary, which may be everything you actually need to know.&nbsp; Here's the longer explanation.<br>
</p>
Having now gone through the process of manually writing many patch files
 for IBM 360 inline code, I've come to realize that I had overestimated 
the difficulty of translating that inline code to C code.&nbsp; With 
experience, I've now observed that:
<ul>
  <li>The number of different IBM 360 instructions used in these is very
 limited, with just a handful of mostly-simple instructions making up 
the bulk of them.</li>
  <li>All those instructions do is to read and write to memory and to a 
subset of the CPU's general registers, floating-point registers, and 
the condition-code register.<br>
  </li>
  <li>And, of those particular CPU registers inlined in legacy XPL or XPL/I code, you can <i>mostly</i> assume that there are no side effects associated with doing so.</li>
</ul>
As part of a systematic framework for exploiting this, the <b>XCOM-I</b> the runtime library defines the IBM 360 CPU registers as the following global variables:
<blockquote>
  <pre><font color="#663300">int32_t GR[16]; // CPU general-purpose registers.<br>double FR[16];  // CPU floating-point registers.<br></font><font color="#663300">uint8_t CC; // CPU condition code register. Only the least two bits are significant.</font><br></pre>
</blockquote>
<blockquote>
  <p><font size="-1"><b>Aside:</b> If unlike me you're actually familiar
 with IBM 360 programming, I'm sure you'll call the CPU's 
general-purpose registers R0, R1, R2, and so on.&nbsp; IBM documentation
 calls them that.&nbsp; It also calls the floating-point registers, 
which are completely separate and independent of the general-purpose 
registers,
 by those very same names:&nbsp; R0, R1, R2, ....&nbsp; Perhaps it's 
just me, but I found that confusing.&nbsp; And because I was so stupid 
as to be confused by this <i>apparently</i> obvious and trivial point, 
it has cost me considerable amount of time.&nbsp; Consequently, I now 
make a point of calling the general-purpose registers GR<i>n</i> and the floating-point registers FR<i>n</i>.&nbsp;
 Yes, it's a departure from tradition.&nbsp; No, in this particular case
 I don't care that I've departed from tradition.&nbsp; A foolish 
consistency is the hobgoblin of little minds.</font><br>
  </p>
</blockquote>
<p>Meanwhile, memory can always be accessed and/or converted from IBM 360 formats to native C formats, also via <b>XCOM-I</b> runtime-library features:<br>
</p>
<ul>
  <li><font color="#663300"><code>uint8_t memory[0x1000000]</code></font> — for reading and writing 8-bit bytes from/to memory.</li>
  <li><font color="#663300"><code>int32_t COREWORD(uint32_t <i>address</i>)</code></font> and <font color="#663300"><code>void COREWORD2(uint32_t <i>address</i>, int32_t <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for reading and writing 32-bit words from/to memory, respectively.</li>
  <li><font color="#663300"><code>int16_t COREHALFWORD(uint32_t <i>address</i>)</code></font> and <font color="#663300"><code>void COREHALFWORD2(uint32_t <i>address</i>, int16_t <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for reading and writing 16-bit half-words from/to memory, respectively.</li>
  <li><font color="#663300"><code>double fromFloatIBM(uint32_t <i>msw</i>, uint32_t <i>lsw</i>)</code></font> and <font color="#663300"><code>void toFloatIBM(uint32_t *<i>msw</i>, uint32_t *<i>lsw</i>, double <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for converting pairs of 32-bit words to/from C double-precision floats, respectively.</li>
  <li><font color="#663300"><code>void setCC(void)</code></font> and <font color="#663300"><code>void setCCd(void)</code></font> <font color="#663300"><code></code></font> — for adjusting the condition-code register after integer operations or floating-point operations, respectively.<br>
  </li>
</ul>
<p>Additional globals are provided by the runtime library for holding commonly-needed temporary results:<br>
</p>
<blockquote>
  <pre><font color="#663300">int32_t address360A, address360B, dsw360, lsw360;<br>int64_t scratch;   // Results of integer operations; input to setCC (see above).<br>double scratchd;   // Results of floating-point operations; input to setCCd (see above).<br>int64_t dummy360;  // Use for anything you like.<br>double dummy360d; </font><font color="#663300"><font color="#663300"> // Use for anything you like.</font>
double epsilon360; // A small number, used for tolerance in some floating-point comparisons.<br></font></pre>
</blockquote>
For floating-point operations, native C formats and arithmetical 
operators are used.&nbsp; Conversion from/to IBM hexadecimal format 
occurs only when floating-point values are read from the memory array or
 written into the <font color="#663300"><code>memory</code></font> array.&nbsp; This is why the CPU's 
floating-point registers are modeled as the C <font color="#663300"><code>double</code></font> type.&nbsp; The alternative would have been to model them as pairs of <font color="#663300"><code>uint32_t</code></font>
 values, and to provide C functions that directly implemented exact IBM 
360 arithmetic (like addition, subtraction, and so on) directly upon 
such pairs.&nbsp; I admit that wisdom of my decision is arguable, but 
have no present plans to change the implementation.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Actually, there is one 
case in which this decision to use C floating-point causes problems, and that involves the IBM 
360 instructions which perform "unnormalized" floating-point 
arithmetic.&nbsp; Recall that floating-point numbers have two parts, the
 <i>exponent</i> and the <i>significand</i>.&nbsp; For example, in 3.14156×<sup><super>10</super></sup>,
 the exponent is 10 and the significand is 3.14156. &nbsp; Almost all 
floating-point arithmetic on the IBM 360 is in "normalized" form, which 
means that the exponent and significant are adjusted so as to produce 
the maximum precision (number of bits) in the significand, given the 
number of bytes of storage allocated for the number in memory and the 
nature of the format used for storage.&nbsp; Thus in principle, 3.14156×<sup><super>10</super></sup> is more precise than 0.03142×<sup><super>12</super></sup>, and is less precise than 314.15654×<sup><super>8</super></sup>.&nbsp;
 In the case of IBM hexadecimal floating-point, the exponent field is 7 
bits wide and represents a power of 64 (rather than 10), and is offset 
by 64.&nbsp; I.e., if the exponent is (say) E, then the powers 
represented are 64<sup>-64</sup> through 64<sup>+63</sup>.&nbsp; The 
significand, meanwhile, is 56 bits wide and always positive, since 
there's a separate sign bit&nbsp; So in principle, an IBM hexadecimal 
double-precision floating-point number could represent exact positive or
 negative 56-bit integers.&nbsp; That'll be important in a minute.<br>
    <br>
Supplementing the instructions for normalized arithmetic, the IBM 360 includes instructions for both <i>unnormalized</i>
 addition and subtraction as well, which means they perform the 
indicated operations, but the results are taken as-is, without any 
normalization.&nbsp; Whereas the choice to use C <font color="#663300"><code>double</code></font> for all arithmetic in the <b>XCOM-I</b> framework means that all arithmetical results have maximum precision all the time.<br>
    <br>
Doesn't sound like a problem to you?&nbsp; Well, in practice <font color="#663300"><code>CALL INLINE</code></font>
 code uses a single unnormalized instruction, namely <font color="#663300"><code>AW</code></font>, which adds two 
floating-point numbers (normalized or unnormalized), producing an 
unnormalized result.&nbsp; It always does so in precisely the same 
manner, in order to perform the trick of converting a positive 
floating-point number (in IBM hexadeximal format) to a binary 
integer.&nbsp; In assembly language, that trick works as follows:<br>
  </font>
  <ul>
    <li><font size="-1">Somewhere — in <b>HAL/S-FC</b>, it's in the floating-point working area <font color="#663300"><code>DW(6)</code></font> and <font color="#663300"><code>DW(7)</code></font>, pointed to by the variable <font color="#663300"><code>ADDR_FIXER</code></font>
  — a representation of the number 0.0 is stored as the pair of words 
0x4E000000,0x00000000.&nbsp; (Note that there's no unique representation
 of 0.0 in IBM hexadecimal floating point, because the exponent is 
indeterminate when the signifcand is 0, but this particular choice of 
exponent is important.)</font></li>
    <li><font size="-1"><font color="#663300"><code>AW</code></font> is used to perform an unnormalized addition of the </font><font size="-1"><font size="-1"><font color="#663300"><code>ADDR_FIXER</code></font></font> representation 0.0 with a non-negative floating-point number that represents an integer.</font></li>
    <li><font size="-1">The unnormalized result of the addition has an 
exponent field that's 0x4E and a significand that's a non-negative 
56-bit binary integer.&nbsp; Specifically, the least-significant word is
 the least-significant 32 bits of the integer.<br>
      </font></li>
    <li><font size="-1">The least-significant word, being the desired <font color="#663300"><code>FIXED</code></font>
 data, is immediately stored someplace via the IBM 360 instruction <font color="#663300"><code>STD </code></font>
for whatever further use the program has for that integer.<br>
      </font></li>
  </ul>
  <p><font size="-1">You probably don't care, but the reason this trick 
works is that IBM floating-point addition functions by unnormalizing the
 operand with the smaller exponent to match the exponent of the other 
operand, and then performing a binary addition of the 
significands.&nbsp; But no 56-bit integer can have an exponent in IBM 
hexadecimal format that's larger than 0x4E, so the representation of 0.0
 to have an exponent of 0x4E guarantees that it's the other operand that
 becomes unnormalized, and the way in which it's unnormalized is to be 
shifted rightward by exactly the right number of bits to turn into a 
binary representation of the integer.<br>
    </font></p>
  <p><font size="-1">Regardless of how it works, the reason this causes 
us a problem is that the native-C arithmetic we perform doesn't track 
any of this, so the </font><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font> is wasted, and <i>doesn't</i> produce an integer 
usable by the </font><font size="-1"><font size="-1"><font color="#663300"><code>STD</code></font></font> instructions that succeed the </font><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font> instructions.&nbsp; 
In other words, after the </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font></font> occurs, the <font color="#663300"><code>CALL INLINE</code></font> for the </font><font size="-1"><font size="-1"><font color="#663300"><code>STD</code></font></font> instruction that's supposed to store the 2's-complement integer has no 2's-complement integer to store!<br>
    </font></p>
  <p><font size="-1">The workaround for this in the <b>XCOM-I</b> 
runtime library is that the floating-point registers are supplemented 
by an additional array that tracks whether the register should be 
treated as normalized or unnormalized, and then interprets the value 
stored in that floating-point register accordingly when an </font><font size="-1"><font size="-1"><font color="#663300"><code>STD</code></font></font>
instruction is performed that stores the value in the register to 
memory:<br>
    </font></p>
  <blockquote>
    <pre><font size="-1" color="#663300">double FR[16];<br>uint8_t unnormFR[16]; // 0 to treat FRn as normalized, 1 as unnormalized.<br></font></pre>
  </blockquote>
  <p><font size="-1">Thus an </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font></font> instruction on <font color="#663300"><code>FR[<i>n</i>]</code></font> sets <font color="#663300"><code>unnormFR[<i>n</i>]</code></font>, while an </font><font size="-1"><font size="-1"><font color="#663300"><code>STD</code></font></font></font><font size="-1"> instruction storing </font><font size="-1"><font size="-1"><font color="#663300"><code>FR[<i>n</i>]</code></font></font> resets </font><font size="-1"><font size="-1"><font color="#663300"><code>unnormFR[<i>n</i>]</code></font></font>.<br>
&nbsp;<br>
Yes, it's a bit of a hack, and if you were writing new <font color="#663300"><code>CALL INLINE</code></font> statements you could easily defeat it, but <i>for right now</i>
 it seems more economical than reworking the entire floating-point 
arithemetic system for a handful (less than 10) of uses of </font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font></font></font>.&nbsp; My 
advice to you is this:&nbsp; If you're writing new XPL code, <i>don't</i> try to subvert my hack with perverted usage of the </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font></font> instruction in </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font> statements; </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>AW</code></font></font></font> (and </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font>, for that matter) is perverted enough already, and doesn't need <i>your</i> help.</font><br>
  </p>
</blockquote>
Let's get the question of IBM 360 
calling conventions out of the way.&nbsp; The conventional usage of the 
IBM 360 CPU's 
general registers in calling subroutines, as I understand it, is 
summarized in the bullet list below.&nbsp; But I've added a couple of 
apparently non-traditional extensions or differences (highlighted in <font color="#006600">green</font>) that I've inferred from some of the <font color="#663300"><code>CALL INLINE</code></font> statements I've encountered in the legacy code; take them with a grain of salt!<br>
<ul>
  <li>GR0 — Upon exit holds the return value.</li>
  <li>GR1 — Upon entry, holds the parameter (if there's only one) or else a pointer to a list of parameters.</li>
  <li><font color="#006600">GR3 — Upon exit holds the return value (<i>rather</i> than GR0).</font></li>
  <li><font color="#006600">GR12 </font><font color="#006600">— Upon 
entry holds the address at the end of the procedure's explicit code 
(prior to whatever linkage executes the actual return).<br>
    </font></li>
  <li>GR13 — Upon entry and exit, holds the address of an 18-word save 
area which holds the state (i.e., the general registers and other 
information) of the calling code. A procedure doesn't modify the 
contents of this save area, and must provide a different save area 
address to any procedures it calls itself<br>
  </li>
  <li>GR14 — Upon entry, holds the return address.</li>
  <li>GR15 — Upon entry, holds the beginning address of the procedure itself.<br>
  </li>
</ul>


<p>As for how a translation from IBM 360 machine code to C uses the 
various concepts described above, consider the very common statement <font color="#663300"><code>CALL INLINE("58", <i>n</i>, <i>v</i>)</code></font>, where <i><font color="#663300"><code>n</code></font></i> is a an integer 0-15 and <i><font color="#663300"><code>v</code></font></i>
 is the name of an XPL variable.&nbsp; This inline has IBM 360 opcode 
0x58, which has the assembly-language mnemonic L, and means to load 
register <font color="#663300"><code>GR[<i>n</i>]</code></font> with the contents of variable <i><font color="#663300"><code>v</code></font></i>.&nbsp; Such an inline can be translated into C as:<br>
</p>
<blockquote>
  <pre><font color="#663300">GR[<i>n</i>] = COREWORD(ADDR(<i>v</i>));</font><br></pre>
</blockquote>

Or consider <font color="#663300"><code>CALL INLINE("41", <i>n</i>, <i>v</i>)</code><font color="#000000">, which has the mnemonic LA, to store the address of the variable into the register:</font></font><br>
<blockquote>
  <pre><font color="#663300">GR[<i>n</i>] = ADDR(<i>v</i>);</font><br></pre>
</blockquote>


<font color="#663300"><font color="#000000">Or </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>CALL INLINE("50", <i>n</i>, <i>v</i>)</code><font color="#000000">, mnemonic ST, </font></font>to store the value of a register into a variable:<br>
  </font></font>
<blockquote>
  <pre><font color="#663300">COREWORD2(ADDR(<i>v</i>), GR[<i>n</i>]);</font><br></pre>
</blockquote>
In the 19-instruction patch used in the preceding section as an example,
 6 of the instructions used are already of one or the other of these 
three types.&nbsp; Other instructions may have much-more-complex 
implementations in C than these, of course.<br>
<br>
Recognizing that the majority of all <font color="#663300"><code>CALL INLINE</code></font> statements — though unfortunately not <i>all</i> of them — can be handled using these simple maneuvers, <b>XCOM-I</b> has a built-in tool that can create guessed versions of patch-files for you, in which most of the <font color="#663300"><code>INLINE</code></font>s have been translated, but with the ones that were too difficult for <b>XCOM-I</b> to handle left in the draft files for you to manually perfect.<br>
<br>
To use this tool, simply run <b>XCOM-I</b> as normal, using either or neither of the <font color="#663300"><code>--cond=P</code></font> or <font color="#663300"><code>--cond=B</code></font> options, <i>plus</i> the <font color="#663300"><code>--guess=...</code></font> switch as I summarized it earlier.&nbsp; When doing so, in addition to the normal compilation outputs, files named guess<i>N</i>.c, guess<i>N</i>p.c, or guess<i>N</i>b.c
 are output as well.&nbsp; You can then make manual changes to the 
guess-files and rename them as patch-files when you're satisfied.<br>
<br>
Regarding the effectiveness of the procedure, in the combined source code for the XPL programs <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>, there's a total of 81 blocks of <font color="#663300"><code>CALL INLINE</code></font>s, and thus in principle a total of 81 patch files.&nbsp; In generating guess-files for these programs, <b>XCOM-I</b> flags 11 of those guess-files with the comment <font color="#663300"><code>***FIXME***</code></font>, which you can easily search for in order to fix the associated issue.&nbsp; Problems <i>not</i> detectable by <font color="#663300"><code>--guess</code></font>, though rare, unfortunately are neither marked nor easy to find or fix.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Regarding the process of manually fixing up the </font><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font> instructions not supported by <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font>, it's actually not that hard once you understand the trick involved.&nbsp; Admittedly, <i>right now</i> it will seem simpler to me than to you, given our relative positions on this particular learning curve.<br>
    <br>
An <font color="#663300"><code>EX</code></font> instruction is syntactically of the form<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">EX	R1,D2(X2,B2)</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">where <font color="#663300"><code>R1</code></font> is the number of a CPU general register, and 
<font color="#663300"><code>D2(X2,B2)</code></font> points to an IBM 360 machine code instruction.&nbsp; While it 
looks confusing, it's always easy to figure out which instruction is 
targeted, because in the XPL source code it will be set off by itself 
and there will be no way to reach it in C to execute it directly.&nbsp; 
Sometimes, the XPL source code will contain a binary representation of 
that target instruction, which makes the task a lot harder for you, but 
in the XPL I've seen it will almost always be represented as a <font color="#663300"><code>CALL INLINE</code></font>, which makes it much easier.&nbsp; The reason it's easy is because <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font>
 will have made a guessed patch file for it, and will have printed the 
assembly-language syntax and the proposed C translation of it for you in
 the patch file.&nbsp; <br>
    <br>
To make what I'm saying concrete, consider an example taken from <b>PASS1</b> of <b>HAL/S-FC</b>.&nbsp; Here's a small excerpt of the XPL source-code file HALINCL/VMEM.xpl:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">         ELSE DO;                                                               00102100<br>            ADDRTEMP = ADDR(MOVECHAR);                                          00102200<br>            CALL INLINE("18",0,4);           /* LR 0,4                        */00102300<br>            CALL INLINE("58",2,0,INTO);      /* L  2,INTO                     */00102400<br>            CALL INLINE("58",3,0,FROM);      /* L   3,FROM                    */00102500<br>            CALL INLINE("48",1,0,LEGNTH);    /* LH 1,LEGNTH                   */00102600<br>            CALL INLINE("06",1,0);           /* BCTR 1,0                      */00102700<br>            CALL INLINE("58",4,0,ADDRTEMP);  /* L 4,ADDRTEMP                  */00102800<br>            CALL INLINE("44",1,0,4,0);       /* EX 1,0(0,4)                   */00102900<br>            CALL INLINE("18",4,0);           /* LR 4,0                        */00103000<br>            RETURN;                                                             00103100<br>         END;                                                                   00103200<br>      END;                                                                      00103300<br>MOVECHAR:                                                                       00103400<br>      CALL INLINE("D2",0,0,2,0,3,0);  /* MVC 0(0,2),0(3)                      */00103500</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1"><font size="-1">Those blocks of <font color="#663300"><code>CALL INLINE</code></font> statements correspond to patches 25 and 32 respectively.&nbsp; Thus <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font></font>
 produces guessed patch files guess25p.c for lines 00102300-00103000 and
 guess32p.c for line 00103500.&nbsp; The latter is the target 
instruction for the </font><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font> instruction at line 00102900.&nbsp; It's visually
 obvious (since it's separated!), but you can tell it from reading the 
code too:&nbsp; Line 00102200 puts the address of the label <font color="#663300"><code>MOVECHAR</code></font> into the variable <font color="#663300"><code>ADDRTEMP</code></font>,
 while line 00102800 it moves it into the CPU general register </font><font size="-1"><font size="-1"><code>GR4</code></font>, and 
then at line 00102900 the </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font></font> instruction says that the base register <code>GR4</code>
 holds the address of the target instruction.&nbsp; Here's how <b>XCOM-I</b> has done its best in guess25p.c to translate the </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font></font> instruction,<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#009900">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>    // ***FIXME*** Unsupported opcode EX</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">and in guess32p.c the target instruction,<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">p32_0: ;<br>  // (32)       CALL INLINE("D2", 0, 0, 1, 1, 1, 0);  /* MVC 1(0,1),0(1)       */         <br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, 0);</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">In fact, in my experience, most </font><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font> instructions have 
targeted </font><font size="-1"><font color="#663300"><code>MVC</code></font></font><font size="-1"> instructions, as this example does, so this is great for 
covering the typical case! <br>
    <br>
Now, the action of an </font><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font> instruction is to replace bits 8-15 of the 
target machine-code instruction by the contents of the general register 
the </font><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font> instruction specifies, and then to execute that modified target 
instruction (<i>without</i> actually jumping to it).&nbsp; All you have 
to figure out is what in the C translation of the target instruction 
corresponds to bits 8-15 of the machine code.&nbsp; It will usually be 
something simple.&nbsp; For a target <font color="#663300"><code>MVC</code></font> instruction, I can tell you 
that it's just the final parameter of the <font color="#663300"><code>mvc(...)</code></font>
 function in the C translation.&nbsp; Thus, the change needed to the 
guessed file guess25p.c, in which the "***FIXME***" is replaced by 
actually-executable code, is this:<br>
  </font>
  <blockquote><font size="-1">
  </font><pre><font color="#009900"><font size="-1">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, GR[2]);</font>
</font></pre></blockquote>
</blockquote>

Not perfect, of course, but not bad either.&nbsp; By my reckoning, close
 to 90% of the guessed files seem to be perfect as-is.&nbsp;&nbsp;&nbsp;
 And of the files which are not perfect, probably around 90% of the <font color="#663300"><code>CALL INLINE</code></font>s translated in those files are still perfect.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; As an example where <b>XCOM-I</b> fails to produce a perfect guessed result <i>not</i> due to an <font color="#663300"><code>EX</code></font> instruction, I can point to the single block of <font color="#663300"><code>CALL INLINE</code></font>s in the legacy program <b>XCOM45</b>.&nbsp;
 A number of its instructions involve use of the seemingly-uninitialized
 register GR12, as well as usage of the register </font><font size="-1"><font size="-1"><font color="#663300"><code>GR3</code></font></font>, that make sense 
(to me!) only if registers </font><font size="-1"><font size="-1"><font color="#663300"><code>GR3</code></font></font> and </font><font size="-1"><font size="-1"><font color="#663300"><code>GR12</code></font></font> are viewed as having a 
non-traditional conventional role in the subroutine linkage for calling 
their parent procedure (namely, <font color="#663300"><code>SCAN_FINDS_END_OF</code></font>):&nbsp;
 i.e., <font color="#663300"><code>GR3</code></font> contains the return value of the procedure (rather than </font><font size="-1"><font size="-1"><font color="#663300"><code>GR0</code></font></font>
as documented by IBM), and </font><font size="-1"><font size="-1"><font color="#663300"><code>GR12</code></font></font> contains the size of the procedure's 
code (other than the linkage code), in bytes.<br>
    <br>
  </font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1">As another example, I'd point to the one case I know of (in the <font color="#663300"><code>INTEGER_VALUED</code></font> procedure of program <b>HAL/S-FC</b>) in which a <code><font color="#663300">RETURN</font></code></font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code> INLINE</code></font> statement is used rather than a </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font> statement.&nbsp; The </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font></font></font></font></font></font></font></font></font></font></font></font> XPL built-in is not specified in such a way as to return a value, but the calling procedure (<font color="#663300"><code>INTEGER_VALUE</code></font>) does check the returned value. &nbsp; Moreover, the </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font>s in </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INTEGER_VALUED</code></font></font></font></font></font></font></font>
 do in fact manipulate the </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>GR3</code></font></font> register in such a way as to contain 
either a 0 or a 1, without there being any other evident reason to do 
so, so it's easy to suppose once again that </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>GR3</code></font></font> is indeed the return 
value.&nbsp; </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><br>
            </font></font></font></font></font></font></blockquote>
<h1>
  <a name="appendix"></a>Appendix:&nbsp; Suitable C Compilers</h1>
<p>Since <b>XCOM-I</b> is merely a translator from the XPL or XPL/I 
languages to C, it's necessary to have a functioning, compatible C 
compiler to use <b>XCOM-I</b> in its intended way.&nbsp; In theory, any reasonably-modern C compiler should be compatible with the C code <b>XCOM-I</b> produces.&nbsp; However, the nature of the <b>XCOM-I</b>
 runtime library is that it must necessarily provide some services that 
are system-dependent, and thus it is in the runtime library that there 
is is a much higher likelihood of finding C compatibility problems.<br>
</p>
<p>While bugs in <b>XCOM-I</b> itself are under my control and can in 
principle be fixed, within the limits of my skill and time, problems 
with C compilers themselves (or with their libraries) are outside of my 
control.&nbsp; Here I'll let you know what some of those problems with C
 compilers are.&nbsp; However, I'm in no position to try every C 
compiler everywhere, so my coverage is hardly extensive.&nbsp; At best, I
 can let you know my current beliefs about the compilers I've checked 
out.<br>
</p>
<h2>Linux and Mac OS<br>
</h2>
<p>No current problems with <b>gcc</b> or <b>clang</b>.<br>
</p><h2>Windows</h2>
<p>For <b>gcc</b> variants in the MSYS2 development environment: <br>
</p>
<ul>
  <li><b>mingw-w64-ucrt-x86_64-gcc</b> (recommended for MSYS2):&nbsp; No current problems<br>
  </li>
  <li><b>mingw-w64-x86_64-gcc</b>:&nbsp; No current problems
  </li>
</ul>
For <b>clang</b> in the MSYS2 development environment:&nbsp; <br>
<ul>
  <li>Not suitable!&nbsp; There is a problem with variadic functions, specifically <code>vsnprintf</code>, that disastrously impacts the <b>XCOM-I</b> runtime library.<br>
  </li>
</ul>
For <b>cl</b> (Visual Studio command-line compiler):<br>
<ul>
  <li>No current problems<br>
</li>
</ul>
<h2>Cross-Compile (Linux to Windows)<br>
</h2>
<p>For Mingw-64 variants:<br>
</p>

<ul>
  <li><b>x86_64-w64-mingw32-gcc</b>:&nbsp; No current problems
  </li>
  <li><b>i686-w64-mingw32-gcc</b>:&nbsp; No current problems
  </li>
</ul>



    
<hr style="width: 100%; height: 2px;">
    
<center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-08-18<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i></center>


    <br>


  

</body></html>